export const metadata = {
  title: 'Quickstart',
  description:
    'This guide will get you all set up and ready to use the Protocol API. We’ll cover how to get started an API client and how to make your first API request.',
}

# Comprehensive Guide to JavaScript Objects

JavaScript objects are essential structures used to store collections of data and more complex entities. In essence, objects in JavaScript can be viewed as collections of properties.

**Defining Objects:**

An object is a collection of properties, where each property is a key-value pair. The key (or property name) is usually a string or a symbol, and the value can be any data type, including numbers, strings, or even functions.

**Comparison with Arrays:**

Unlike arrays which are indexed collections, objects hold named properties. This difference is crucial:
Arrays: Indexed by numbers, which makes them ideal for ordered collections where items are typically accessed sequentially.
Objects: Properties are accessed via keys, making them ideal for representing more structured data where each piece of data can be uniquely identified by a string key or symbol.

## Creating Objects

Objects can be created in JavaScript using different syntaxes, each serving various purposes and use cases.

**Object Literal Notation:**

This is the most straightforward and widely used method to create objects due to its clarity and conciseness.

```js
let car = {
  make: 'Toyota',
  model: 'Corolla',
  year: 2022
};
```

**Using the new Object() Syntax:**

While not as common for creating simple objects, the new Object() syntax can be useful in certain scenarios, though object literal notation is preferred for readability and simplicity.

```js
let car = new Object();
car.make = 'Toyota';
car.model = 'Corolla';
car.year = 2022;
```

## Accessing Properties

Once an object is created, accessing its properties can be done in two main ways, which are useful in different contexts.

**Dot Notation:**

The most common way to access properties in an object. It’s concise and easy to read, but it requires that the property name is a valid identifier.

```js
console.log(car.make); // Outputs: 'Toyota'
```

**Bracket Notation:**

This notation is powerful when accessing properties with dynamic names or names that aren't valid identifiers, such as spaces or special characters.

```js
console.log(car['model']); // Outputs: 'Corolla'
// Useful when property names are variables
let property = 'year';
console.log(car[property]); // Outputs: 2022
```

## Adding and Deleting Properties

JavaScript objects are dynamic, which means you can add or remove properties even after an object has been instantiated.

**Adding Properties:**

You can add new properties to an object at any time using either dot notation or bracket notation, depending on the situation.

```js
let car = { make: 'Toyota', model: 'Corolla', year: 2022 };
car.color = 'blue'; // Adding a new property
car['owner'] = 'John Doe'; // Adding another property using bracket notation
console.log(car); // Outputs: { make: 'Toyota', model: 'Corolla', year: 2022, color: 'blue', owner: 'John Doe' }
```

**Deleting Properties:**

The delete operator removes a property from an object. It's important to use this with caution to avoid unintentionally removing properties.

```js
delete car.year; // Removes the 'year' property
console.log(car); // Outputs: { make: 'Toyota', model: 'Corolla', color: 'blue', owner: 'John Doe' }
```

## Methods

Methods are functions that are stored as object properties, and they can use the object context to operate on the data that the object holds.

**Defining Methods:**

Here's how you can define a method within an object using function expressions.

```js
car.displayInfo = function() {
  return `${this.make} ${this.model}, owned by ${this.owner}`;
};
```

**Calling Methods:**

Methods can be invoked similar to how you access properties but with parentheses to indicate a function call.

```js
console.log(car.displayInfo()); // Outputs: 'Toyota Corolla, owned by John Doe'
```

## The this Keyword in Methods

The this keyword is pivotal within methods because it refers to the object from which the method is called, making it extremely useful for accessing other properties of the object.

**Understanding this:**

In the context of an object's method, this refers to the object itself. However, its value can change depending on the context in which a function is called, especially with callback functions or when passing methods as arguments.

```js
car.describe = function() {
  return `${this.make} from ${this.year}`;
};
console.log(car.describe()); // Correctly references `car` object properties

let describeFunc = car.describe;
console.log(describeFunc()); // Often incorrect; `this` might not refer to `car` if the function loses its context
```

**Binding this:**

If you need to ensure that this remains bound to the original object, you can use the bind method.

```js
let boundDescribe = describeFunc.bind(car);
console.log(boundDescribe()); // Now correctly outputs 'Toyota from undefined' as year is deleted
```

## Object Methods from Object Global

The global Object class in JavaScript provides several utility methods that can be incredibly useful for object manipulation and inspection. These methods can help you interact with objects more efficiently and understand their structure better.

**Key Methods:**

Object.keys(obj): Returns an array of a given object's own property names.

```js
console.log(Object.keys(car)); // ["make", "model", "color", "owner", "displayInfo", "describe"]
Object.values(obj): Returns an array of a given object's own enumerable property values.
```

```js
console.log(Object.values(car)); // ["Toyota", "Corolla", "blue", "John Doe", f, f]
Object.entries(obj): Returns an array of a given object's own enumerable string-keyed property [key, value] pairs.
```

```js
console.log(Object.entries(car)); // [["make", "Toyota"], ["model", "Corolla"], ...]
Object.assign(target, ...sources): Copies all enumerable own properties from one or more source objects to a target object.
```

```js
let newCar = Object.assign({}, car);
console.log(newCar);
Object.freeze(obj): Freezes an object. A frozen object can no longer be changed.
```

```js
Object.freeze(car);
car.newProperty = 'new'; // Will not have any effect
console.log(car);
Object.seal(obj): Prevents new properties from being added to an object and marks all existing properties as non-configurable.
```

```js
Object.seal(car);
delete car.owner; // Will not work
console.log(car);
```

## Constructors and Prototypes

JavaScript uses constructor functions and prototypes to provide object-oriented functionality in a way that can be more familiar to developers coming from class-based languages.

**Using Constructors:**

Constructor functions are used to create multiple instances of similar objects.

```js
function Car(make, model, year) {
  this.make = make;
  this.model = model;
  this.year = year;
}
let myCar = new Car('Honda', 'Civic', 2023);
console.log(myCar);
```

**Prototype Chain:**

Every JavaScript object has a prototype. An object's prototype is an object itself from which the object inherits methods and properties.

```js
Car.prototype.describe = function() {
  return `${this.make} ${this.model}, ${this.year}`;
};
console.log(myCar.describe()); // "Honda Civic, 2023"
```

## ES6+ Enhancements

Recent versions of JavaScript have introduced significant improvements to how objects can be handled, making code more intuitive and easier to manage.

**Class Syntax:**

ES6 introduced the class syntax which is syntactic sugar over JavaScript's existing prototype-based inheritance and makes it easier to write and manage constructors.

```js
class Vehicle {
  constructor(make, model) {
    this.make = make;
    this.model = model;
  }

  display() {
    return `${this.make} ${this.model}`;
  }
}
let myVehicle = new Vehicle('Ford', 'Mustang');
console.log(myVehicle.display()); // "Ford Mustang"
```

**Enhanced Object Literals:**

Object literals were enhanced to easily handle dynamic properties and concise method definitions.

```js
let brand = 'Ford';
let car = {
  [brand]: 'Mustang',
  year: 2025,
  displayInfo() {
    return `${this.Ford} ${this.year}`;
  }
};
console.log(car.displayInfo()); // "Mustang 2025"
```

## Practical Examples

JavaScript objects are incredibly versatile and can be used in a myriad of practical applications to organize and process data efficiently.

**Grouping Related Data and Functions:**

Objects are ideal for encapsulating attributes and behaviors of something in a structured way. For example, representing a user in a system:

```js
let user = {
  name: "John Doe",
  age: 30,
  login() {
    console.log(`${this.name} has logged in.`);
  }
};
user.login();  // Outputs: "John Doe has logged in."
```

**Using Objects as Dictionaries:**

Objects can serve as dictionaries with dynamic keys for storing data in a key-value pair format, which is useful for lookups and data management.

```js
let settings = {
  theme: "dark",
  notifications: true,
  updateSetting(key, value) {
    this[key] = value;
  }
};
settings.updateSetting('theme', 'light');
console.log(settings.theme); // Outputs: "light"
```

## Common Mistakes and Misconceptions

Understanding common pitfalls when working with objects can help prevent bugs and improve code reliability.

**Mutable Object References vs. Primitive Value Copies:**

A common error is not understanding that objects are passed by reference, not by value. This can lead to unintended side effects when objects are modified.

```js
let original = { value: 100 };
let copy = original;
copy.value = 200;
console.log(original.value); // Outputs: 200, because 'copy' is a reference to 'original'
```

**Misunderstanding this Context:**

The context of this can be confusing, especially in callbacks and events where this does not point to the object as expected.

```js
let person = {
  name: 'Jane',
  greet: function() {
    setTimeout(function() {
      console.log(`Hello, ${this.name}`);
    }, 1000);
  }
};
person.greet(); // Incorrectly outputs: "Hello, " because `this` in setTimeout doesn't point to `person`
```

## Advanced Topics

To further enhance your object manipulation skills, consider these advanced topics:

**Destructuring Objects:**

Destructuring provides a way to extract multiple properties from an object in a single statement, making it easier to handle objects.

```js
let { name, age } = user;
console.log(name); // Outputs: "John Doe"
console.log(age);  // Outputs: 30
```

**Using Map and Set:**

For collections of items where keys can be of any type and values need to be unique, the Map and Set objects offer more flexibility than regular objects.

```js
let map = new Map();
map.set(user, { role: 'Admin' });
console.log(map.get(user)); // Outputs: { role: 'Admin' }

let set = new Set();
set.add("apple");
set.add("banana");
console.log(set.has("apple")); // true
```

## Understanding Objects in JavaScript

Property Access

Objects in JavaScript allow you to store data in key-value pairs. Accessing or setting a property is generally O(1) under typical conditions. However, if properties are frequently added and deleted, some JavaScript engines may downgrade the hidden class of the object, potentially affecting performance.

Prototype Chain

Every JavaScript object has a prototype. When you attempt to access a property, it not only looks up on the object itself but also checks its prototype, and the prototype’s prototype, until it finds the property or reaches the end of the prototype chain. Understanding this can help in optimizing performance and avoiding unintended side effects.

## Common Mistakes and Misunderstandings

Using Objects as Maps

While it's common to use plain objects as maps from keys to values, there are pitfalls:

Prototype Pollution: Objects inherit properties from Object.prototype, which can lead to unexpected behavior if not handled properly. For instance, {} has a default toString property.
Only String and Symbol Keys: Before ES6, object keys could only be strings or symbols, any other value would be converted to a string.

Tip: Use Map for collections of key-value pairs; Map keys can be of any type and do not have the prototype pollution issue.

Modifying Objects During Iteration

Modifying an object (adding/removing properties) during iteration can lead to unexpected behavior because the iteration order is not guaranteed and might change as the object's structure changes.

## Performance Tips and Tricks

Object Destructuring

Destructuring is syntactically convenient and helps in writing cleaner code. It's particularly useful in function parameters or in extracting multiple properties from an object:

```js
const person = { name: 'John', age: 30, job: 'Developer' };
const { name, age } = person;
```

Efficient Cloning and Merging

Shallow Copy: Object.assign({}, obj) or \{ ...obj } for a quick shallow copy.
Deep Copy: For a deep copy, you might need a utility like JSON.parse(JSON.stringify(obj)), though be aware of its limitations with non-JSON-serializable data.

Property Enumeration

Use Object.keys(), Object.values(), and Object.entries() to iterate over properties. These methods only consider the object's own properties (ignoring the prototype chain).

## Advanced Usage

Immutable Object Patterns

For situations where immutability is necessary (e.g., in Redux state management), you should avoid directly modifying the object. Instead, use operations that return new objects:

```js
const newState = { ...state, newProp: 'value' };
```

Memoization with Objects

Objects can be useful for memoizing function results based on arguments:

```js
const memoizedResults = {};
function complexComputation(arg) {
  if (!memoizedResults[arg]) {
    memoizedResults[arg] = compute(arg); // Some expensive operation
  }
  return memoizedResults[arg];
}
```

Performance Considerations for Large Objects

For very large objects or when performance is critical, consider:

Minimizing the number of properties on an object, as more properties can lead to slower property access.

Using Map or other more specialized data structures depending on the operations needed (especially if frequent additions and deletions occur).

## Using Object.freeze and Object.seal

Object.freeze(): This method freezes an object, which means you can't add new properties, change existing properties, or delete properties. It's useful when you want to ensure that an object remains constant.
Object.seal(): This method seals an object, allowing you to change existing properties but not add new properties or delete any. It's useful for locking down objects to prevent structural changes while allowing their existing properties to be mutable.

## Performance Implications of Dynamic Property Access

Adding or deleting properties dynamically can significantly alter an object's shape, leading to potential deoptimizations:

Hidden Classes: JavaScript engines use hidden classes (or shapes) behind the scenes to optimize object access. Continuously adding new properties to an object can cause these optimizations to reset, reducing the efficiency of property access.
Avoid Premature Optimization: While it's important to be aware of performance, it's also crucial not to over-optimize early. Make code readable and maintainable first, then optimize based on actual performance measurements.

## Property Attributes and Descriptors

Understanding property attributes can be crucial in some scenarios:

Writable: Determines if the property value can be changed.
Enumerable: Determines if the property is enumerable in for-loops.
Configurable: Determines if the property can be deleted or changed.

You can use Object.defineProperty() to set these attributes explicitly, which is particularly useful when you need to create an API that hides internal properties or controls their mutability:

```js
Object.defineProperty(obj, 'key', {
  value: 'value',
  writable: false,
  enumerable: true,
  configurable: false
});
```

## Advanced Patterns: Proxy and Reflect

Proxy: JavaScript Proxy objects enable you to create a proxy for another object, which can intercept and redefine fundamental operations (like property lookup, assignment, enumeration, function invocation, etc.). This is particularly useful for creating reactive programming patterns, debugging, or performance monitoring wrappers.
Reflect: The Reflect API provides methods for interceptable JavaScript operations. This is especially handy in conjunction with Proxy, as it allows you to handle default actions on the target object easily.

## Edge Cases and Gotchas

Non-Object Values: Be careful when using methods like Object.keys() or Object.values() on non-object values (e.g., null or undefined), as these will throw a TypeError. Always ensure the data is properly validated or converted to an object form if necessary.
Enumerable Properties in Prototypes: Remember that properties inherited from a prototype are not listed by methods like Object.keys() unless they are directly on the object. This can be a source of bugs if not properly understood.