# **Network Flow Algorithms**

Network Flow Algorithms are used to find the maximum flow in a flow network. A flow network is a directed graph where each edge has a capacity, and the goal is to maximize the flow from the source to the sink while respecting the capacities.

## **Concept and Use Cases**

**Definition:**
Network flow problems involve finding the maximum flow from a source vertex to a sink vertex in a flow network. Each edge in the network has a capacity, and the flow through an edge cannot exceed its capacity.

**Common Use Cases:**
- Network routing
- Bipartite matching
- Circulation with demands
- Image segmentation

## **Key Concepts**

1. **Flow Network:**
   - A directed graph where each edge has a capacity and each vertex, except the source and sink, follows flow conservation.

2. **Residual Graph:**
   - A graph that shows the remaining capacities of edges after considering the current flow.

3. **Augmenting Path:**
   - A path from the source to the sink in the residual graph where the flow can be increased.

4. **Ford-Fulkerson Method:**
   - An algorithm to compute the maximum flow by finding augmenting paths and updating residual capacities.

5. **Edmonds-Karp Algorithm:**
   - An implementation of the Ford-Fulkerson method using Breadth-First Search (BFS) to find augmenting paths, ensuring polynomial time complexity.

## **Time and Space Complexity**

**Time Complexity:**
- Ford-Fulkerson Method: O(max_flow * E) in the worst case.
- Edmonds-Karp Algorithm: O(VE^2).

**Space Complexity:**
- Both algorithms: O(V + E) for storing the graph and residual capacities.

## **Network Flow Algorithms and Methods**

### **Ford-Fulkerson Method**

**Steps:**
1. Initialize the flow in all edges to 0.
2. While there exists an augmenting path from the source to the sink in the residual graph, augment the flow along this path.
3. Update the residual capacities and reverse edges accordingly.
4. The maximum flow is the total flow into the sink.

**Example:**
```javascript
class FordFulkerson {
    constructor(vertices) {
        this.V = vertices;
        this.graph = Array.from({ length: vertices }, () => []);
    }

    addEdge(u, v, capacity) {
        this.graph[u].push([v, capacity]);
        this.graph[v].push([u, 0]);  // Add reverse edge with 0 capacity
    }

    bfs(source, sink, parent) {
        const visited = Array(this.V).fill(false);
        const queue = [source];
        visited[source] = true;

        while (queue.length > 0) {
            const u = queue.shift();

            for (const [v, capacity] of this.graph[u]) {
                if (!visited[v] && capacity > 0) {
                    parent[v] = u;
                    if (v === sink) return true;
                    queue.push(v);
                    visited[v] = true;
                }
            }
        }

        return false;
    }

    fordFulkerson(source, sink) {
        let maxFlow = 0;
        const parent = Array(this.V).fill(-1);

        while (this.bfs(source, sink, parent)) {
            let pathFlow = Infinity;
            for (let v = sink; v !== source; v = parent[v]) {
                const u = parent[v];
                const capacity = this.graph[u].find(([vertex, cap]) => vertex === v)[1];
                pathFlow = Math.min(pathFlow, capacity);
            }

            for (let v = sink; v !== source; v = parent[v]) {
                const u = parent[v];
                const edge = this.graph[u].find(([vertex, cap]) => vertex === v);
                edge[1] -= pathFlow;
                const reverseEdge = this.graph[v].find(([vertex, cap]) => vertex === u);
                reverseEdge[1] += pathFlow;
            }

            maxFlow += pathFlow;
        }

        return maxFlow;
    }
}

// Example usage:
const graph = new FordFulkerson(6);
graph.addEdge(0, 1, 16);
graph.addEdge(0, 2, 13);
graph.addEdge(1, 2, 10);
graph.addEdge(1, 3, 12);
graph.addEdge(2, 1, 4);
graph.addEdge(2, 4, 14);
graph.addEdge(3, 2, 9);
graph.addEdge(3, 5, 20);
graph.addEdge(4, 3, 7);
graph.addEdge(4, 5, 4);

console.log(graph.fordFulkerson(0, 5));  // Output: 23
```

### **Edmonds-Karp Algorithm**

**Steps:**
1. Initialize the flow in all edges to 0.
2. Use BFS to find the shortest augmenting path in the residual graph.
3. Augment the flow along the path and update residual capacities.
4. Repeat until no more augmenting paths are found.
5. The maximum flow is the total flow into the sink.

**Example:**
```javascript
class EdmondsKarp {
    constructor(vertices) {
        this.V = vertices;
        this.graph = Array.from({ length: vertices }, () => []);
    }

    addEdge(u, v, capacity) {
        this.graph[u].push([v, capacity]);
        this.graph[v].push([u, 0]);  // Add reverse edge with 0 capacity
    }

    bfs(source, sink, parent) {
        const visited = Array(this.V).fill(false);
        const queue = [source];
        visited[source] = true;

        while (queue.length > 0) {
            const u = queue.shift();

            for (const [v, capacity] of this.graph[u]) {
                if (!visited[v] && capacity > 0) {
                    parent[v] = u;
                    if (v === sink) return true;
                    queue.push(v);
                    visited[v] = true;
                }
            }
        }

        return false;
    }

    edmondsKarp(source, sink) {
        let maxFlow = 0;
        const parent = Array(this.V).fill(-1);

        while (this.bfs(source, sink, parent)) {
            let pathFlow = Infinity;
            for (let v = sink; v !== source; v = parent[v]) {
                const u = parent[v];
                const capacity = this.graph[u].find(([vertex, cap]) => vertex === v)[1];
                pathFlow = Math.min(pathFlow, capacity);
            }

            for (let v = sink; v !== source; v = parent[v]) {
                const u = parent[v];
                const edge = this.graph[u].find(([vertex, cap]) => vertex === v);
                edge[1] -= pathFlow;
                const reverseEdge = this.graph[v].find(([vertex, cap]) => vertex === u);
                reverseEdge[1] += pathFlow;
            }

            maxFlow += pathFlow;
        }

        return maxFlow;
    }
}

// Example usage:
const graph = new EdmondsKarp(6);
graph.addEdge(0, 1, 16);
graph.addEdge(0, 2, 13);
graph.addEdge(1, 2, 10);
graph.addEdge(1, 3, 12);
graph.addEdge(2, 1, 4);
graph.addEdge(2, 4, 14);
graph.addEdge(3, 2, 9);
graph.addEdge(3, 5, 20);
graph.addEdge(4, 3, 7);
graph.addEdge(4, 5, 4);

console.log(graph.edmondsKarp(0, 5));  // Output: 23
```

## **Practical Tips and Tricks**

- **Choosing the Algorithm:**
  Use Edmonds-Karp for a straightforward implementation with BFS, ensuring polynomial time complexity.

- **Edge Cases:**
  Handle edge cases such as disconnected graphs and zero capacity edges appropriately.

- **Residual Graph:**
  Maintain and update the residual graph correctly to reflect the remaining capacities and reverse flows.

## **Common Gotchas**

- **Updating Residual Capacities:**
  Ensure both the forward and reverse edges are updated correctly in the residual graph.

- **BFS Implementation:**
  Implement BFS efficiently to find augmenting paths in Edmonds-Karp.

- **Cycle Detection:**
  Handle scenarios where cycles may form due to reverse flows.

## **Advanced Topics**

### **Capacity Scaling**

**Description:**
Capacity scaling is an optimization of the Ford-Fulkerson method that processes augmenting paths in decreasing order of capacities.

**Example:**
```javascript
class CapacityScaling {
    constructor(vertices) {
        this.V = vertices;
        this.graph = Array.from({ length: vertices }, () => []);
    }

    addEdge(u, v, capacity) {
        this.graph[u].push([v, capacity]);
        this.graph[v].push([u, 0]);  // Add reverse edge with 0 capacity
    }

    bfs(source, sink, parent, minCapacity) {
        const visited = Array(this.V).fill(false);
        const queue = [source];
        visited[source] = true;

        while (queue.length > 0) {
            const u = queue.shift();

            for (const [v, capacity] of this.graph[u]) {
                if (!visited[v] && capacity >= minCapacity) {
                    parent[v] = u;
                    if (v === sink) return true;
                    queue.push(v);
                    visited[v] = true;
                }
            }
        }

        return false;
    }

    capacityScaling(source, sink) {
        let maxFlow = 0;
        const parent = Array(this.V).fill(-1);
        let maxCapacity = Math.max(...this.graph.flat().map(([_, capacity]) => capacity));

        let scale = 1;
        while (scale <= maxCapacity) scale *= 2;

        while (scale > 0) {
            while (this.bfs(source, sink, parent, scale)) {
                let pathFlow = Infinity;
                for (let v = sink; v !== source; v = parent[v]) {
                    const u = parent[v];
                    const capacity = this.graph[u].find(([vertex, cap]) => vertex === v)[1];
                    pathFlow = Math.min(pathFlow, capacity);
                }

                for (let v = sink; v !== source; v = parent[v]) {
                    const u = parent[v];
                    const edge = this.graph[u].find(([vertex, cap]) => vertex === v);
                    edge[1] -= pathFlow;
                    const reverseEdge = this.graph[v].find(([vertex, cap]) => vertex === u);
                    reverseEdge[1] += pathFlow;
                }

                maxFlow += pathFlow;
            }
            scale = Math.floor(scale / 2);
        }

        return maxFlow;
    }
}

// Example usage:
const graph = new CapacityScaling(6);
graph.addEdge(0, 1, 16);
graph.addEdge(0, 2, 13);
graph.addEdge(1, 2, 10);
graph.addEdge(1, 3, 12);
graph.addEdge(2, 1, 4);
graph.addEdge(2, 4, 14);
graph.addEdge(3, 2, 9);
graph.addEdge(3, 5, 20);
graph.addEdge(4, 3, 7);
graph.addEdge(4, 5, 4);

console.log(graph.capacityScaling(0, 5));  // Output: 23
```

### **Dinic's Algorithm**

**Description:**
Dinic's algorithm is a highly efficient algorithm for computing maximum flow in a flow network, with a time complexity of O(V^2 E).

**Example:**
```javascript
class Dinic {
    constructor(vertices) {
        this.V = vertices;
        this.graph = Array.from({ length: vertices }, () => []);
        this.level = Array(vertices).fill(-1);
    }

    addEdge(u, v, capacity) {
        this.graph[u].push([v, capacity, this.graph[v].length]);
        this.graph[v].push([u, 0, this.graph[u].length - 1]);
    }

    bfs(source, sink) {
        this.level.fill(-1);
        this.level[source] = 0;
        const queue = [source];

        while (queue.length > 0) {
            const u = queue.shift();

            for (const [v, capacity] of this.graph[u]) {
                if (this.level[v] === -1 && capacity > 0) {
                    this.level[v] = this.level[u] + 1;
                    queue.push(v);
                }
            }
        }

        return this.level[sink] !== -1;
    }

    dfs(u, sink, flow) {
        if (u === sink) return flow;

        for (let i = 0; i < this.graph[u].length; i++) {
            const [v, capacity, rev] = this.graph[u][i];

            if (this.level[v] === this.level[u] + 1 && capacity > 0) {
                const minFlow = this.dfs(v, sink, Math.min(flow, capacity));
                if (minFlow > 0) {
                    this.graph[u][i][1] -= minFlow;
                    this.graph[v][rev][1] += minFlow;
                    return minFlow;
                }
            }
        }

        return 0;
    }

    dinic(source, sink) {
        let maxFlow = 0;

        while (this.bfs(source, sink)) {
            let flow;
            while ((flow = this.dfs(source, sink, Infinity)) > 0) {
                maxFlow += flow;
            }
        }

        return maxFlow;
    }
}

// Example usage:
const graph = new Dinic(6);
graph.addEdge(0, 1, 16);
graph.addEdge(0, 2, 13);
graph.addEdge(1, 2, 10);
graph.addEdge(1, 3, 12);
graph.addEdge(2, 1, 4);
graph.addEdge(2, 4, 14);
graph.addEdge(3, 2, 9);
graph.addEdge(3, 5, 20);
graph.addEdge(4, 3, 7);
graph.addEdge(4, 5, 4);

console.log(graph.dinic(0, 5));  // Output: 23
```

## **Interview Tips and Tricks**

- **Explain the Algorithms:**
  Clearly explain the steps of Ford-Fulkerson, Edmonds-Karp, and other algorithms.

- **Residual Graph:**
  Discuss the importance of the residual graph and how it is updated.

- **Cycle Detection:**
  Explain how reverse flows are handled and how cycles are detected.

- **Edge Cases:**
  Handle edge cases, such as disconnected graphs and zero capacity edges, appropriately.

## **Common Mistakes**

- **Updating Residual Capacities:**
  Ensure both the forward and reverse edges are updated correctly in the residual graph.

- **BFS and DFS Implementation:**
  Implement BFS and DFS efficiently to find augmenting paths.

- **Initialization:**
  Ensure all distances and flows are initialized correctly.

By mastering Network Flow algorithms and understanding their intricacies, you will be well-equipped to handle a variety of flow network problems. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.