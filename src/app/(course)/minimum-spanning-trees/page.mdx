# **Minimum Spanning Trees (MST)**

A Minimum Spanning Tree (MST) is a subset of the edges in a connected, undirected graph that connects all the vertices together, without any cycles, and with the minimum possible total edge weight. There are two primary algorithms used to find the MST: Kruskal's and Prim's algorithms.

## **Concept and Use Cases**

**Definition:**
A Minimum Spanning Tree of a graph is a tree that spans all the vertices and has the minimum total edge weight.

**Common Use Cases:**
- Network design (e.g., designing least-cost networks for telecommunications, electrical grids).
- Approximation algorithms for NP-hard problems (e.g., traveling salesman problem).
- Cluster analysis in machine learning.

## **Key Concepts**

1. **Spanning Tree:**
   - A subgraph that includes all the vertices of the original graph with no cycles.
   
2. **Kruskal's Algorithm:**
   - An MST algorithm that adds edges in increasing order of weight, ensuring no cycles are formed.

3. **Prim's Algorithm:**
   - An MST algorithm that grows the MST one vertex at a time, starting from an arbitrary vertex.

## **Time and Space Complexity**

**Time Complexity:**
- Kruskal's Algorithm: O(E log E) due to sorting of edges.
- Prim's Algorithm: O(E log V) using a priority queue.

**Space Complexity:**
- Both algorithms: O(V + E) for storing the graph.

## **MST Algorithms and Methods**

### **Kruskal's Algorithm**

**Steps:**
1. Sort all the edges in non-decreasing order of their weight.
2. Pick the smallest edge. Check if it forms a cycle with the spanning tree formed so far. If a cycle is not formed, include this edge. Else, discard it.
3. Repeat step 2 until there are (V-1) edges in the spanning tree.

**Example:**
```javascript
class UnionFind {
    constructor(size) {
        this.parent = Array(size).fill(0).map((_, index) => index);
        this.rank = Array(size).fill(0);
    }

    find(x) {
        if (this.parent[x] !== x) {
            this.parent[x] = this.find(this.parent[x]);  // Path compression
        }
        return this.parent[x];
    }

    union(x, y) {
        const rootX = this.find(x);
        const rootY = this.find(y);

        if (rootX !== rootY) {
            if (this.rank[rootX] > this.rank[rootY]) {
                this.parent[rootY] = rootX;
            } else if (this.rank[rootX] < this.rank[rootY]) {
                this.parent[rootX] = rootY;
            } else {
                this.parent[rootY] = rootX;
                this.rank[rootX]++;
            }
        }
    }
}

class KruskalMST {
    constructor(vertices) {
        this.V = vertices;
        this.edges = [];
    }

    addEdge(u, v, w) {
        this.edges.push([u, v, w]);
    }

    kruskalMST() {
        this.edges.sort((a, b) => a[2] - b[2]);
        const uf = new UnionFind(this.V);
        const result = [];
        let e = 0;
        let i = 0;

        while (e < this.V - 1 && i < this.edges.length) {
            const [u, v, w] = this.edges[i++];
            const x = uf.find(u);
            const y = uf.find(v);

            if (x !== y) {
                result.push([u, v, w]);
                uf.union(x, y);
                e++;
            }
        }

        return result;
    }
}

// Example usage:
const graph = new KruskalMST(4);
graph.addEdge(0, 1, 10);
graph.addEdge(0, 2, 6);
graph.addEdge(0, 3, 5);
graph.addEdge(1, 3, 15);
graph.addEdge(2, 3, 4);

console.log(graph.kruskalMST());
// Output: [ [ 2, 3, 4 ], [ 0, 3, 5 ], [ 0, 1, 10 ] ]
```

### **Prim's Algorithm**

**Steps:**
1. Initialize a priority queue to store vertices that are being preprocessed. Initialize all key values as infinity. Initialize the key value of the first vertex to 0.
2. Extract the vertex with the minimum key value. Add it to the MST.
3. Update the key values of all adjacent vertices of the extracted vertex. If the current key value is greater than the new key value, update it.

**Example:**
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }

    insert(key, value) {
        this.heap.push({ key, value });
        this.bubbleUp();
    }

    extractMin() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();

        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown();
        return min;
    }

    bubbleUp() {
        let index = this.heap.length - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].key >= this.heap[parentIndex].key) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    bubbleDown() {
        let index = 0;
        const length = this.heap.length;
        const element = this.heap[0];

        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swapIndex = null;

            if (leftChildIndex < length) {
                leftChild = this.heap[leftChildIndex];
                if (leftChild.key < element.key) {
                    swapIndex = leftChildIndex;
                }
            }

            if (rightChildIndex < length) {
                rightChild = this.heap[rightChildIndex];
                if (
                    (swapIndex === null && rightChild.key < element.key) ||
                    (swapIndex !== null && rightChild.key < leftChild.key)
                ) {
                    swapIndex = rightChildIndex;
                }
            }

            if (swapIndex === null) break;
            [this.heap[index], this.heap[swapIndex]] = [this.heap[swapIndex], this.heap[index]];
            index = swapIndex;
        }
    }

    isEmpty() {
        return this.heap.length === 0;
    }
}

class PrimMST {
    constructor(vertices) {
        this.V = vertices;
        this.adj = new Map();
    }

    addEdge(u, v, w) {
        if (!this.adj.has(u)) this.adj.set(u, []);
        if (!this.adj.has(v)) this.adj.set(v, []);
        this.adj.get(u).push([v, w]);
        this.adj.get(v).push([u, w]);
    }

    primMST() {
        const key = Array(this.V).fill(Infinity);
        const parent = Array(this.V).fill(-1);
        const minHeap = new MinHeap();
        const inMST = Array(this.V).fill(false);

        key[0] = 0;
        minHeap.insert(0, key[0]);

        while (!minHeap.isEmpty()) {
            const { value: u } = minHeap.extractMin();
            inMST[u] = true;

            const neighbors = this.adj.get(u);
            for (let [v, weight] of neighbors) {
                if (!inMST[v] && key[v] > weight) {
                    key[v] = weight;
                    minHeap.insert(key[v], v);
                    parent[v] = u;
                }
            }
        }

        const result = [];
        for (let i = 1; i < this.V; i++) {
            result.push([parent[i], i, key[i]]);
        }
        return result;
    }
}

// Example usage:
const graph = new PrimMST(5);
graph.addEdge(0, 1, 2);
graph.addEdge(0, 3, 6);
graph.addEdge(1, 2, 3);
graph.addEdge(1, 3, 8);
graph.addEdge(1, 4, 5);
graph.addEdge(2, 4, 7);
graph.addEdge(3, 4, 9);

console.log(graph.primMST());
// Output: [ [ 0, 1, 2 ], [ 1, 2, 3 ], [ 0, 3, 6 ], [ 1, 4, 5 ] ]
```

## **Practical Tips and Tricks**

- **Choosing the Algorithm:**
  Use Kruskal's algorithm when the graph is sparse (few edges). Use Prim's algorithm when the graph is dense (many edges).

- **Edge Cases:**
  Handle edge cases such as disconnected graphs appropriately. MST algorithms assume the graph is connected.

- **Heap Implementation:**
  Implement a priority queue (min-heap) efficiently to optimize Prim's algorithm.

## **Common Gotchas**

- **Cycle Detection:**
  Ensure cycle detection in Kruskal's algorithm by correctly implementing the union-find structure.

- **Edge Sorting:**
  Ensure edges are sorted by weight in non-decreasing order for Kruskal's algorithm.

- **Disconnected Graphs:**
  Handle scenarios where the graph might be disconnected, as MST requires a connected graph.

## **Advanced Topics**

### **Borůvka's Algorithm**

**Description:**
Borůvka's algorithm is another MST algorithm that repeatedly adds the shortest edge from each component to a different component until only one component remains.

**Example:**
```javascript
class BoruvkaMST {
    constructor(vertices) {
        this.V = vertices;
        this.edges = [];
    }

    addEdge(u, v, w) {
        this.edges.push([u, v, w]);
    }

    boruvkaMST() {
        const uf = new UnionFind(this.V);
        const result = [];
        let numTrees = this.V;
        let MSTweight = 0;

        while (numTrees > 1) {
            const cheapest = Array(this.V).fill(null);

            for (let [u, v, w] of this.edges) {
                const set1 = uf.find(u);
                const set2 = uf.find(v);

                if (set1 !== set2) {
                    if (cheapest[set1] === null || cheapest[set1][2] > w) {
                        cheapest[set1] = [u, v, w];
                    }

                    if (cheapest[set2] === null || cheapest[set2][2] > w) {
                        cheapest[set2] = [u, v, w];
                    }
                }
            }

            for (let i = 0; i < this.V; i++) {
                if (cheapest[i] !== null) {
                    const [u, v, w] = cheapest[i];
                    const set1 = uf.find(u);
                    const set2 = uf.find(v);

                    if (set1 !== set2) {
                        uf.union(set1, set2);
                        result.push([u, v, w]);
                        MSTweight += w;
                        numTrees--;
                    }
                }
            }
        }

        return { MSTweight, result };
    }
}

// Example usage:
const graph = new BoruvkaMST(4);
graph.addEdge(0, 1, 10);
graph.addEdge(0, 2, 6);
graph.addEdge(0, 3, 5);
graph.addEdge(1, 3, 15);
graph.addEdge(2, 3, 4);

console.log(graph.boruvkaMST());
// Output: { MSTweight: 19, result: [ [ 0, 3, 5 ], [ 2, 3, 4 ], [ 0, 1, 10 ] ] }
```

### **Comparison of MST Algorithms**

- **Kruskal's Algorithm:**
  - Suitable for sparse graphs.
  - Time Complexity: O(E log E)
  - Uses Union-Find for cycle detection.

- **Prim's Algorithm:**
  - Suitable for dense graphs.
  - Time Complexity: O(E log V) using a priority queue.
  - Greedily expands the MST from a starting vertex.

- **Borůvka's Algorithm:**
  - Suitable for parallel implementation.
  - Time Complexity: O(E log V)
  - Adds the shortest edge from each component iteratively.

## **Interview Tips and Tricks**

- **Explain the Algorithms:**
  Clearly explain the steps of Kruskal's and Prim's algorithms, and their differences.

- **Union-Find in Kruskal's:**
  Demonstrate the use of Union-Find for cycle detection in Kruskal's algorithm.

- **Priority Queue in Prim's:**
  Discuss the importance of a priority queue (min-heap) in optimizing Prim's algorithm.

- **Edge Cases:**
  Handle edge cases, such as disconnected graphs, appropriately.

## **Common Mistakes**

- **Cycle Detection in Kruskal's:**
  Incorrect implementation of the Union-Find structure can lead to incorrect cycle detection.

- **Edge Sorting in Kruskal's:**
  Ensure edges are sorted correctly by weight in non-decreasing order.

- **Priority Queue in Prim's:**
  Implement the priority queue efficiently to optimize Prim's algorithm.

By mastering Minimum Spanning Tree algorithms and understanding their intricacies, you will be well-equipped to handle a variety of graph-related problems. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.