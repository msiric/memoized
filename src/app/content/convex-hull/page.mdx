# **Convex Hull**

The Convex Hull of a set of points is the smallest convex polygon that contains all the points. It is a fundamental problem in computational geometry with applications in computer graphics, pattern recognition, and geographic information systems.

## **Concept and Use Cases**

**Definition:**
The Convex Hull of a set of points is the smallest convex polygon that encloses all the points. It can be visualized as the shape formed by stretching a rubber band around the set of points.

**Common Use Cases:**
- Computer graphics (e.g., collision detection, shape analysis)
- Pattern recognition
- Geographic information systems (e.g., finding the boundary of a set of geographical locations)

## **Key Concepts**

1. **Convex Polygon:**
   - A polygon where all interior angles are less than 180 degrees, and no line segment between any two points on the boundary goes outside the polygon.

2. **Graham Scan:**
   - An algorithm that sorts the points by polar angle with respect to a reference point and then constructs the hull using a stack.

3. **Jarvis March (Gift Wrapping):**
   - An algorithm that starts from the leftmost point and wraps around the set of points to form the hull.

## **Time and Space Complexity**

**Graham Scan:**
- Time Complexity: O(n log n) due to sorting.
- Space Complexity: O(n) for storing the hull points.

**Jarvis March:**
- Time Complexity: O(nh), where h is the number of points in the hull.
- Space Complexity: O(n) for storing the hull points.

## **Convex Hull Algorithms and Methods**

### **Graham Scan Algorithm**

**Steps:**
1. Find the point with the lowest y-coordinate (and the leftmost if there are ties).
2. Sort the points by polar angle with respect to the reference point.
3. Traverse the sorted points and maintain a stack to build the hull.

**Example:**
```javascript
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

function crossProduct(o, a, b) {
    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);
}

function grahamScan(points) {
    if (points.length < 3) return points;

    // Find the point with the lowest y-coordinate
    const start = points.reduce((lowest, point) => {
        if (point.y < lowest.y || (point.y === lowest.y && point.x < lowest.x)) {
            return point;
        }
        return lowest;
    }, points[0]);

    // Sort points by polar angle with respect to the start point
    points.sort((a, b) => {
        const cp = crossProduct(start, a, b);
        if (cp === 0) {
            return Math.hypot(start.x - a.x, start.y - a.y) - Math.hypot(start.x - b.x, start.y - b.y);
        }
        return cp;
    });

    const hull = [];
    for (let point of points) {
        while (hull.length >= 2 && crossProduct(hull[hull.length - 2], hull[hull.length - 1], point) <= 0) {
            hull.pop();
        }
        hull.push(point);
    }

    return hull;
}

// Example usage:
const points = [new Point(0, 3), new Point(2, 2), new Point(1, 1), new Point(2, 1), new Point(3, 0), new Point(0, 0), new Point(3, 3)];
const hull = grahamScan(points);
console.log(hull);  // Output: Convex hull points in order
```

### **Jarvis March (Gift Wrapping) Algorithm**

**Steps:**
1. Start from the leftmost point.
2. Select the next point such that all other points are to the right of the line formed by the current point and the next point.
3. Repeat until the hull is completed.

**Example:**
```javascript
class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

function orientation(p, q, r) {
    const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
    if (val === 0) return 0; // collinear
    return val > 0 ? 1 : 2; // clock or counterclock wise
}

function jarvisMarch(points) {
    if (points.length < 3) return points;

    const hull = [];
    let l = 0;

    // Find the leftmost point
    for (let i = 1; i < points.length; i++) {
        if (points[i].x < points[l].x) {
            l = i;
        }
    }

    let p = l, q;
    do {
        hull.push(points[p]);

        q = (p + 1) % points.length;
        for (let i = 0; i < points.length; i++) {
            if (orientation(points[p], points[i], points[q]) === 2) {
                q = i;
            }
        }

        p = q;

    } while (p !== l);

    return hull;
}

// Example usage:
const points = [new Point(0, 3), new Point(2, 2), new Point(1, 1), new Point(2, 1), new Point(3, 0), new Point(0, 0), new Point(3, 3)];
const hull = jarvisMarch(points);
console.log(hull);  // Output: Convex hull points in order
```

## **Practical Tips and Tricks**

- **Choosing the Algorithm:**
  Use Graham scan for larger datasets due to its O(n log n) complexity. Use Jarvis March for smaller datasets or when the number of hull points (h) is much smaller than the total number of points (n).

- **Handling Collinear Points:**
  Properly handle collinear points when sorting or selecting the next hull point.

- **Precision Issues:**
  Be mindful of precision issues when working with floating-point coordinates. Consider using integer coordinates when possible.

## **Common Gotchas**

- **Degenerate Cases:**
  Handle degenerate cases such as all points being collinear or the input set containing fewer than three points.

- **Duplicate Points:**
  Ensure that duplicate points are handled appropriately to avoid incorrect hull construction.

- **Edge Cases:**
  Consider edge cases such as points forming a perfect circle or multiple points having the same polar angle with respect to the reference point.

## **Advanced Topics**

### **Chan's Algorithm**

**Description:**
Chan's algorithm is an optimal O(n log h) algorithm for finding the convex hull of a set of points, where h is the number of points in the hull. It combines the ideas of Graham scan and Jarvis March.

### **Divide and Conquer Algorithm**

**Description:**
A divide-and-conquer approach for finding the convex hull, which recursively divides the set of points into smaller subsets, finds the convex hull for each subset, and then merges the hulls.

**Example:**
```javascript
function mergeHulls(hull1, hull2) {
    // Implementation of merging two convex hulls
}

function divideAndConquer(points) {
    if (points.length <= 3) return grahamScan(points);

    const mid = Math.floor(points.length / 2);
    const leftHull = divideAndConquer(points.slice(0, mid));
    const rightHull = divideAndConquer(points.slice(mid));

    return mergeHulls(leftHull, rightHull);
}

// Example usage:
const points = [new Point(0, 3), new Point(2, 2), new Point(1, 1), new Point(2, 1), new Point(3, 0), new Point(0, 0), new Point(3, 3)];
const hull = divideAndConquer(points);
console.log(hull);  // Output: Convex hull points in order
```

## **Interview Tips and Tricks**

- **Explain the Algorithms:**
  Clearly explain the steps of Graham scan and Jarvis March algorithms, and their differences.

- **Handling Edge Cases:**
  Discuss how to handle edge cases, such as collinear points, degenerate cases, and precision issues.

- **Optimizations:**
  Highlight potential optimizations and when to use each algorithm based on the input size and characteristics.

- **Use Cases:**
  Provide examples of practical use cases for convex hull algorithms.

## **Common Mistakes**

- **Incorrect Sorting:**
  Ensure points are sorted correctly by polar angle in the Graham scan algorithm.

- **Handling Collinear Points:**
  Properly handle collinear points to avoid incorrect hull construction.

- **Memory Consumption:**
  Be mindful of memory consumption, especially with large input datasets.

By mastering Convex Hull algorithms and understanding their intricacies, you will be well-equipped to handle a variety of geometric problems with efficient and robust solutions. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.