# Advanced React: TypeScript Patterns

## Concept and Use Cases

**Definition:**
Advanced React TypeScript patterns involve combining TypeScript's type system with React patterns to create type-safe, reusable, and maintainable components and hooks.

**Common Use Cases:**

- Generic components
- Type-safe hooks
- Polymorphic components
- Component composition
- State management
- Event handling
- Form validation
- API integration

### Visual Representation:

```
TypeScript Pattern Layers:

Type Safety → Component Types → Hook Types → Pattern Types
     ↓              ↓               ↓             ↓
Generics     Polymorphic Comp    Inferred     Utility Types
```

## Key Patterns

1. **Generic Components:**

   - Type parameters
   - Constraints
   - Defaults

2. **Polymorphic Components:**

   - Dynamic element types
   - Prop inheritance
   - Type inference

3. **Type-Safe Hooks:**
   - Generic hooks
   - Type inference
   - Type guards

## Implementation Examples

### 1. Generic Components

```typescript
// Generic list component with type-safe rendering
interface ListProps<T> {
    items: T[];
    getKey: (item: T) => string | number;
    renderItem: (item: T) => React.ReactNode;
    onItemClick?: (item: T) => void;
}

function List<T>({
    items,
    getKey,
    renderItem,
    onItemClick
}: ListProps<T>) {
    const handleClick = useCallback((item: T) => {
        onItemClick?.(item);
    }, [onItemClick]);

    return (
        <ul>
            {items.map(item => (
                <li
                    key={getKey(item)}
                    onClick={() => handleClick(item)}
                    role={onItemClick ? 'button' : undefined}
                    tabIndex={onItemClick ? 0 : undefined}
                >
                    {renderItem(item)}
                </li>
            ))}
        </ul>
    );
}

// Type-safe composite component
interface CompositeProps<T> {
    data: T;
    components: {
        [K in keyof T]: React.ComponentType<{ value: T[K] }>;
    };
}

function Composite<T extends Record<string, any>>({
    data,
    components
}: CompositeProps<T>) {
    return (
        <div>
            {(Object.keys(data) as Array<keyof T>).map(key => {
                const Component = components[key];
                return (
                    <Component
                        key={key as string}
                        value={data[key]}
                    />
                );
            })}
        </div>
    );
}
```

### 2. Polymorphic Components

```typescript
// Type-safe polymorphic component
type AsProp<C extends React.ElementType> = {
    as?: C;
};

type PropsToOmit<C extends React.ElementType, P> = keyof (AsProp<C> & P);

type PolymorphicComponentProp<
    C extends React.ElementType,
    Props = {}
> = React.PropsWithChildren<Props & AsProp<C>> &
    Omit<React.ComponentPropsWithoutRef<C>, PropsToOmit<C, Props>>;

type PolymorphicRef<C extends React.ElementType> = React.ComponentPropsWithRef<C>['ref'];

type PolymorphicComponentPropWithRef<
    C extends React.ElementType,
    Props = {}
> = PolymorphicComponentProp<C, Props> & { ref?: PolymorphicRef<C> };

type TextProps<C extends React.ElementType> = PolymorphicComponentPropWithRef<
    C,
    { variant?: 'h1' | 'h2' | 'h3' | 'body' }
>;

type TextComponent = <C extends React.ElementType = 'span'>(
    props: TextProps<C>
) => React.ReactElement | null;

const Text: TextComponent = React.forwardRef(
    <C extends React.ElementType = 'span'>(
        { as, variant, children, ...props }: TextProps<C>,
        ref?: PolymorphicRef<C>
    ) => {
        const Component = as || 'span';
        const className = variant ? `text-${variant}` : undefined;

        return (
            <Component
                {...props}
                ref={ref}
                className={className}
            >
                {children}
            </Component>
        );
    }
);

// Usage
function Example() {
    return (
        <>
            <Text>Default span</Text>
            <Text as="h1" variant="h1">Heading 1</Text>
            <Text as="label" htmlFor="input">Label</Text>
            <Text as="a" href="/">Link</Text>
        </>
    );
}
```

### 3. Type-Safe Hooks

```typescript
// Generic state management hook
type ActionMap<M extends { [index: string]: any }> = {
  [Key in keyof M]: M[Key] extends undefined
    ? { type: Key }
    : { type: Key; payload: M[Key] }
}

interface State<T> {
  data: T | null
  loading: boolean
  error: Error | null
}

type ActionPayload<T> = {
  SET_DATA: T
  SET_ERROR: Error
  SET_LOADING: boolean
  RESET: undefined
}

type Actions<T> = ActionMap<ActionPayload<T>>[keyof ActionMap<ActionPayload<T>>]

function createStateHook<T>() {
  function reducer(state: State<T>, action: Actions<T>): State<T> {
    switch (action.type) {
      case 'SET_DATA':
        return { ...state, data: action.payload, loading: false }
      case 'SET_ERROR':
        return { ...state, error: action.payload, loading: false }
      case 'SET_LOADING':
        return { ...state, loading: action.payload }
      case 'RESET':
        return { data: null, loading: false, error: null }
      default:
        return state
    }
  }

  return function useCustomState(initialData?: T) {
    const [state, dispatch] = useReducer(reducer, {
      data: initialData || null,
      loading: false,
      error: null,
    })

    const setData = useCallback((data: T) => {
      dispatch({ type: 'SET_DATA', payload: data })
    }, [])

    const setError = useCallback((error: Error) => {
      dispatch({ type: 'SET_ERROR', payload: error })
    }, [])

    const setLoading = useCallback((loading: boolean) => {
      dispatch({ type: 'SET_LOADING', payload: loading })
    }, [])

    const reset = useCallback(() => {
      dispatch({ type: 'RESET' })
    }, [])

    return {
      ...state,
      setData,
      setError,
      setLoading,
      reset,
    }
  }
}

// Type-safe form hook
type FieldValidator<T> = (value: T) => string | undefined

interface FieldConfig<T> {
  validate?: FieldValidator<T>
  initialValue: T
}

type FormConfig<T> = {
  [K in keyof T]: FieldConfig<T[K]>
}

function useForm<T extends Record<string, any>>(config: FormConfig<T>) {
  type FormState = {
    values: T
    errors: Partial<Record<keyof T, string>>
    touched: Partial<Record<keyof T, boolean>>
  }

  const [state, setState] = useState<FormState>({
    values: Object.entries(config).reduce(
      (acc, [key, field]) => ({
        ...acc,
        [key]: field.initialValue,
      }),
      {},
    ) as T,
    errors: {},
    touched: {},
  })

  const validateField = useCallback(
    (name: keyof T, value: T[keyof T]) => {
      const validator = config[name].validate
      return validator ? validator(value) : undefined
    },
    [config],
  )

  const setFieldValue = useCallback(
    (name: keyof T, value: T[keyof T]) => {
      setState((prev) => {
        const error = validateField(name, value)
        return {
          ...prev,
          values: { ...prev.values, [name]: value },
          errors: { ...prev.errors, [name]: error },
        }
      })
    },
    [validateField],
  )

  const setFieldTouched = useCallback((name: keyof T) => {
    setState((prev) => ({
      ...prev,
      touched: { ...prev.touched, [name]: true },
    }))
  }, [])

  return {
    values: state.values,
    errors: state.errors,
    touched: state.touched,
    setFieldValue,
    setFieldTouched,
  }
}
```

### 4. Advanced Type Utilities

```typescript
// Component prop type extraction
type ExtractProps<T> = T extends React.ComponentType<infer P> ? P : never

type ExtractRef<T> =
  T extends React.ForwardRefExoticComponent<infer P>
    ? P extends { ref?: infer R }
      ? R
      : never
    : never

// Discriminated union helper
type DiscriminateUnion<T, K extends keyof T, V extends T[K]> =
  T extends Record<K, V> ? T : never

// Deep partial type
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

// Strict object keys
type StrictObjectKeys<T> = {
  [K in keyof T]: K extends string ? (T[K] extends Function ? never : K) : never
}[keyof T]

// Type-safe event handlers
type TypedEventHandler<T extends Element> = (
  event: React.SyntheticEvent<T>,
) => void

type TypedChangeHandler<T extends Element> = (
  event: React.ChangeEvent<T>,
) => void

// Component with strict props
interface StrictComponentProps {
  required: string
  optional?: number
  children: React.ReactNode
}

function StrictComponent(props: Readonly<StrictComponentProps>) {
  return null
}
```

## Interview Tips and Tricks

1. **Type System Understanding:**

   - Advanced TypeScript features
   - Type inference
   - Generics usage

2. **Best Practices:**

   - Type safety
   - Code reusability
   - Performance implications

3. **Common Pitfalls:**
   - Over-engineering
   - Type complexity
   - Performance impact

## Common Interview Questions

1. How do you implement generic components effectively?
2. What are your strategies for type-safe hooks?
3. How do you handle polymorphic components?
4. What patterns do you use for type-safe forms?
5. How do you balance type safety and code complexity?
6. What are your favorite TypeScript utility types?
7. How do you handle complex type inference scenarios?

Understanding advanced TypeScript patterns in React is crucial for building robust and maintainable applications. It involves leveraging TypeScript's type system while maintaining clean and efficient code.
