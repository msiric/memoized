# Advanced Frontend: Web Workers and Worklets

## Concept and Use Cases

**Definition:**
Web Workers and Worklets enable parallel processing and background tasks in web applications, allowing heavy computations to run without blocking the main thread.

**Common Use Cases:**

- Complex calculations
- Data processing
- Image manipulation
- Encryption/Decryption
- File operations
- Real-time processing
- Background sync
- Custom rendering

### Visual Representation:

```
Parallel Processing Model:

Main Thread → Message Bus → Worker Threads
    ↓             ↓              ↓
   UI         Transfer     Computation
```

## Key Concepts

1. **Worker Types:**

   - Dedicated Workers
   - Shared Workers
   - Service Workers
   - Worklets

2. **Communication:**

   - Message passing
   - Transferable objects
   - Shared memory

3. **Performance:**
   - Thread management
   - Resource allocation
   - Task scheduling

## Implementation Examples

### 1. Advanced Worker Management

```typescript
// Worker pool implementation
interface WorkerTask {
  id: string
  type: string
  data: any
}

interface WorkerResponse {
  taskId: string
  result: any
  error?: Error
}

class WorkerPool {
  private workers: Worker[] = []
  private taskQueue: WorkerTask[] = []
  private busyWorkers: Set<Worker> = new Set()
  private callbacks: Map<
    string,
    {
      resolve: (value: any) => void
      reject: (error: Error) => void
    }
  > = new Map()

  constructor(
    private workerScript: string,
    private poolSize: number = navigator.hardwareConcurrency || 4,
  ) {
    this.initialize()
  }

  private initialize(): void {
    for (let i = 0; i < this.poolSize; i++) {
      const worker = new Worker(this.workerScript)
      worker.onmessage = this.handleWorkerMessage.bind(this, worker)
      worker.onerror = this.handleWorkerError.bind(this, worker)
      this.workers.push(worker)
    }
  }

  async executeTask<T>(type: string, data: any): Promise<T> {
    const task: WorkerTask = {
      id: crypto.randomUUID(),
      type,
      data,
    }

    return new Promise((resolve, reject) => {
      this.callbacks.set(task.id, { resolve, reject })
      this.scheduleTask(task)
    })
  }

  private scheduleTask(task: WorkerTask): void {
    const availableWorker = this.workers.find(
      (worker) => !this.busyWorkers.has(worker),
    )

    if (availableWorker) {
      this.assignTask(availableWorker, task)
    } else {
      this.taskQueue.push(task)
    }
  }

  private assignTask(worker: Worker, task: WorkerTask): void {
    this.busyWorkers.add(worker)
    worker.postMessage({
      taskId: task.id,
      type: task.type,
      data: task.data,
    })
  }

  private handleWorkerMessage(worker: Worker, event: MessageEvent): void {
    const response: WorkerResponse = event.data
    const callback = this.callbacks.get(response.taskId)

    if (callback) {
      if (response.error) {
        callback.reject(response.error)
      } else {
        callback.resolve(response.result)
      }
      this.callbacks.delete(response.taskId)
    }

    this.busyWorkers.delete(worker)
    this.processNextTask(worker)
  }

  private handleWorkerError(worker: Worker, error: ErrorEvent): void {
    console.error('Worker error:', error)
    // Implement error handling and worker recovery
  }

  private processNextTask(worker: Worker): void {
    const nextTask = this.taskQueue.shift()
    if (nextTask) {
      this.assignTask(worker, nextTask)
    }
  }

  terminate(): void {
    this.workers.forEach((worker) => worker.terminate())
    this.workers = []
    this.taskQueue = []
    this.busyWorkers.clear()
    this.callbacks.clear()
  }
}

// Usage with React
function useWorkerPool(workerScript: string, poolSize?: number) {
  const pool = useRef<WorkerPool>()

  useEffect(() => {
    pool.current = new WorkerPool(workerScript, poolSize)
    return () => pool.current?.terminate()
  }, [workerScript, poolSize])

  const executeTask = useCallback(
    async <T>(type: string, data: any): Promise<T> => {
      if (!pool.current) {
        throw new Error('Worker pool not initialized')
      }
      return pool.current.executeTask<T>(type, data)
    },
    [],
  )

  return executeTask
}
```

### 2. Shared Memory and Atomics

```typescript
// Shared memory implementation
class SharedMemoryBuffer {
  private sharedBuffer: SharedArrayBuffer
  private int32Array: Int32Array

  constructor(size: number) {
    this.sharedBuffer = new SharedArrayBuffer(size * 4)
    this.int32Array = new Int32Array(this.sharedBuffer)
  }

  write(index: number, value: number): void {
    Atomics.store(this.int32Array, index, value)
  }

  read(index: number): number {
    return Atomics.load(this.int32Array, index)
  }

  waitFor(index: number, expectedValue: number): void {
    Atomics.wait(this.int32Array, index, expectedValue)
  }

  notify(index: number): void {
    Atomics.notify(this.int32Array, index, 1)
  }

  getBuffer(): SharedArrayBuffer {
    return this.sharedBuffer
  }
}

// Worker implementation using shared memory
// worker.ts
self.onmessage = (event: MessageEvent) => {
  const { sharedBuffer, operation } = event.data
  const int32Array = new Int32Array(sharedBuffer)

  switch (operation) {
    case 'increment':
      // Atomic increment
      Atomics.add(int32Array, 0, 1)
      break

    case 'compute':
      // Perform computation and signal completion
      performComputation(int32Array)
      Atomics.store(int32Array, 1, 1)
      Atomics.notify(int32Array, 1)
      break
  }
}
```

### 3. Worklet Implementation

```typescript
// Paint worklet implementation
class CustomPaintWorklet {
  private code: string

  constructor(paintLogic: string) {
    this.code = `
            registerPaint('customPaint', class {
                static get inputProperties() {
                    return ['--custom-property'];
                }

                paint(ctx, size, properties) {
                    ${paintLogic}
                }
            });
        `
  }

  async register(): Promise<void> {
    if (!('paintWorklet' in CSS)) {
      throw new Error('Paint Worklet not supported')
    }

    const blob = new Blob([this.code], {
      type: 'application/javascript',
    })
    const url = URL.createObjectURL(blob)

    try {
      await CSS.paintWorklet.addModule(url)
    } finally {
      URL.revokeObjectURL(url)
    }
  }
}

// Audio worklet implementation
class CustomAudioWorklet extends AudioWorkletProcessor {
  static get parameterDescriptors() {
    return [
      {
        name: 'gain',
        defaultValue: 1.0,
        minValue: 0,
        maxValue: 1,
      },
    ]
  }

  process(
    inputs: Float32Array[][],
    outputs: Float32Array[][],
    parameters: Record<string, Float32Array>,
  ): boolean {
    const input = inputs[0]
    const output = outputs[0]
    const gain = parameters.gain

    for (let channel = 0; channel < output.length; ++channel) {
      const inputChannel = input[channel]
      const outputChannel = output[channel]

      for (let i = 0; i < outputChannel.length; ++i) {
        outputChannel[i] = inputChannel[i] * gain[i]
      }
    }

    return true
  }
}
```

### 4. Worker Communication Patterns

```typescript
// Advanced worker communication
interface MessagePort {
  start(): void
  close(): void
  postMessage(message: any, transfer?: Transferable[]): void
  onmessage: ((event: MessageEvent) => void) | null
}

class WorkerMessenger {
  private channels: Map<string, MessageChannel> = new Map()
  private worker: Worker

  constructor(workerScript: string) {
    this.worker = new Worker(workerScript)
  }

  createChannel(name: string): MessagePort {
    const channel = new MessageChannel()
    this.channels.set(name, channel)

    this.worker.postMessage({ type: 'channel', name, port: channel.port2 }, [
      channel.port2,
    ])

    return channel.port1
  }

  postMessage(message: any, transfer?: Transferable[], channel?: string): void {
    if (channel) {
      const messageChannel = this.channels.get(channel)
      if (messageChannel) {
        messageChannel.port1.postMessage(message, transfer)
      }
    } else {
      this.worker.postMessage(message, transfer)
    }
  }

  addEventListener<K extends keyof WorkerEventMap>(
    type: K,
    listener: (event: WorkerEventMap[K]) => void,
  ): void {
    this.worker.addEventListener(type, listener)
  }

  terminate(): void {
    this.channels.forEach((channel) => {
      channel.port1.close()
      channel.port2.close()
    })
    this.worker.terminate()
  }
}
```

## Best Practices

1. **Worker Management:**

   - Pool workers
   - Reuse instances
   - Handle errors

2. **Data Transfer:**

   - Use transferable objects
   - Minimize copying
   - Batch operations

3. **Resource Usage:**
   - Monitor memory
   - Handle termination
   - Clean up resources

## Common Challenges

1. **Data Sharing:**

   - Large data sets
   - Shared state
   - Synchronization

2. **Error Handling:**

   - Worker crashes
   - Message failures
   - Resource limits

3. **Browser Support:**
   - Feature detection
   - Fallback strategies
   - API differences

## Interview Tips and Tricks

1. **Architecture Design:**

   - Worker patterns
   - Communication strategies
   - Error handling

2. **Best Practices:**

   - Performance optimization
   - Resource management
   - Browser compatibility

3. **Problem Solving:**
   - Parallel processing
   - Data synchronization
   - Error recovery

## Common Interview Questions

1. When should you use Web Workers?
2. How do you handle shared state between workers?
3. What are the limitations of Web Workers?
4. How do you optimize worker communication?
5. What are the differences between worker types?
6. How do you handle worker errors?
7. What are the best practices for worker pools?

Understanding Web Workers and Worklets is crucial for building high-performance web applications. It involves managing parallel processing, optimizing communication, and handling resources effectively.
