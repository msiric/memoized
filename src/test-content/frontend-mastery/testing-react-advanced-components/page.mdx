# Advanced React: Testing Strategies

## Concept and Use Cases

**Definition:**
Advanced React testing involves comprehensive testing strategies for complex components, custom hooks, state management, animations, and advanced patterns.

**Common Use Cases:**

- Complex component testing
- Custom hook testing
- State management testing
- Async operation testing
- Integration testing
- Performance testing
- Visual regression testing
- Animation testing

### Visual Representation:

```
Testing Hierarchy:

Unit Tests → Integration Tests → E2E Tests → Visual Tests
    ↓              ↓                ↓            ↓
Components     User Flows      Application    UI Regression
```

## Key Concepts

1. **Test Types:**

   - Component testing
   - Hook testing
   - Integration testing
   - Visual testing

2. **Testing Strategies:**

   - Behavior-driven testing
   - Snapshot testing
   - Mock strategies
   - Test composition

3. **Testing Tools:**
   - React Testing Library
   - Jest
   - MSW
   - Cypress
   - Storybook

## Implementation Examples

### 1. Complex Component Testing

```typescript
// Testing a complex form component
interface FormData {
    email: string;
    password: string;
    confirmPassword: string;
}

interface FormProps {
    onSubmit: (data: FormData) => Promise<void>;
    onError?: (error: Error) => void;
}

describe('RegistrationForm', () => {
    const mockSubmit = jest.fn();
    const mockError = jest.fn();

    beforeEach(() => {
        jest.clearAllMocks();
    });

    it('validates and submits form data correctly', async () => {
        const { getByLabelText, getByRole } = render(
            <RegistrationForm
                onSubmit={mockSubmit}
                onError={mockError}
            />
        );

        // Fill form
        await userEvent.type(
            getByLabelText(/email/i),
            'test@example.com'
        );
        await userEvent.type(
            getByLabelText(/password/i),
            'password123'
        );
        await userEvent.type(
            getByLabelText(/confirm password/i),
            'password123'
        );

        // Submit form
        await userEvent.click(getByRole('button', { name: /submit/i }));

        // Assertions
        expect(mockSubmit).toHaveBeenCalledWith({
            email: 'test@example.com',
            password: 'password123',
            confirmPassword: 'password123'
        });
        expect(mockError).not.toHaveBeenCalled();
    });

    it('handles validation errors correctly', async () => {
        const { getByLabelText, getByRole, getByText } = render(
            <RegistrationForm
                onSubmit={mockSubmit}
                onError={mockError}
            />
        );

        // Submit without filling
        await userEvent.click(getByRole('button', { name: /submit/i }));

        // Check error messages
        expect(getByText(/email is required/i)).toBeInTheDocument();
        expect(getByText(/password is required/i)).toBeInTheDocument();
        expect(mockSubmit).not.toHaveBeenCalled();
    });

    it('handles async submission errors', async () => {
        const error = new Error('Submission failed');
        const mockFailedSubmit = jest.fn().mockRejectedValue(error);

        const { getByLabelText, getByRole, getByText } = render(
            <RegistrationForm
                onSubmit={mockFailedSubmit}
                onError={mockError}
            />
        );

        // Fill and submit form
        await userEvent.type(
            getByLabelText(/email/i),
            'test@example.com'
        );
        await userEvent.type(
            getByLabelText(/password/i),
            'password123'
        );
        await userEvent.type(
            getByLabelText(/confirm password/i),
            'password123'
        );
        await userEvent.click(getByRole('button', { name: /submit/i }));

        // Check error handling
        expect(mockError).toHaveBeenCalledWith(error);
        expect(getByText(/submission failed/i)).toBeInTheDocument();
    });
});
```

### 2. Custom Hook Testing

```typescript
// Testing a complex custom hook
interface UseDataFetcherOptions<T> {
  initialData?: T
  cacheTime?: number
  retries?: number
}

function useDataFetcher<T>(
  url: string,
  options: UseDataFetcherOptions<T> = {},
) {
  // Hook implementation
}

describe('useDataFetcher', () => {
  beforeEach(() => {
    jest.useFakeTimers()
    jest.spyOn(global, 'fetch')
  })

  afterEach(() => {
    jest.useRealTimers()
    jest.restoreAllMocks()
  })

  it('fetches and caches data correctly', async () => {
    const mockData = { id: 1, name: 'Test' }
    ;(global.fetch as jest.Mock).mockResolvedValueOnce({
      ok: true,
      json: async () => mockData,
    })

    const { result, rerender } = renderHook(
      ({ url }) => useDataFetcher(url, { cacheTime: 5000 }),
      { initialProps: { url: 'test-url' } },
    )

    // Initial state
    expect(result.current.loading).toBe(true)
    expect(result.current.data).toBeUndefined()

    // Wait for fetch
    await waitFor(() => {
      expect(result.current.loading).toBe(false)
    })

    expect(result.current.data).toEqual(mockData)

    // Test caching
    rerender({ url: 'test-url' })
    expect(global.fetch).toHaveBeenCalledTimes(1)

    // Advance time past cache
    jest.advanceTimersByTime(6000)

    // Should fetch again
    rerender({ url: 'test-url' })
    expect(global.fetch).toHaveBeenCalledTimes(2)
  })

  it('handles retries correctly', async () => {
    const error = new Error('Network error')
    ;(global.fetch as jest.Mock)
      .mockRejectedValueOnce(error)
      .mockRejectedValueOnce(error)
      .mockResolvedValueOnce({
        ok: true,
        json: async () => ({ success: true }),
      })

    const { result } = renderHook(() =>
      useDataFetcher('test-url', { retries: 2 }),
    )

    // Initial state
    expect(result.current.loading).toBe(true)

    // Wait for all retries
    await waitFor(
      () => {
        expect(result.current.loading).toBe(false)
      },
      { timeout: 3000 },
    )

    expect(global.fetch).toHaveBeenCalledTimes(3)
    expect(result.current.data).toEqual({ success: true })
  })
})
```

### 3. Integration Testing

```typescript
// Testing complex component interactions
describe('UserDashboard Integration', () => {
    beforeAll(() => {
        // Setup MSW handlers
        server.listen();
    });

    afterEach(() => {
        server.resetHandlers();
    });

    afterAll(() => {
        server.close();
    });

    it('handles the complete user flow', async () => {
        const { getByRole, getByText, queryByText } = render(
            <UserDashboard />
        );

        // Wait for initial data load
        await waitFor(() => {
            expect(queryByText(/loading/i)).not.toBeInTheDocument();
        });

        // Test user interactions
        await userEvent.click(
            getByRole('button', { name: /create project/i })
        );

        // Fill project form
        await userEvent.type(
            getByRole('textbox', { name: /project name/i }),
            'New Project'
        );
        await userEvent.click(
            getByRole('button', { name: /save/i })
        );

        // Verify project creation
        expect(getByText('New Project')).toBeInTheDocument();

        // Test project deletion
        await userEvent.click(
            getByRole('button', { name: /delete project/i })
        );
        await userEvent.click(
            getByRole('button', { name: /confirm/i })
        );

        // Verify project deletion
        expect(queryByText('New Project')).not.toBeInTheDocument();
    });
});
```

### 4. Visual Regression Testing

```typescript
// Storybook story with visual regression tests
import type { Meta, StoryObj } from '@storybook/react'
import { within, userEvent } from '@storybook/testing-library'

const meta: Meta<typeof ComplexComponent> = {
  component: ComplexComponent,
  parameters: {
    chromatic: {
      // Visual regression config
      viewports: [320, 1200],
      diffThreshold: 0.2,
    },
  },
}

export default meta
type Story = StoryObj<typeof ComplexComponent>

export const Default: Story = {
  args: {
    initialData: mockData,
  },
}

export const Loading: Story = {
  args: {
    loading: true,
  },
}

export const WithError: Story = {
  args: {
    error: new Error('Test error'),
  },
}

export const InteractionTest: Story = {
  play: async ({ canvasElement }) => {
    const canvas = within(canvasElement)

    // Simulate user interactions
    await userEvent.click(canvas.getByRole('button', { name: /open/i }))

    // Add assertions for visual changes
    await expect(canvas.getByRole('dialog')).toBeVisible()
  },
}
```

## Testing Patterns

### 1. Test Composition

```typescript
// Reusable test utilities
function setup() {
    const utils = render(<ComponentUnderTest />);
    const inputs = {
        email: utils.getByLabelText(/email/i),
        password: utils.getByLabelText(/password/i)
    };
    const buttons = {
        submit: utils.getByRole('button', { name: /submit/i }),
        reset: utils.getByRole('button', { name: /reset/i })
    };

    return {
        ...utils,
        inputs,
        buttons
    };
}

// Test scenarios
const testCases = [
    {
        name: 'valid input',
        input: {
            email: 'test@example.com',
            password: 'valid123'
        },
        expected: {
            isValid: true,
            errors: {}
        }
    },
    {
        name: 'invalid email',
        input: {
            email: 'invalid',
            password: 'valid123'
        },
        expected: {
            isValid: false,
            errors: {
                email: 'Invalid email format'
            }
        }
    }
];

describe('Form Validation', () => {
    test.each(testCases)(
        '$name',
        async ({ input, expected }) => {
            const { inputs, buttons } = setup();

            // Fill form
            await userEvent.type(inputs.email, input.email);
            await userEvent.type(inputs.password, input.password);

            // Submit form
            await userEvent.click(buttons.submit);

            // Verify results
            if (!expected.isValid) {
                Object.entries(expected.errors).forEach(([field, message]) => {
                    expect(
                        screen.getByText(message)
                    ).toBeInTheDocument();
                });
            }
        }
    );
});
```

## Interview Tips and Tricks

1. **Testing Strategy:**

   - Test coverage
   - Priority determination
   - Test organization

2. **Best Practices:**

   - Testing patterns
   - Mock strategies
   - Test maintenance

3. **Common Pitfalls:**
   - Brittle tests
   - Over-mocking
   - Poor test isolation

## Common Interview Questions

1. How do you approach testing complex components?
2. What strategies do you use for testing hooks?
3. How do you handle async testing?
4. What are your mocking strategies?
5. How do you test edge cases?
6. What tools do you use for testing?
7. How do you maintain test quality?

Understanding advanced testing strategies is crucial for building reliable React applications. It involves choosing the right testing approaches and tools while maintaining good test coverage and quality.
