# Advanced React: Design Patterns

## Concept and Use Cases

**Definition:**
React design patterns are reusable solutions to common problems in React application development, focusing on component composition, state management, and code organization.

**Common Use Cases:**

- Component composition
- State management
- Code reusability
- UI patterns
- Data fetching
- Form handling
- Error boundaries
- Performance optimization

### Visual Representation:

```
Design Pattern Categories:

Structural → Behavioral → Compositional → Presentational
    ↓            ↓             ↓              ↓
HOCs      Render Props    Compound      Controlled/Uncontrolled
```

## Key Patterns

1. **Compound Components:**

   - Component composition
   - Implicit state sharing
   - Flexible APIs

2. **Render Props:**

   - Logic sharing
   - Component inversion
   - Flexible rendering

3. **Custom Hooks:**
   - Logic extraction
   - State management
   - Behavior sharing

## Implementation Examples

### 1. Compound Components Pattern

```typescript
// Compound components implementation
interface TabsContext {
    activeTab: string;
    setActiveTab: (id: string) => void;
}

const TabsContext = createContext<TabsContext | null>(null);

interface TabsProps {
    defaultTab?: string;
    children: React.ReactNode;
}

function Tabs({ defaultTab, children }: TabsProps) {
    const [activeTab, setActiveTab] = useState(defaultTab);

    return (
        <TabsContext.Provider value={{ activeTab, setActiveTab }}>
            <div className="tabs-container">
                {children}
            </div>
        </TabsContext.Provider>
    );
}

function TabList({ children }: { children: React.ReactNode }) {
    return (
        <div className="tabs-list" role="tablist">
            {children}
        </div>
    );
}

interface TabProps {
    id: string;
    children: React.ReactNode;
}

function Tab({ id, children }: TabProps) {
    const context = useContext(TabsContext);
    if (!context) throw new Error('Tab must be used within Tabs');

    const { activeTab, setActiveTab } = context;
    const isActive = activeTab === id;

    return (
        <button
            role="tab"
            aria-selected={isActive}
            onClick={() => setActiveTab(id)}
            className={`tab ${isActive ? 'active' : ''}`}
        >
            {children}
        </button>
    );
}

function TabPanel({ id, children }: TabProps) {
    const context = useContext(TabsContext);
    if (!context) throw new Error('TabPanel must be used within Tabs');

    const { activeTab } = context;
    if (activeTab !== id) return null;

    return (
        <div role="tabpanel" className="tab-panel">
            {children}
        </div>
    );
}

// Compose the components
Tabs.List = TabList;
Tabs.Tab = Tab;
Tabs.Panel = TabPanel;

// Usage
function TabsExample() {
    return (
        <Tabs defaultTab="tab1">
            <Tabs.List>
                <Tabs.Tab id="tab1">Tab 1</Tabs.Tab>
                <Tabs.Tab id="tab2">Tab 2</Tabs.Tab>
            </Tabs.List>

            <Tabs.Panel id="tab1">
                Content for Tab 1
            </Tabs.Panel>
            <Tabs.Panel id="tab2">
                Content for Tab 2
            </Tabs.Panel>
        </Tabs>
    );
}
```

### 2. Render Props Pattern

```typescript
// Render props implementation
interface WindowSizeProps {
    children: (size: { width: number; height: number }) => React.ReactNode;
}

function WindowSize({ children }: WindowSizeProps) {
    const [size, setSize] = useState({
        width: window.innerWidth,
        height: window.innerHeight
    });

    useEffect(() => {
        const handleResize = () => {
            setSize({
                width: window.innerWidth,
                height: window.innerHeight
            });
        };

        window.addEventListener('resize', handleResize);
        return () => window.removeEventListener('resize', handleResize);
    }, []);

    return children(size);
}

// Advanced render props with multiple renders
interface DataFetcherProps<T> {
    url: string;
    renderLoading?: () => React.ReactNode;
    renderError?: (error: Error) => React.ReactNode;
    renderData: (data: T) => React.ReactNode;
}

function DataFetcher<T>({
    url,
    renderLoading = () => <div>Loading...</div>,
    renderError = (error) => <div>Error: {error.message}</div>,
    renderData
}: DataFetcherProps<T>) {
    const [state, setState] = useState<{
        data?: T;
        error?: Error;
        loading: boolean;
    }>({
        loading: true
    });

    useEffect(() => {
        let mounted = true;

        const fetchData = async () => {
            try {
                const response = await fetch(url);
                const data = await response.json();

                if (mounted) {
                    setState({
                        data,
                        loading: false
                    });
                }
            } catch (error) {
                if (mounted) {
                    setState({
                        error: error as Error,
                        loading: false
                    });
                }
            }
        };

        fetchData();

        return () => {
            mounted = false;
        };
    }, [url]);

    if (state.loading) return renderLoading();
    if (state.error) return renderError(state.error);
    if (!state.data) return null;

    return renderData(state.data);
}

// Usage
function DataExample() {
    return (
        <DataFetcher<User[]>
            url="/api/users"
            renderLoading={() => <Spinner />}
            renderError={(error) => (
                <ErrorMessage message={error.message} />
            )}
            renderData={(users) => (
                <UserList users={users} />
            )}
        />
    );
}
```

### 3. Custom Hook Patterns

```typescript
// Advanced hook composition
function useFormField<T>(
    initialValue: T,
    validate?: (value: T) => string | undefined
) {
    const [value, setValue] = useState<T>(initialValue);
    const [touched, setTouched] = useState(false);
    const [error, setError] = useState<string | undefined>();

    const onChange = useCallback((newValue: T) => {
        setValue(newValue);
        if (validate) {
            setError(validate(newValue));
        }
    }, [validate]);

    const onBlur = useCallback(() => {
        setTouched(true);
        if (validate) {
            setError(validate(value));
        }
    }, [validate, value]);

    return {
        value,
        onChange,
        onBlur,
        touched,
        error,
        setTouched
    };
}

// Composing multiple hooks
function useFormValidation<T extends Record<string, any>>(
    initialValues: T,
    validationSchema?: Record<keyof T, (value: any) => string | undefined>
) {
    const fields = Object.entries(initialValues).reduce((acc, [key, value]) => ({
        ...acc,
        [key]: useFormField(
            value,
            validationSchema?.[key as keyof T]
        )
    }), {} as Record<keyof T, ReturnType<typeof useFormField<any>>>);

    const isValid = useCallback(() => {
        return Object.values(fields).every(field => !field.error);
    }, [fields]);

    const touchAll = useCallback(() => {
        Object.values(fields).forEach(field => field.setTouched(true));
    }, [fields]);

    return {
        fields,
        isValid,
        touchAll
    };
}

// Usage
function RegistrationForm() {
    const form = useFormValidation({
        email: '',
        password: ''
    }, {
        email: (value) => {
            if (!value.includes('@')) return 'Invalid email';
        },
        password: (value) => {
            if (value.length < 6) return 'Password too short';
        }
    });

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        form.touchAll();

        if (form.isValid()) {
            // Submit form
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <input
                value={form.fields.email.value}
                onChange={e => form.fields.email.onChange(e.target.value)}
                onBlur={form.fields.email.onBlur}
            />
            {form.fields.email.touched && form.fields.email.error && (
                <span>{form.fields.email.error}</span>
            )}
            {/* Similar for password */}
        </form>
    );
}
```

### 4. Provider Pattern

```typescript
// Advanced provider pattern with actions
interface State<T> {
    data: T;
    loading: boolean;
    error?: Error;
}

type Action<T> =
    | { type: 'SET_DATA'; payload: T }
    | { type: 'SET_LOADING'; payload: boolean }
    | { type: 'SET_ERROR'; payload: Error }
    | { type: 'RESET' };

function createProvider<T>(initialState: T) {
    const StateContext = createContext<State<T> | null>(null);
    const DispatchContext = createContext<Dispatch<Action<T>> | null>(null);

    function reducer(state: State<T>, action: Action<T>): State<T> {
        switch (action.type) {
            case 'SET_DATA':
                return { ...state, data: action.payload, loading: false };
            case 'SET_LOADING':
                return { ...state, loading: action.payload };
            case 'SET_ERROR':
                return { ...state, error: action.payload, loading: false };
            case 'RESET':
                return { data: initialState, loading: false };
            default:
                return state;
        }
    }

    function Provider({ children }: { children: React.ReactNode }) {
        const [state, dispatch] = useReducer(reducer, {
            data: initialState,
            loading: false
        });

        return (
            <StateContext.Provider value={state}>
                <DispatchContext.Provider value={dispatch}>
                    {children}
                </DispatchContext.Provider>
            </StateContext.Provider>
        );
    }

    function useState() {
        const context = useContext(StateContext);
        if (!context) {
            throw new Error('useState must be used within Provider');
        }
        return context;
    }

    function useDispatch() {
        const context = useContext(DispatchContext);
        if (!context) {
            throw new Error('useDispatch must be used within Provider');
        }
        return context;
    }

    return {
        Provider,
        useState,
        useDispatch
    };
}

// Usage
interface User {
    id: string;
    name: string;
}

const UserContext = createProvider<User | null>(null);

function UserProfile() {
    const { data: user, loading } = UserContext.useState();
    const dispatch = UserContext.useDispatch();

    if (loading) return <div>Loading...</div>;
    if (!user) return <div>No user</div>;

    return <div>{user.name}</div>;
}
```

## Interview Tips and Tricks

1. **Pattern Selection:**

   - When to use each pattern
   - Trade-offs between patterns
   - Implementation considerations

2. **Best Practices:**

   - Code organization
   - Component composition
   - State management

3. **Common Pitfalls:**
   - Over-engineering
   - Pattern misuse
   - Performance implications

## Common Interview Questions

1. What patterns do you use for component composition?
2. How do you decide between HOCs and hooks?
3. When would you use render props vs compound components?
4. How do you handle shared logic between components?
5. What patterns do you use for state management?
6. How do you implement reusable form logic?
7. What are the trade-offs of different design patterns?

Understanding React design patterns is crucial for building maintainable and scalable applications. It involves choosing the right patterns for specific use cases and implementing them effectively.
