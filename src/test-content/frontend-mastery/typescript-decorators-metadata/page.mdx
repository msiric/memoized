# Advanced TypeScript: Decorators and Metadata Reflection

## Concept and Use Cases

**Definition:**
Decorators are special declarations that can be attached to class declarations, methods, properties, and parameters to modify their behavior or add metadata.

**Common Use Cases:**

- Dependency injection
- Method interception
- Property validation
- Logging and monitoring
- Authorization
- Route definitions
- ORM mappings
- API endpoint definitions

### Visual Representation:

```
Decorator Execution Order:

1. Parameter Decorators
2. Method Decorators
3. Property Decorators
4. Class Decorators

@ClassDecorator
class Example {
    @PropertyDecorator
    property: string;

    @MethodDecorator
    method(@ParameterDecorator param: string) {}
}
```

## Key Concepts

1. **Decorator Types:**

   - Class decorators
   - Method decorators
   - Property decorators
   - Parameter decorators
   - Accessor decorators

2. **Metadata Reflection:**

   - Design-time type information
   - Runtime type checking
   - Custom metadata

3. **Decorator Factories:**
   - Parameterized decorators
   - Composition
   - Chaining

## Implementation Examples

### 1. Basic Decorators

```typescript
// Class Decorator
function Logger(prefix: string) {
  return function (target: Function) {
    console.log(`${prefix}: ${target.name}`)
  }
}

// Method Decorator
function Log() {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor,
  ) {
    const originalMethod = descriptor.value

    descriptor.value = function (...args: any[]) {
      console.log(`Calling ${propertyKey} with:`, args)
      const result = originalMethod.apply(this, args)
      console.log(`Result:`, result)
      return result
    }

    return descriptor
  }
}

// Property Decorator
function Required(target: any, propertyKey: string) {
  let value: any

  const getter = function () {
    return value
  }

  const setter = function (newVal: any) {
    if (newVal === undefined || newVal === null) {
      throw new Error(`${propertyKey} is required`)
    }
    value = newVal
  }

  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true,
  })
}

// Usage
@Logger('MyClass')
class Example {
  @Required
  name: string

  @Log()
  greet(message: string) {
    return `${this.name} says: ${message}`
  }
}
```

### 2. Metadata Reflection

```typescript
import 'reflect-metadata'

// Custom metadata key
const VALIDATION_KEY = Symbol('validation')

// Validation decorator factory
function Validate(validationFn: (value: any) => boolean) {
  return function (target: any, propertyKey: string) {
    const validators = Reflect.getMetadata(VALIDATION_KEY, target) || {}
    validators[propertyKey] = validationFn
    Reflect.defineMetadata(VALIDATION_KEY, validators, target)
  }
}

// Class with validation
class User {
  @Validate((value) => typeof value === 'string' && value.length >= 3)
  name: string

  @Validate((value) => typeof value === 'string' && value.includes('@'))
  email: string

  constructor(name: string, email: string) {
    this.name = name
    this.email = email
  }
}

// Validation helper
function validate(obj: any): boolean {
  const validators = Reflect.getMetadata(VALIDATION_KEY, obj)
  if (!validators) return true

  return Object.entries(validators).every(([key, validationFn]) => {
    return (validationFn as Function)(obj[key])
  })
}

// Usage
const user = new User('John', 'john@example.com')
console.log(validate(user)) // true
```

### 3. Dependency Injection System

```typescript
// DI Container implementation
class Container {
  private static instance: Container = new Container()
  private dependencies: Map<string, any> = new Map()

  static getInstance(): Container {
    return Container.instance
  }

  register(token: string, dependency: any): void {
    this.dependencies.set(token, dependency)
  }

  resolve<T>(token: string): T {
    const dependency = this.dependencies.get(token)
    if (!dependency) {
      throw new Error(`Dependency ${token} not found`)
    }
    return dependency
  }
}

// Inject decorator
function Inject(token: string) {
  return function (target: any, propertyKey: string) {
    const container = Container.getInstance()

    Object.defineProperty(target, propertyKey, {
      get: () => container.resolve(token),
      enumerable: true,
      configurable: true,
    })
  }
}

// Service decorator
function Service(token: string) {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    const container = Container.getInstance()
    container.register(token, new constructor())
  }
}

// Usage
@Service('userService')
class UserService {
  getUsers() {
    return ['User1', 'User2']
  }
}

class UserController {
  @Inject('userService')
  private userService: UserService

  getUsers() {
    return this.userService.getUsers()
  }
}
```

### 4. Method Interception

```typescript
// Method timing decorator
function Measure() {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor,
  ) {
    const originalMethod = descriptor.value

    descriptor.value = async function (...args: any[]) {
      const start = performance.now()
      const result = await originalMethod.apply(this, args)
      const end = performance.now()

      console.log(`${propertyKey} took ${end - start}ms`)
      return result
    }

    return descriptor
  }
}

// Retry decorator
function Retry(attempts: number = 3, delay: number = 1000) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor,
  ) {
    const originalMethod = descriptor.value

    descriptor.value = async function (...args: any[]) {
      for (let i = 0; i < attempts; i++) {
        try {
          return await originalMethod.apply(this, args)
        } catch (error) {
          if (i === attempts - 1) throw error
          await new Promise((resolve) => setTimeout(resolve, delay))
        }
      }
    }

    return descriptor
  }
}

// Usage
class API {
  @Measure()
  @Retry(3, 1000)
  async fetchData() {
    // Simulated API call
    const random = Math.random()
    if (random < 0.7) throw new Error('Request failed')
    return 'Data'
  }
}
```

### 5. Route Decorators

```typescript
// Route decorators for a simple web framework
type RouteDefinition = {
  path: string
  method: 'GET' | 'POST' | 'PUT' | 'DELETE'
  handler: string
}

const ROUTES_KEY = Symbol('routes')

function Route(method: RouteDefinition['method'], path: string) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor,
  ) {
    const routes: RouteDefinition[] =
      Reflect.getMetadata(ROUTES_KEY, target) || []

    routes.push({
      path,
      method,
      handler: propertyKey,
    })

    Reflect.defineMetadata(ROUTES_KEY, routes, target)
  }
}

// Controller decorator
function Controller(basePath: string = '') {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    const routes: RouteDefinition[] = Reflect.getMetadata(
      ROUTES_KEY,
      constructor.prototype,
    )

    routes.forEach((route) => {
      // Here you would typically register these routes with your web framework
      console.log(
        `Registered: ${route.method} ${basePath}${route.path} -> ${route.handler}`,
      )
    })
  }
}

// Usage
@Controller('/users')
class UserController {
  @Route('GET', '/')
  getUsers() {
    return ['User1', 'User2']
  }

  @Route('POST', '/')
  createUser(user: any) {
    // Create user logic
  }

  @Route('GET', '/:id')
  getUser(id: string) {
    // Get user logic
  }
}
```

## Interview Tips and Tricks

1. **Understanding Decorator Order:**

   - Know the execution order of different decorator types
   - Understand how multiple decorators on the same target interact

2. **Performance Considerations:**

   - Metadata reflection impact
   - Runtime overhead
   - Memory usage

3. **Best Practices:**
   - When to use decorators
   - Error handling
   - Testing decorated code

## Common Interview Questions

1. What are decorators and when should you use them?
2. How does metadata reflection work in TypeScript?
3. Explain the different types of decorators and their use cases.
4. How would you implement a simple dependency injection system?
5. What are the performance implications of using decorators?
6. How do you test code that uses decorators?
7. What are some common pitfalls when working with decorators?

Understanding decorators and metadata reflection is crucial for working with modern TypeScript frameworks and libraries. These features enable powerful metaprogramming capabilities and are extensively used in frameworks like Angular, NestJS, and TypeORM.
