# Advanced TypeScript: Compiler API

## Concept and Use Cases

**Definition:**
The TypeScript Compiler API provides programmatic access to the TypeScript compiler, enabling code analysis, transformation, and generation.

**Common Use Cases:**

- Custom lint rules
- Code refactoring tools
- Documentation generators
- Code analyzers
- Custom transformers
- AST manipulation
- Type checking

### Visual Representation:

```
TypeScript Compilation Pipeline:

Source Code → AST → Type Checker → Transformations → JavaScript
                     ↓
              Type System Info
                     ↓
             Semantic Analysis
```

## Key Concepts

1. **Abstract Syntax Tree (AST):**

   - Node types
   - Tree traversal
   - Node manipulation

2. **Type Checker:**

   - Type analysis
   - Symbol resolution
   - Type inference

3. **Transformers:**
   - AST transformations
   - Code generation
   - Source map creation

## Practical Examples

### 1. Creating a Program and Type Checker

```typescript
import * as ts from 'typescript'

// Create a program instance
function createProgramFromFiles(files: string[]) {
  const options: ts.CompilerOptions = {
    target: ts.ScriptTarget.ES2020,
    module: ts.ModuleKind.CommonJS,
  }

  const program = ts.createProgram(files, options)
  const checker = program.getTypeChecker()

  return { program, checker }
}

// Usage
const { program, checker } = createProgramFromFiles(['./src/index.ts'])

// Get source file
const sourceFile = program.getSourceFile('./src/index.ts')
if (sourceFile) {
  // Analyze the file
  analyzeFile(sourceFile, checker)
}
```

### 2. AST Traversal and Analysis

```typescript
function analyzeFile(sourceFile: ts.SourceFile, checker: ts.TypeChecker) {
  function visit(node: ts.Node) {
    if (ts.isFunctionDeclaration(node)) {
      analyzeFunctionDeclaration(node, checker)
    }

    ts.forEachChild(node, visit)
  }

  visit(sourceFile)
}

function analyzeFunctionDeclaration(
  node: ts.FunctionDeclaration,
  checker: ts.TypeChecker,
) {
  if (node.name) {
    const symbol = checker.getSymbolAtLocation(node.name)
    if (symbol) {
      const type = checker.getTypeOfSymbolAtLocation(symbol, node)
      console.log(`Function ${symbol.name}: ${checker.typeToString(type)}`)
    }
  }
}
```

### 3. Custom Transformer Implementation

```typescript
// Custom transformer that adds console.log to function entries
function createConsoleLogTransformer<
  T extends ts.Node,
>(): ts.TransformerFactory<T> {
  return (context: ts.TransformationContext) => {
    const visit: ts.Visitor = (node: ts.Node): ts.Node => {
      if (ts.isFunctionDeclaration(node)) {
        const newBody = ts.factory.createBlock([
          ts.factory.createExpressionStatement(
            ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(
                ts.factory.createIdentifier('console'),
                'log',
              ),
              undefined,
              [
                ts.factory.createStringLiteral(
                  `Entering function ${node.name?.text || 'anonymous'}`,
                ),
              ],
            ),
          ),
          ...(node.body?.statements || []),
        ])

        return ts.factory.updateFunctionDeclaration(
          node,
          node.decorators,
          node.modifiers,
          node.asteriskToken,
          node.name,
          node.typeParameters,
          node.parameters,
          node.type,
          newBody,
        )
      }
      return ts.visitEachChild(node, visit, context)
    }
    return (node: T) => ts.visitNode(node, visit) as T
  }
}

// Usage
const source = `
function greet(name: string) {
    return "Hello, " + name;
}
`

const sourceFile = ts.createSourceFile(
  'example.ts',
  source,
  ts.ScriptTarget.Latest,
  true,
)

const result = ts.transform(sourceFile, [createConsoleLogTransformer()])
const printer = ts.createPrinter()
console.log(printer.printFile(result.transformed[0]))
```

### 4. Type Analysis and Validation

```typescript
function validateObjectLiteralTypes(
  node: ts.ObjectLiteralExpression,
  checker: ts.TypeChecker,
): void {
  const type = checker.getTypeAtLocation(node)
  const properties = type.getProperties()

  properties.forEach((property) => {
    const propertyType = checker.getTypeOfSymbolAtLocation(
      property,
      property.valueDeclaration!,
    )
    console.log(
      `Property ${property.name}: ${checker.typeToString(propertyType)}`,
    )
  })
}

function findInvalidTypeAssignments(
  sourceFile: ts.SourceFile,
  checker: ts.TypeChecker,
): void {
  function visit(node: ts.Node) {
    if (ts.isVariableDeclaration(node) && node.initializer) {
      const declaredType = checker.getTypeAtLocation(node)
      const initializerType = checker.getTypeAtLocation(node.initializer)

      if (!checker.isTypeAssignableTo(initializerType, declaredType)) {
        console.error(
          `Type '${checker.typeToString(initializerType)}' is not assignable to type '${checker.typeToString(declaredType)}'`,
        )
      }
    }

    ts.forEachChild(node, visit)
  }

  visit(sourceFile)
}
```

### 5. Custom Diagnostic Implementation

```typescript
interface CustomDiagnostic {
  node: ts.Node
  message: string
  category: ts.DiagnosticCategory
}

function createCustomLinter(program: ts.Program) {
  const checker = program.getTypeChecker()
  const diagnostics: CustomDiagnostic[] = []

  function checkNode(node: ts.Node) {
    // Example rule: Check for any type usage
    if (ts.isTypeReferenceNode(node) && node.typeName.getText() === 'any') {
      diagnostics.push({
        node,
        message: "Avoid using 'any' type",
        category: ts.DiagnosticCategory.Warning,
      })
    }

    // Example rule: Check for console.log usage
    if (
      ts.isCallExpression(node) &&
      ts.isPropertyAccessExpression(node.expression) &&
      node.expression.expression.getText() === 'console' &&
      node.expression.name.getText() === 'log'
    ) {
      diagnostics.push({
        node,
        message: 'Avoid using console.log in production code',
        category: ts.DiagnosticCategory.Warning,
      })
    }

    ts.forEachChild(node, checkNode)
  }

  return {
    check(sourceFile: ts.SourceFile) {
      checkNode(sourceFile)
      return diagnostics
    },
  }
}
```

## Advanced Use Cases

### 1. Code Generation Tool

```typescript
function generateTypeGuard(
  interfaceName: string,
  properties: { name: string; type: string }[],
): string {
  const functionName = `is${interfaceName}`

  return `
export function ${functionName}(value: any): value is ${interfaceName} {
    return (
        value != null &&
        typeof value === 'object'
        ${properties
          .map((prop) => {
            switch (prop.type) {
              case 'string':
                return `&& typeof value.${prop.name} === 'string'`
              case 'number':
                return `&& typeof value.${prop.name} === 'number'`
              case 'boolean':
                return `&& typeof value.${prop.name} === 'boolean'`
              default:
                return `&& '${prop.name}' in value`
            }
          })
          .join('\n        ')}
    );
}`
}
```

### 2. AST Visualization Tool

```typescript
function visualizeAST(node: ts.Node, indent: string = ''): string {
  let output = `${indent}${ts.SyntaxKind[node.kind]}\n`

  if (ts.isIdentifier(node)) {
    output += `${indent}  text: ${node.text}\n`
  }

  ts.forEachChild(node, (child) => {
    output += visualizeAST(child, indent + '  ')
  })

  return output
}
```

## Interview Tips and Tricks

1. **Understanding AST Structure:**

   - Know common node types
   - Understand node relationships
   - Be familiar with traversal patterns

2. **Type System Integration:**

   - Explain type checking process
   - Understand symbol resolution
   - Know type inference rules

3. **Performance Considerations:**
   - AST traversal optimization
   - Memory management
   - Caching strategies

## Common Interview Questions

1. How does the TypeScript compiler process source files?
2. What are the main components of the TypeScript Compiler API?
3. How would you implement a custom lint rule?
4. Explain the difference between syntactic and semantic analysis.
5. How does type checking work in the TypeScript compiler?
6. What are transformers and how do they work?
7. How would you handle source maps in a custom transformer?

Understanding the TypeScript Compiler API is crucial for building developer tools, static analysis tools, and custom transformations. It provides powerful capabilities for working with TypeScript code programmatically.
