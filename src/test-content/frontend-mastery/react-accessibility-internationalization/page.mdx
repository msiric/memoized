# Advanced React: Accessibility and Internationalization

## Concept and Use Cases

**Definition:**
Accessibility (a11y) ensures applications are usable by people with disabilities, while Internationalization (i18n) enables applications to adapt to different languages and regions.

**Common Use Cases:**

- Screen reader support
- Keyboard navigation
- Multi-language support
- RTL layout support
- Color contrast compliance
- Date/time formatting
- Number formatting
- Region-specific content

### Visual Representation:

```
Accessibility & i18n Flow:

Semantic HTML → ARIA → Keyboard → Screen Readers
       ↓          ↓        ↓            ↓
  i18n Text → Formatting → RTL → Cultural Adaptation
```

## Key Concepts

1. **Accessibility:**

   - ARIA attributes
   - Keyboard navigation
   - Focus management
   - Semantic HTML

2. **Internationalization:**

   - Translation management
   - RTL support
   - Number formatting
   - Date formatting

3. **Cultural Adaptation:**
   - Region-specific content
   - Cultural considerations
   - Local conventions

## Implementation Examples

### 1. Accessible Components

```typescript
// Accessible Modal Component
interface ModalProps {
    isOpen: boolean;
    onClose: () => void;
    title: string;
    children: React.ReactNode;
}

function Modal({ isOpen, onClose, title, children }: ModalProps) {
    const modalRef = useRef<HTMLDivElement>(null);
    const previousFocus = useRef<HTMLElement | null>(null);

    useEffect(() => {
        if (isOpen) {
            previousFocus.current = document.activeElement as HTMLElement;
            modalRef.current?.focus();
        } else if (previousFocus.current) {
            previousFocus.current.focus();
        }
    }, [isOpen]);

    const handleKeyDown = (event: React.KeyboardEvent) => {
        if (event.key === 'Escape') {
            onClose();
        }
    };

    if (!isOpen) return null;

    return (
        <div
            ref={modalRef}
            role="dialog"
            aria-modal="true"
            aria-labelledby="modal-title"
            tabIndex={-1}
            onKeyDown={handleKeyDown}
            className="modal"
        >
            <div className="modal-content">
                <h2 id="modal-title">{title}</h2>
                {children}
                <button
                    onClick={onClose}
                    aria-label="Close modal"
                >
                    ×
                </button>
            </div>
        </div>
    );
}

// Accessible Form Component
function AccessibleForm() {
    const [error, setError] = useState<string | null>(null);

    return (
        <form
            role="form"
            aria-label="Contact form"
            onSubmit={(e) => {
                e.preventDefault();
                // Form submission logic
            }}
        >
            <div role="group" aria-labelledby="personal-info">
                <h3 id="personal-info">Personal Information</h3>

                <label htmlFor="name">
                    Name
                    <span aria-hidden="true">*</span>
                    <span className="sr-only">(required)</span>
                </label>
                <input
                    id="name"
                    type="text"
                    required
                    aria-required="true"
                    aria-invalid={!!error}
                    aria-describedby={error ? "name-error" : undefined}
                />
                {error && (
                    <div id="name-error" role="alert">
                        {error}
                    </div>
                )}
            </div>
        </form>
    );
}
```

### 2. Internationalization Setup

```typescript
// i18n Configuration
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';

i18n
    .use(initReactI18next)
    .init({
        resources: {
            en: {
                translation: {
                    greeting: 'Hello, {{name}}!',
                    items: {
                        one: '{{count}} item',
                        other: '{{count}} items'
                    }
                }
            },
            es: {
                translation: {
                    greeting: '¡Hola, {{name}}!',
                    items: {
                        one: '{{count}} artículo',
                        other: '{{count}} artículos'
                    }
                }
            }
        },
        lng: 'en',
        fallbackLng: 'en',
        interpolation: {
            escapeValue: false
        }
    });

// Language Provider Component
function LanguageProvider({ children }: { children: React.ReactNode }) {
    const [language, setLanguage] = useState(i18n.language);

    const handleLanguageChange = useCallback((newLang: string) => {
        i18n.changeLanguage(newLang);
        setLanguage(newLang);
        document.documentElement.lang = newLang;
        document.documentElement.dir = i18n.dir(newLang);
    }, []);

    return (
        <LanguageContext.Provider value={{ language, setLanguage: handleLanguageChange }}>
            {children}
        </LanguageContext.Provider>
    );
}
```

### 3. RTL Support

```typescript
// RTL-aware component
function RTLAwareComponent() {
    const { language } = useLanguage();
    const isRTL = i18n.dir(language) === 'rtl';

    return (
        <div className={`container ${isRTL ? 'rtl' : 'ltr'}`}>
            <div className="sidebar" style={{
                [isRTL ? 'right' : 'left']: 0
            }}>
                Sidebar content
            </div>
            <div className="main-content" style={{
                marginInlineStart: '200px'
            }}>
                Main content
            </div>
        </div>
    );
}

// RTL-aware styles
const styles = {
    container: {
        display: 'flex',
        flexDirection: 'row',
    },
    item: {
        marginInlineStart: '1rem',
        paddingInlineEnd: '1rem',
        borderInlineStart: '1px solid #ccc'
    }
};

// RTL CSS-in-JS
const StyledComponent = styled.div<{ isRTL: boolean }>`
    text-align: ${props => props.isRTL ? 'right' : 'left'};
    margin-inline-start: 1rem;
    padding-inline-end: 1rem;
    border-inline-start: 1px solid #ccc;
`;
```

### 4. Formatting Utilities

```typescript
// Date and number formatting
function FormattingExample() {
    const { t } = useTranslation();
    const { language } = useLanguage();

    const formatDate = (date: Date) => {
        return new Intl.DateTimeFormat(language, {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        }).format(date);
    };

    const formatNumber = (num: number) => {
        return new Intl.NumberFormat(language, {
            style: 'currency',
            currency: 'USD'
        }).format(num);
    };

    return (
        <div>
            <p>{t('dateLabel')}: {formatDate(new Date())}</p>
            <p>{t('priceLabel')}: {formatNumber(99.99)}</p>
        </div>
    );
}

// Plural rules
function ItemCount({ count }: { count: number }) {
    const { t } = useTranslation();

    return (
        <div>
            {t('items', { count })}
        </div>
    );
}
```

### 5. Focus Management

```typescript
// Focus trap component
function FocusTrap({ children }: { children: React.ReactNode }) {
    const ref = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const element = ref.current;
        if (!element) return;

        const focusableElements = element.querySelectorAll(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
        );

        const firstElement = focusableElements[0] as HTMLElement;
        const lastElement = focusableElements[focusableElements.length - 1] as HTMLElement;

        const handleKeyDown = (e: KeyboardEvent) => {
            if (e.key === 'Tab') {
                if (e.shiftKey) {
                    if (document.activeElement === firstElement) {
                        e.preventDefault();
                        lastElement.focus();
                    }
                } else {
                    if (document.activeElement === lastElement) {
                        e.preventDefault();
                        firstElement.focus();
                    }
                }
            }
        };

        element.addEventListener('keydown', handleKeyDown);
        return () => element.removeEventListener('keydown', handleKeyDown);
    }, []);

    return (
        <div ref={ref}>
            {children}
        </div>
    );
}
```

### 6. Screen Reader Announcements

```typescript
// Live region component
function Announcer() {
    const [message, setMessage] = useState('');
    const [isPolite, setIsPolite] = useState(true);

    const announce = useCallback((
        newMessage: string,
        polite: boolean = true
    ) => {
        setIsPolite(polite);
        setMessage(newMessage);
    }, []);

    return (
        <>
            <div
                aria-live={isPolite ? 'polite' : 'assertive'}
                aria-atomic="true"
                className="sr-only"
            >
                {message}
            </div>
            <AnnouncerContext.Provider value={announce}>
                {children}
            </AnnouncerContext.Provider>
        </>
    );
}

// Usage in components
function LoadingState() {
    const announce = useAnnouncer();

    useEffect(() => {
        announce('Content is loading');
        return () => announce('Content loaded');
    }, []);

    return <div>Loading...</div>;
}
```

## Interview Tips and Tricks

1. **Accessibility Testing:**

   - Screen reader testing
   - Keyboard navigation testing
   - Color contrast testing
   - ARIA validation

2. **i18n Best Practices:**

   - Translation management
   - Dynamic content
   - Cultural considerations

3. **Common Pitfalls:**
   - Missing ARIA attributes
   - Incorrect heading hierarchy
   - Hard-coded strings
   - RTL layout issues

## Common Interview Questions

1. How do you ensure an application is accessible?
2. What are the key considerations for internationalization?
3. How do you handle RTL layouts?
4. What are best practices for focus management?
5. How do you structure translations?
6. What tools do you use for accessibility testing?
7. How do you handle date and number formatting across locales?

Understanding accessibility and internationalization is crucial for building inclusive applications that can reach a global audience. These features should be considered from the start of development rather than as afterthoughts.
