# Advanced React: Testing Strategies

## Concept and Use Cases

**Definition:**
Advanced React testing involves comprehensive strategies for testing components, hooks, state management, and integration points using modern testing tools and methodologies.

**Common Use Cases:**

- Component testing
- Hook testing
- Integration testing
- Performance testing
- State management testing
- API integration testing
- Visual regression testing
- End-to-end testing

### Visual Representation:

```
Testing Pyramid:

E2E Tests (Cypress/Playwright)
         ↓
Integration Tests (RTL)
         ↓
Unit Tests (Jest)
         ↓
Static Analysis (TypeScript)
```

## Key Concepts

1. **Testing Types:**

   - Unit testing
   - Integration testing
   - End-to-end testing
   - Visual testing

2. **Testing Approaches:**

   - Behavior-driven testing
   - Component testing
   - Hook testing
   - State testing

3. **Testing Tools:**
   - Jest
   - React Testing Library
   - Cypress/Playwright
   - MSW (Mock Service Worker)

## Implementation Examples

### 1. Component Testing

```typescript
// Component under test
interface UserProfileProps {
    user: User;
    onUpdate: (user: User) => Promise<void>;
}

function UserProfile({ user, onUpdate }: UserProfileProps) {
    const [isEditing, setIsEditing] = useState(false);
    const [name, setName] = useState(user.name);

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        await onUpdate({ ...user, name });
        setIsEditing(false);
    };

    return (
        <div>
            {isEditing ? (
                <form onSubmit={handleSubmit}>
                    <input
                        value={name}
                        onChange={e => setName(e.target.value)}
                        data-testid="name-input"
                    />
                    <button type="submit">Save</button>
                </form>
            ) : (
                <>
                    <h2>{user.name}</h2>
                    <button onClick={() => setIsEditing(true)}>
                        Edit
                    </button>
                </>
            )}
        </div>
    );
}

// Component tests
describe('UserProfile', () => {
    const mockUser = {
        id: '1',
        name: 'John Doe'
    };

    it('renders user information correctly', () => {
        render(
            <UserProfile
                user={mockUser}
                onUpdate={jest.fn()}
            />
        );

        expect(screen.getByText('John Doe')).toBeInTheDocument();
    });

    it('handles edit mode correctly', async () => {
        const mockUpdate = jest.fn();
        const user = userEvent.setup();

        render(
            <UserProfile
                user={mockUser}
                onUpdate={mockUpdate}
            />
        );

        await user.click(screen.getByText('Edit'));
        const input = screen.getByTestId('name-input');
        expect(input).toBeInTheDocument();

        await user.clear(input);
        await user.type(input, 'Jane Doe');
        await user.click(screen.getByText('Save'));

        expect(mockUpdate).toHaveBeenCalledWith({
            ...mockUser,
            name: 'Jane Doe'
        });
    });

    it('handles API errors gracefully', async () => {
        const mockUpdate = jest.fn().mockRejectedValue(new Error('API Error'));
        const user = userEvent.setup();

        render(
            <UserProfile
                user={mockUser}
                onUpdate={mockUpdate}
            />
        );

        await user.click(screen.getByText('Edit'));
        await user.type(screen.getByTestId('name-input'), 'Jane Doe');
        await user.click(screen.getByText('Save'));

        expect(await screen.findByText('Error updating profile')).toBeInTheDocument();
    });
});
```

### 2. Custom Hook Testing

```typescript
// Custom hook
function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState(value)

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value)
    }, delay)

    return () => {
      clearTimeout(handler)
    }
  }, [value, delay])

  return debouncedValue
}

// Hook tests
describe('useDebounce', () => {
  beforeEach(() => {
    jest.useFakeTimers()
  })

  afterEach(() => {
    jest.useRealTimers()
  })

  it('returns the initial value immediately', () => {
    const { result } = renderHook(() => useDebounce('initial', 1000))
    expect(result.current).toBe('initial')
  })

  it('debounces value updates', () => {
    const { result, rerender } = renderHook(
      ({ value, delay }) => useDebounce(value, delay),
      {
        initialProps: { value: 'initial', delay: 1000 },
      },
    )

    // Update the value
    rerender({ value: 'updated', delay: 1000 })
    expect(result.current).toBe('initial')

    // Fast-forward time
    jest.advanceTimersByTime(1000)
    expect(result.current).toBe('updated')
  })

  it('cleans up timeout on unmount', () => {
    const { unmount } = renderHook(() => useDebounce('test', 1000))

    unmount()
    expect(clearTimeout).toHaveBeenCalled()
  })
})
```

### 3. Integration Testing with MSW

```typescript
// API mocking setup
import { setupServer } from 'msw/node';
import { rest } from 'msw';

const server = setupServer(
    rest.get('/api/users/:id', (req, res, ctx) => {
        return res(
            ctx.json({
                id: req.params.id,
                name: 'John Doe'
            })
        );
    }),

    rest.post('/api/users/:id', (req, res, ctx) => {
        return res(ctx.json(req.body));
    })
);

// Integration tests
describe('UserProfilePage', () => {
    beforeAll(() => server.listen());
    afterEach(() => server.resetHandlers());
    afterAll(() => server.close());

    it('loads and displays user data', async () => {
        render(<UserProfilePage userId="1" />);

        expect(await screen.findByText('Loading...')).toBeInTheDocument();
        expect(await screen.findByText('John Doe')).toBeInTheDocument();
    });

    it('handles API errors', async () => {
        server.use(
            rest.get('/api/users/:id', (req, res, ctx) => {
                return res(ctx.status(500));
            })
        );

        render(<UserProfilePage userId="1" />);

        expect(await screen.findByText('Error loading user')).toBeInTheDocument();
    });
});
```

### 4. Performance Testing

```typescript
// Performance test utilities
const measureRender = async (
    Component: React.ComponentType,
    props: any
): Promise<number> => {
    const start = performance.now();

    render(<Component {...props} />);
    await waitFor(() => {
        expect(screen.getByTestId('component-ready')).toBeInTheDocument();
    });

    return performance.now() - start;
};

// Performance tests
describe('Performance', () => {
    it('renders large lists efficiently', async () => {
        const items = Array.from({ length: 1000 }, (_, i) => ({
            id: i.toString(),
            name: `Item ${i}`
        }));

        const renderTime = await measureRender(ListView, { items });
        expect(renderTime).toBeLessThan(100);
    });

    it('handles frequent updates efficiently', async () => {
        const { rerender } = render(<DynamicComponent />);
        const updateTimes: number[] = [];

        for (let i = 0; i < 10; i++) {
            const start = performance.now();
            rerender(<DynamicComponent value={i} />);
            updateTimes.push(performance.now() - start);
        }

        const averageUpdateTime = updateTimes.reduce((a, b) => a + b) / updateTimes.length;
        expect(averageUpdateTime).toBeLessThan(16); // 60fps threshold
    });
});
```

### 5. Visual Regression Testing

```typescript
// Visual regression test setup
import { toMatchImageSnapshot } from 'jest-image-snapshot';

expect.extend({ toMatchImageSnapshot });

describe('Visual Regression', () => {
    it('matches component snapshot', async () => {
        const { container } = render(<ComplexComponent />);

        await waitFor(() => {
            expect(screen.getByTestId('loaded')).toBeInTheDocument();
        });

        const image = await takeScreenshot(container);
        expect(image).toMatchImageSnapshot();
    });

    it('handles different themes correctly', async () => {
        const themes = ['light', 'dark', 'high-contrast'];

        for (const theme of themes) {
            const { container } = render(
                <ThemeProvider theme={theme}>
                    <ComplexComponent />
                </ThemeProvider>
            );

            const image = await takeScreenshot(container);
            expect(image).toMatchImageSnapshot({
                customSnapshotIdentifier: `complex-component-${theme}`
            });
        }
    });
});
```

### 6. Test Utilities and Helpers

```typescript
// Common test utilities
const TestWrapper = ({ children }: { children: React.ReactNode }) => (
    <Provider store={createTestStore()}>
        <ThemeProvider theme="light">
            <Router>
                {children}
            </Router>
        </ThemeProvider>
    </Provider>
);

const renderWithProviders = (
    ui: React.ReactElement,
    options?: Omit<RenderOptions, 'wrapper'>
) => {
    return render(ui, {
        wrapper: TestWrapper,
        ...options
    });
};

// Custom matchers
expect.extend({
    toHaveBeenCalledOnceWith(received: jest.Mock, ...expected: any[]) {
        const pass = received.mock.calls.length === 1 &&
            JSON.stringify(received.mock.calls[0]) === JSON.stringify(expected);

        return {
            pass,
            message: () => pass
                ? `Expected mock not to have been called once with ${expected}`
                : `Expected mock to have been called once with ${expected}`
        };
    }
});
```

## Testing Best Practices

1. **Test Organization:**

   - Group related tests
   - Use descriptive names
   - Follow AAA pattern (Arrange, Act, Assert)

2. **Mocking Strategy:**

   - Mock at the right level
   - Use realistic test data
   - Clean up mocks

3. **Test Coverage:**
   - Focus on critical paths
   - Test edge cases
   - Balance coverage and maintenance

## Common Interview Questions

1. How do you decide what to test in a React application?
2. What are the best practices for testing custom hooks?
3. How do you handle async operations in tests?
4. What are the trade-offs between different types of tests?
5. How do you test performance in React components?
6. What strategies do you use for mocking dependencies?
7. How do you ensure tests remain maintainable?

Understanding advanced testing strategies is crucial for building reliable React applications. It involves choosing the right testing tools and approaches while maintaining a balance between coverage and maintainability.
