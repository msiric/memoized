# Advanced React: Concurrent Mode and Suspense

## Concept and Use Cases

**Definition:**
Concurrent Mode is a set of features in React that help applications stay responsive by rendering component trees in memory before committing to the DOM. Suspense allows components to "wait" for something before rendering.

**Common Use Cases:**

- Data fetching
- Code splitting
- Image loading
- Route transitions
- Complex UI updates
- Progressive loading
- Fallback states

### Visual Representation:

```
Concurrent Rendering Process:

User Interaction → Concurrent Work → Memory Tree → Priority Updates → DOM
                          ↓              ↓              ↓
                    Interruptible    Suspense      Time Slicing
```

## Key Concepts

1. **Concurrent Features:**

   - Time slicing
   - Suspense boundaries
   - Transitions
   - Deferred values

2. **Priority Levels:**

   - Urgent updates
   - Transition updates
   - Background updates

3. **Error Boundaries:**
   - Error catching
   - Fallback UI
   - Recovery

## Implementation Examples

### 1. Basic Suspense and Data Fetching

```typescript
// Resource creation utility
interface Resource<T> {
    read(): T;
}

function createResource<T>(promise: Promise<T>): Resource<T> {
    let status = 'pending';
    let result: T;
    let error: Error;

    const suspender = promise.then(
        (data) => {
            status = 'success';
            result = data;
        },
        (err) => {
            status = 'error';
            error = err;
        }
    );

    return {
        read() {
            switch (status) {
                case 'pending':
                    throw suspender;
                case 'error':
                    throw error;
                case 'success':
                    return result;
                default:
                    throw new Error('Invalid status');
            }
        }
    };
}

// Component using Suspense
const UserProfile = ({ userId }: { userId: string }) => {
    const resource = useMemo(
        () => createResource(fetchUser(userId)),
        [userId]
    );

    const user = resource.read();

    return (
        <div>
            <h1>{user.name}</h1>
            <p>{user.email}</p>
        </div>
    );
};

// Usage with Suspense
function App() {
    return (
        <Suspense fallback={<Loading />}>
            <UserProfile userId="123" />
        </Suspense>
    );
}
```

### 2. Transitions and Concurrent Updates

```typescript
// useTransition hook usage
function SearchResults() {
    const [query, setQuery] = useState('');
    const [isPending, startTransition] = useTransition();
    const [results, setResults] = useState<Result[]>([]);

    const handleSearch = (value: string) => {
        // Urgent update
        setQuery(value);

        // Transition update
        startTransition(() => {
            fetchResults(value).then(setResults);
        });
    };

    return (
        <div>
            <input
                value={query}
                onChange={(e) => handleSearch(e.target.value)}
            />
            {isPending ? (
                <div>Loading...</div>
            ) : (
                <ResultsList results={results} />
            )}
        </div>
    );
}

// Deferred value example
function AutoComplete() {
    const [query, setQuery] = useState('');
    const deferredQuery = useDeferredValue(query);

    const suggestions = useMemo(
        () => computeSuggestions(deferredQuery),
        [deferredQuery]
    );

    return (
        <div>
            <input
                value={query}
                onChange={(e) => setQuery(e.target.value)}
            />
            <SuggestionsList suggestions={suggestions} />
        </div>
    );
}
```

### 3. Advanced Suspense Patterns

```typescript
// Suspense with multiple boundaries
function Dashboard() {
    return (
        <div>
            <Suspense fallback={<HeaderSkeleton />}>
                <Header />
            </Suspense>

            <div className="content">
                <Suspense fallback={<SidebarSkeleton />}>
                    <Sidebar />
                </Suspense>

                <Suspense fallback={<MainContentSkeleton />}>
                    <MainContent />
                </Suspense>
            </div>
        </div>
    );
}

// Suspense with SuspenseList (experimental)
function NewsFeed() {
    return (
        <SuspenseList revealOrder="forwards" tail="collapsed">
            <Suspense fallback={<PostSkeleton />}>
                <Post id="1" />
            </Suspense>
            <Suspense fallback={<PostSkeleton />}>
                <Post id="2" />
            </Suspense>
            <Suspense fallback={<PostSkeleton />}>
                <Post id="3" />
            </Suspense>
        </SuspenseList>
    );
}
```

### 4. Error Boundaries with Suspense

```typescript
class ErrorBoundary extends React.Component<
    { fallback: React.ReactNode },
    { hasError: boolean }
> {
    state = { hasError: false };

    static getDerivedStateFromError() {
        return { hasError: true };
    }

    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
        console.error('Error:', error, errorInfo);
    }

    render() {
        if (this.state.hasError) {
            return this.props.fallback;
        }

        return this.props.children;
    }
}

// Usage with Suspense
function DataComponent() {
    return (
        <ErrorBoundary fallback={<ErrorMessage />}>
            <Suspense fallback={<Loading />}>
                <AsyncContent />
            </Suspense>
        </ErrorBoundary>
    );
}
```

### 5. Data Fetching with Suspense

```typescript
// Cache implementation
class QueryCache {
    private cache = new Map<string, Resource<any>>();

    query<T>(
        key: string,
        fetcher: () => Promise<T>
    ): Resource<T> {
        if (!this.cache.has(key)) {
            this.cache.set(key, createResource(fetcher()));
        }
        return this.cache.get(key)!;
    }

    invalidate(key: string): void {
        this.cache.delete(key);
    }
}

// Custom hook for data fetching
function useQuery<T>(
    key: string,
    fetcher: () => Promise<T>
): T {
    const queryCache = useContext(QueryCacheContext);
    const resource = queryCache.query(key, fetcher);
    return resource.read();
}

// Component using the hook
function UserList() {
    const users = useQuery(
        'users',
        () => fetch('/api/users').then(r => r.json())
    );

    return (
        <ul>
            {users.map(user => (
                <li key={user.id}>{user.name}</li>
            ))}
        </ul>
    );
}
```

### 6. Streaming Server Rendering

```typescript
// Server component
async function ServerComponent() {
    const data = await fetchSlowData();

    return (
        <div>
            <h1>Server Rendered Content</h1>
            <Suspense fallback={<Loading />}>
                <SlowComponent data={data} />
            </Suspense>
        </div>
    );
}

// Client entry point
function ClientRoot() {
    return (
        <Suspense fallback={<AppLoading />}>
            <ServerComponent />
        </Suspense>
    );
}
```

## Interview Tips and Tricks

1. **Understanding Concurrency:**

   - Explain how concurrent rendering works
   - Difference from synchronous rendering
   - Use cases and benefits

2. **Suspense Best Practices:**

   - Granular suspense boundaries
   - Error handling
   - Performance implications

3. **Common Pitfalls:**
   - Resource waterfall
   - Over-nesting Suspense
   - Transition misuse

## Common Interview Questions

1. What is Concurrent Mode and how does it improve user experience?
2. How does Suspense work internally?
3. When should you use transitions vs deferred values?
4. How do you handle errors in Suspense boundaries?
5. What are the best practices for data fetching with Suspense?
6. How does Suspense interact with server-side rendering?
7. What are the performance implications of using Concurrent Mode?

Understanding Concurrent Mode and Suspense is crucial for building modern React applications with improved user experiences. These features provide powerful tools for handling async operations and managing loading states.
