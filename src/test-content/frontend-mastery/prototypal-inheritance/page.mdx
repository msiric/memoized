# Advanced JavaScript: Prototypal Inheritance and Object Composition

## Concept and Use Cases

**Definition:**
Prototypal inheritance is JavaScript's native way of implementing inheritance, where objects can inherit properties and methods from other objects through their prototype chain. Object composition is a design approach where complex functionality is built by combining simpler objects.

**Common Use Cases:**

- Creating object hierarchies and inheritance structures
- Implementing reusable behavior patterns
- Building extensible libraries and frameworks
- Sharing functionality between objects efficiently

### Visual Representation:

```
Object Prototype Chain:
myObject --> MyConstructor.prototype --> Object.prototype --> null

Object Composition:
+----------------+
|  Final Object  |
|  +----------+  |
|  | Feature A |  |
|  +----------+  |
|  | Feature B |  |
|  +----------+  |
+----------------+
```

## Key Concepts

1. **Prototype Chain:**

   - Every JavaScript object has a prototype
   - Objects inherit properties and methods through the prototype chain
   - The chain ends at Object.prototype or null

2. **Constructor Functions:**

   - Used to create objects with shared properties and methods
   - The 'new' keyword creates a new object and sets its prototype

3. **Object Composition:**
   - Combining multiple objects to create more complex ones
   - Favoring composition over inheritance
   - Implementing has-a relationships instead of is-a

## Time and Space Complexity

**Time Complexity:**

- Property lookup through prototype chain: O(n), where n is the chain length
- Direct property access: O(1)
- Object composition: O(m), where m is the number of properties being composed

**Space Complexity:**

- Prototype chain: O(1) per object instance
- Shared methods through prototype: O(1) for all instances
- Object composition: O(n) where n is the number of composed properties

## Prototypes and Composition: Operations and Methods

### Basic Prototype Inheritance

**Problem:**
Create a hierarchy of shapes with shared properties and methods.

**Step-by-Step Solution:**

1. Create a base Shape constructor with common properties
2. Add shared methods to Shape.prototype
3. Create specific shape constructors that inherit from Shape

**Example:**

<CodeGroup>

```javascript
function Shape(color) {
  this.color = color
}

Shape.prototype.getColor = function () {
  return this.color
}

function Circle(color, radius) {
  Shape.call(this, color)
  this.radius = radius
}

Circle.prototype = Object.create(Shape.prototype)
Circle.prototype.constructor = Circle

Circle.prototype.getArea = function () {
  return Math.PI * this.radius ** 2
}

const redCircle = new Circle('red', 5)
console.log(redCircle.getColor()) // Output: red
console.log(redCircle.getArea()) // Output: 78.54...
```

```typescript
class Shape {
  protected color: string

  constructor(color: string) {
    this.color = color
  }

  getColor(): string {
    return this.color
  }
}

class Circle extends Shape {
  private radius: number

  constructor(color: string, radius: number) {
    super(color)
    this.radius = radius
  }

  getArea(): number {
    return Math.PI * this.radius ** 2
  }
}

const redCircle = new Circle('red', 5)
console.log(redCircle.getColor()) // Output: red
console.log(redCircle.getArea()) // Output: 78.54...
```

</CodeGroup>

### Object Composition

**Problem:**
Create a system where objects can be composed of multiple behaviors.

**Step-by-Step Solution:**

1. Create separate objects for different behaviors
2. Implement a composition function to combine behaviors
3. Create objects with composed functionality

**Example:**

<CodeGroup>

```javascript
const swimBehavior = {
  swim() {
    return `${this.name} is swimming`
  },
}

const flyBehavior = {
  fly() {
    return `${this.name} is flying`
  },
}

const speakBehavior = {
  speak() {
    return `${this.name} says: ${this.sound}`
  },
}

function createDuck(name) {
  return Object.assign(
    { name, sound: 'quack' },
    swimBehavior,
    flyBehavior,
    speakBehavior,
  )
}

const duck = createDuck('Donald')
console.log(duck.swim()) // Output: Donald is swimming
console.log(duck.fly()) // Output: Donald is flying
console.log(duck.speak()) // Output: Donald says: quack
```

```typescript
interface SwimBehavior {
  swim(): string
}

interface FlyBehavior {
  fly(): string
}

interface SpeakBehavior {
  speak(): string
}

interface Animal {
  name: string
  sound: string
}

const swimBehavior: SwimBehavior = {
  swim() {
    return `${(this as Animal).name} is swimming`
  },
}

const flyBehavior: FlyBehavior = {
  fly() {
    return `${(this as Animal).name} is flying`
  },
}

const speakBehavior: SpeakBehavior = {
  speak() {
    return `${(this as Animal).name} says: ${(this as Animal).sound}`
  },
}

type Duck = Animal & SwimBehavior & FlyBehavior & SpeakBehavior

function createDuck(name: string): Duck {
  return Object.assign(
    { name, sound: 'quack' },
    swimBehavior,
    flyBehavior,
    speakBehavior,
  )
}

const duck = createDuck('Donald')
console.log(duck.swim()) // Output: Donald is swimming
console.log(duck.fly()) // Output: Donald is flying
console.log(duck.speak()) // Output: Donald says: quack
```

</CodeGroup>

### Factory Pattern with Prototypes

**Problem:**
Create a factory that produces objects with shared behavior through prototypes.

**Step-by-Step Solution:**

1. Define a prototype object with shared methods
2. Create a factory function that sets up the prototype chain
3. Add instance-specific properties through the factory

**Example:**

<CodeGroup>

```javascript
const userPrototype = {
  getFullName() {
    return `${this.firstName} ${this.lastName}`
  },
  getInitials() {
    return `${this.firstName[0]}${this.lastName[0]}`
  },
}

function createUser(firstName, lastName) {
  return Object.assign(Object.create(userPrototype), { firstName, lastName })
}

const user = createUser('John', 'Doe')
console.log(user.getFullName()) // Output: John Doe
console.log(user.getInitials()) // Output: JD
```

```typescript
interface User {
  firstName: string
  lastName: string
  getFullName(): string
  getInitials(): string
}

const userPrototype = {
  getFullName(this: User) {
    return `${this.firstName} ${this.lastName}`
  },
  getInitials(this: User) {
    return `${this.firstName[0]}${this.lastName[0]}`
  },
}

function createUser(firstName: string, lastName: string): User {
  return Object.assign(Object.create(userPrototype), { firstName, lastName })
}

const user = createUser('John', 'Doe')
console.log(user.getFullName()) // Output: John Doe
console.log(user.getInitials()) // Output: JD
```

</CodeGroup>

## Practical Tips and Tricks

- **Prototype Pollution:**
  Be careful when modifying object prototypes to avoid security vulnerabilities.
- **Performance:**
  Use composition for complex behaviors to avoid deep prototype chains.

- **Modern Syntax:**
  Consider using class syntax for cleaner prototype-based inheritance.

## Common Gotchas

- **Property Shadowing:**
  Instance properties shadow prototype properties.

- **this Context:**
  Be careful with 'this' binding in prototype methods.

- **Mutating Shared State:**
  Avoid modifying shared prototype properties.

## Advanced Topics

### Dynamic Prototypes

**Problem:**
Implement a system that can dynamically modify object behavior through prototype manipulation.

**Example:**

<CodeGroup>

```javascript
function enhancePrototype(constructor, methods) {
  Object.assign(constructor.prototype, methods)
}

function User(name) {
  this.name = name
}

// Later, dynamically add functionality
enhancePrototype(User, {
  greet() {
    return `Hello, I'm ${this.name}`
  },
  farewell() {
    return `Goodbye from ${this.name}`
  },
})

const user = new User('Alice')
console.log(user.greet()) // Output: Hello, I'm Alice
console.log(user.farewell()) // Output: Goodbye from Alice
```

```typescript
interface UserMethods {
  greet(): string
  farewell(): string
}

function enhancePrototype<T extends new (...args: any[]) => any>(
  constructor: T,
  methods: Partial<UserMethods>,
): void {
  Object.assign(constructor.prototype, methods)
}

class User {
  name: string
  constructor(name: string) {
    this.name = name
  }
}

// Later, dynamically add functionality
enhancePrototype(User, {
  greet() {
    return `Hello, I'm ${this.name}`
  },
  farewell() {
    return `Goodbye from ${this.name}`
  },
})

const user = new User('Alice')
console.log((user as User & UserMethods).greet()) // Output: Hello, I'm Alice
console.log((user as User & UserMethods).farewell()) // Output: Goodbye from Alice
```

</CodeGroup>

## Interview Tips and Tricks

- **Understand Both Approaches:**
  Be ready to explain when to use inheritance vs. composition.

- **Performance Implications:**
  Know the performance characteristics of prototype chains vs. composition.

- **Modern JavaScript:**
  Be familiar with both classical prototype syntax and modern class syntax.

## Common Interview Questions

1. Explain the prototype chain in JavaScript.
2. What are the advantages of composition over inheritance?
3. How does the 'new' keyword work in JavaScript?
4. What is prototype pollution and how can it be prevented?
5. Compare classical inheritance with prototypal inheritance.

## Advanced Use Cases

1. **Mixins:**

   - Implementing multiple inheritance-like behavior
   - Creating reusable behavior modules

2. **Property Descriptors:**

   - Controlling property behavior through descriptors
   - Implementing getters and setters

3. **Proxy Objects:**
   - Intercepting property access
   - Implementing custom behavior

By understanding prototypal inheritance and object composition, you'll be better equipped to create flexible and maintainable JavaScript applications. These patterns are fundamental to many JavaScript libraries and frameworks, and mastering them will make you a more effective developer.
