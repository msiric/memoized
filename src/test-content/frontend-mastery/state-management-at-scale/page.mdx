# Advanced Frontend: State Management at Scale

## Concept and Use Cases

**Definition:**
State management at scale involves strategies and patterns for managing complex application state in large frontend applications, ensuring predictable state updates and optimal performance.

**Common Use Cases:**

- Large applications
- Complex data flows
- Real-time updates
- Multi-user collaboration
- Form management
- Server state synchronization
- Undo/redo functionality
- Cross-component communication

### Visual Representation:

```
State Management Architecture:

Actions → Dispatcher → Store → View
   ↑                           ↓
   └────────── Effects ───────┘
```

## Key Concepts

1. **State Architecture:**

   - Flux pattern
   - Event sourcing
   - CQRS
   - Immutability

2. **Performance:**

   - State segmentation
   - Selective updates
   - Memoization

3. **Scalability:**
   - State composition
   - Action management
   - Side effects

## Implementation Examples

### 1. Custom Flux Implementation

```typescript
// Advanced Flux implementation
type Listener<T> = (state: T) => void
type Reducer<T, A> = (state: T, action: A) => T
type Effect<T, A> = (store: Store<T, A>) => (action: A) => Promise<void>
type Middleware<T, A> = (
  store: Store<T, A>,
) => (next: (action: A) => void) => (action: A) => void

class Store<T, A> {
  private state: T
  private reducer: Reducer<T, A>
  private listeners: Set<Listener<T>> = new Set()
  private effects: Effect<T, A>[] = []
  private middlewares: Middleware<T, A>[] = []

  constructor(
    reducer: Reducer<T, A>,
    initialState: T,
    effects: Effect<T, A>[] = [],
    middlewares: Middleware<T, A>[] = [],
  ) {
    this.state = initialState
    this.reducer = reducer
    this.effects = effects
    this.middlewares = middlewares
  }

  getState(): T {
    return this.state
  }

  dispatch(action: A): void {
    let dispatchFn = (action: A) => {
      this.state = this.reducer(this.state, action)
      this.notify()

      // Handle effects
      this.effects.forEach((effect) => {
        effect(this)(action)
      })
    }

    // Apply middlewares in reverse
    for (const middleware of this.middlewares.reverse()) {
      dispatchFn = middleware(this)(dispatchFn)
    }

    dispatchFn(action)
  }

  subscribe(listener: Listener<T>): () => void {
    this.listeners.add(listener)
    return () => this.listeners.delete(listener)
  }

  private notify(): void {
    this.listeners.forEach((listener) => listener(this.state))
  }
}

// Example usage with TypeScript
interface AppState {
  user: User | null
  settings: Settings
  todos: Todo[]
}

type AppAction =
  | { type: 'SET_USER'; payload: User }
  | { type: 'UPDATE_SETTINGS'; payload: Partial<Settings> }
  | { type: 'ADD_TODO'; payload: Todo }
  | { type: 'REMOVE_TODO'; payload: string }

// Create store with middlewares and effects
const store = new Store<AppState, AppAction>(
  reducer,
  initialState,
  [loggingEffect, analyticsEffect],
  [loggingMiddleware, thunkMiddleware],
)
```

### 2. Advanced State Composition

```typescript
// State composition with selective updates
class ComposableStore<T> {
  private stores: Map<keyof T, Store<T[keyof T], any>> = new Map()
  private combinedState: T

  constructor(initialStores: { [K in keyof T]: Store<T[K], any> }) {
    this.combinedState = Object.create(null)

    Object.entries(initialStores).forEach(([key, store]) => {
      this.stores.set(key as keyof T, store)
      this.combinedState[key as keyof T] = store.getState()

      store.subscribe((state) => {
        this.combinedState[key as keyof T] = state
        this.notify(key as keyof T)
      })
    })
  }

  getState(): T {
    return this.combinedState
  }

  getStore<K extends keyof T>(key: K): Store<T[K], any> | undefined {
    return this.stores.get(key)
  }

  private listeners: Map<keyof T, Set<(state: T) => void>> = new Map()

  subscribe(listener: (state: T) => void): () => void
  subscribe<K extends keyof T>(
    key: K,
    listener: (state: T[K]) => void,
  ): () => void
  subscribe<K extends keyof T>(
    keyOrListener: K | ((state: T) => void),
    listener?: (state: T[K]) => void,
  ): () => void {
    if (typeof keyOrListener === 'function') {
      const globalListener = keyOrListener
      const allKeys = new Set(this.stores.keys())

      allKeys.forEach((key) => {
        const listeners = this.listeners.get(key) || new Set()
        listeners.add(globalListener)
        this.listeners.set(key, listeners)
      })

      return () => {
        allKeys.forEach((key) => {
          const listeners = this.listeners.get(key)
          if (listeners) {
            listeners.delete(globalListener)
          }
        })
      }
    } else {
      const key = keyOrListener
      const keyListener = listener!

      const listeners = this.listeners.get(key) || new Set()
      listeners.add(() => keyListener(this.combinedState[key]))
      this.listeners.set(key, listeners)

      return () => {
        const listeners = this.listeners.get(key)
        if (listeners) {
          listeners.delete(keyListener)
        }
      }
    }
  }

  private notify(key: keyof T): void {
    const listeners = this.listeners.get(key)
    if (listeners) {
      listeners.forEach((listener) => listener(this.combinedState))
    }
  }
}

// Usage
interface AppStores {
  user: UserStore
  settings: SettingsStore
  todos: TodoStore
}

const composedStore = new ComposableStore<AppStores>({
  user: userStore,
  settings: settingsStore,
  todos: todosStore,
})
```

### 3. State Synchronization

```typescript
// State synchronization with server
class SynchronizedStore<T, A> extends Store<T, A> {
  private syncInterval: number
  private syncTimeout: NodeJS.Timeout | null = null
  private lastSyncedState: T

  constructor(
    reducer: Reducer<T, A>,
    initialState: T,
    options: {
      syncInterval?: number
      onSync?: (state: T) => Promise<void>
    } = {},
  ) {
    super(reducer, initialState)
    this.syncInterval = options.syncInterval || 5000
    this.lastSyncedState = initialState

    if (options.onSync) {
      this.startSync(options.onSync)
    }
  }

  private startSync(onSync: (state: T) => Promise<void>): void {
    const sync = async () => {
      const currentState = this.getState()

      if (!this.isStateEqual(currentState, this.lastSyncedState)) {
        try {
          await onSync(currentState)
          this.lastSyncedState = currentState
        } catch (error) {
          console.error('Sync failed:', error)
        }
      }

      this.syncTimeout = setTimeout(sync, this.syncInterval)
    }

    sync()
  }

  private isStateEqual(a: T, b: T): boolean {
    return JSON.stringify(a) === JSON.stringify(b)
  }

  stopSync(): void {
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout)
      this.syncTimeout = null
    }
  }
}
```

### 4. Performance Optimization

```typescript
// Optimized state selectors
class SelectiveStore<T, A> extends Store<T, A> {
  private selectors: Map<string, (state: T) => any> = new Map()
  private selectorCache: Map<string, any> = new Map()
  private selectorDependencies: Map<string, Set<keyof T>> = new Map()

  createSelector<R>(
    key: string,
    selector: (state: T) => R,
    dependencies: Array<keyof T>,
  ): (state: T) => R {
    this.selectors.set(key, selector)
    this.selectorDependencies.set(key, new Set(dependencies))

    return (state: T): R => {
      const cached = this.selectorCache.get(key)
      const deps = this.selectorDependencies.get(key)!

      const shouldRecompute =
        !cached ||
        Array.from(deps).some((dep) => state[dep] !== cached.state[dep])

      if (shouldRecompute) {
        const result = selector(state)
        this.selectorCache.set(key, {
          result,
          state,
        })
        return result
      }

      return cached.result
    }
  }

  dispatch(action: A): void {
    const prevState = this.getState()
    super.dispatch(action)
    const newState = this.getState()

    // Invalidate affected selectors
    this.selectors.forEach((_, key) => {
      const deps = this.selectorDependencies.get(key)!
      const isAffected = Array.from(deps).some(
        (dep) => prevState[dep] !== newState[dep],
      )

      if (isAffected) {
        this.selectorCache.delete(key)
      }
    })
  }
}
```

## Best Practices

1. **State Design:**

   - Clear boundaries
   - Immutability
   - Predictable updates

2. **Performance:**

   - Selective updates
   - Caching
   - Batching

3. **Scalability:**
   - Modular design
   - State composition
   - Action management

## Common Challenges

1. **State Complexity:**

   - Deep updates
   - Derived state
   - Side effects

2. **Performance:**

   - Large state trees
   - Frequent updates
   - Memory usage

3. **Synchronization:**
   - Server state
   - Offline support
   - Conflict resolution

## Interview Tips and Tricks

1. **Architecture Decisions:**

   - State structure
   - Update patterns
   - Performance considerations

2. **Best Practices:**

   - State isolation
   - Error handling
   - Testing approaches

3. **Common Pitfalls:**
   - Over-centralization
   - Poor performance
   - Complex updates

## Common Interview Questions

1. How do you structure state in large applications?
2. What patterns do you use for state updates?
3. How do you handle performance with large state trees?
4. What strategies do you use for state synchronization?
5. How do you test state management code?
6. What are your approaches to handling side effects?
7. How do you manage state composition in large applications?

Understanding state management at scale is crucial for building large frontend applications. It involves making informed decisions about state architecture, performance optimization, and scalability patterns.
