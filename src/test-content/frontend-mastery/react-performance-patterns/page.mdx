# Advanced React: Performance Patterns

## Concept and Use Cases

**Definition:**
Performance patterns are design strategies and techniques used to optimize React applications for speed, responsiveness, and efficiency.

**Common Use Cases:**

- Large lists and tables
- Complex form handling
- Real-time data updates
- Heavy computations
- Infinite scrolling
- Image optimization
- State management
- API caching

### Visual Representation:

```
Performance Optimization Layers:

Component Level → Data Flow → Resource Loading → Runtime
      ↓              ↓              ↓               ↓
Memoization    State Updates    Code Splitting    Workers
```

## Key Concepts

1. **Rendering Optimization:**

   - Component memoization
   - Render batching
   - Virtual rendering

2. **Data Management:**

   - State optimization
   - Cache management
   - Data normalization

3. **Resource Optimization:**
   - Code splitting
   - Asset loading
   - Lazy loading

## Implementation Examples

### 1. Virtual List Implementation

```typescript
// Virtual list for large datasets
interface VirtualListProps<T> {
    items: T[];
    height: number;
    itemHeight: number;
    renderItem: (item: T, index: number) => React.ReactNode;
    overscan?: number;
}

function VirtualList<T>({
    items,
    height,
    itemHeight,
    renderItem,
    overscan = 3
}: VirtualListProps<T>) {
    const containerRef = useRef<HTMLDivElement>(null);
    const [scrollTop, setScrollTop] = useState(0);

    const visibleItems = useMemo(() => {
        const startIndex = Math.max(
            0,
            Math.floor(scrollTop / itemHeight) - overscan
        );
        const endIndex = Math.min(
            items.length,
            Math.ceil((scrollTop + height) / itemHeight) + overscan
        );

        return items.slice(startIndex, endIndex).map((item, index) => ({
            item,
            index: startIndex + index,
            offsetY: (startIndex + index) * itemHeight
        }));
    }, [items, scrollTop, height, itemHeight, overscan]);

    const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
        requestAnimationFrame(() => {
            setScrollTop(e.currentTarget.scrollTop);
        });
    }, []);

    return (
        <div
            ref={containerRef}
            style={{ height, overflow: 'auto' }}
            onScroll={handleScroll}
        >
            <div style={{ height: items.length * itemHeight }}>
                {visibleItems.map(({ item, index, offsetY }) => (
                    <div
                        key={index}
                        style={{
                            position: 'absolute',
                            top: 0,
                            transform: `translateY(${offsetY}px)`,
                            width: '100%',
                            height: itemHeight
                        }}
                    >
                        {renderItem(item, index)}
                    </div>
                ))}
            </div>
        </div>
    );
}

// Usage
function LargeList() {
    const items = useMemo(() =>
        Array.from({ length: 10000 }, (_, i) => ({
            id: i,
            title: `Item ${i}`
        })),
        []
    );

    return (
        <VirtualList
            items={items}
            height={400}
            itemHeight={50}
            renderItem={(item) => (
                <div className="list-item">
                    {item.title}
                </div>
            )}
        />
    );
}
```

### 2. Efficient Form Handling

```typescript
// Form state optimization
interface FormField<T> {
    value: T;
    error?: string;
    touched: boolean;
    validate: (value: T) => string | undefined;
}

function useEfficientForm<T extends Record<string, any>>(
    initialValues: T,
    onSubmit: (values: T) => Promise<void>
) {
    const [fields, setFields] = useState<{
        [K in keyof T]: FormField<T[K]>
    }>(() =>
        Object.entries(initialValues).reduce((acc, [key, value]) => ({
            ...acc,
            [key]: {
                value,
                touched: false,
                validate: () => undefined
            }
        }), {} as { [K in keyof T]: FormField<T[K]> })
    );

    const updateField = useCallback(<K extends keyof T>(
        name: K,
        value: T[K]
    ) => {
        setFields(prev => ({
            ...prev,
            [name]: {
                ...prev[name],
                value,
                touched: true,
                error: prev[name].validate(value)
            }
        }));
    }, []);

    const handleSubmit = useCallback(async (e: React.FormEvent) => {
        e.preventDefault();

        const values = Object.entries(fields).reduce((acc, [key, field]) => ({
            ...acc,
            [key]: field.value
        }), {} as T);

        await onSubmit(values);
    }, [fields, onSubmit]);

    return {
        fields,
        updateField,
        handleSubmit
    };
}

// Usage
function EfficientForm() {
    const form = useEfficientForm({
        username: '',
        email: '',
        password: ''
    }, async (values) => {
        // Submit form
    });

    return (
        <form onSubmit={form.handleSubmit}>
            {Object.entries(form.fields).map(([name, field]) => (
                <div key={name}>
                    <input
                        value={field.value}
                        onChange={e =>
                            form.updateField(name as keyof typeof form.fields, e.target.value)
                        }
                    />
                    {field.touched && field.error && (
                        <span>{field.error}</span>
                    )}
                </div>
            ))}
        </form>
    );
}
```

### 3. Optimized Data Fetching

```typescript
// Cache implementation with automatic garbage collection
class QueryCache<T> {
  private cache: Map<
    string,
    {
      data: T
      timestamp: number
      subscribers: Set<() => void>
    }
  >
  private maxAge: number

  constructor(maxAge: number = 5 * 60 * 1000) {
    this.cache = new Map()
    this.maxAge = maxAge
    this.startGC()
  }

  set(key: string, data: T) {
    const entry = this.cache.get(key)
    const newEntry = {
      data,
      timestamp: Date.now(),
      subscribers: entry?.subscribers || new Set(),
    }
    this.cache.set(key, newEntry)
    newEntry.subscribers.forEach((callback) => callback())
  }

  get(key: string): T | undefined {
    const entry = this.cache.get(key)
    if (!entry) return undefined
    if (Date.now() - entry.timestamp > this.maxAge) {
      this.cache.delete(key)
      return undefined
    }
    return entry.data
  }

  subscribe(key: string, callback: () => void) {
    const entry = this.cache.get(key)
    if (entry) {
      entry.subscribers.add(callback)
    } else {
      this.cache.set(key, {
        data: undefined as unknown as T,
        timestamp: 0,
        subscribers: new Set([callback]),
      })
    }
    return () => {
      this.cache.get(key)?.subscribers.delete(callback)
    }
  }

  private startGC() {
    setInterval(() => {
      const now = Date.now()
      for (const [key, entry] of this.cache.entries()) {
        if (now - entry.timestamp > this.maxAge) {
          this.cache.delete(key)
        }
      }
    }, this.maxAge)
  }
}

// Custom hook for data fetching
function useQuery<T>(
  key: string,
  fetcher: () => Promise<T>,
  options: {
    enabled?: boolean
    refetchInterval?: number
  } = {},
) {
  const cache = useRef(new QueryCache<T>())
  const [data, setData] = useState<T | undefined>(() => cache.current.get(key))
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<Error>()

  const fetch = useCallback(async () => {
    setIsLoading(true)
    try {
      const result = await fetcher()
      cache.current.set(key, result)
      setData(result)
      setError(undefined)
    } catch (e) {
      setError(e as Error)
    } finally {
      setIsLoading(false)
    }
  }, [key, fetcher])

  useEffect(() => {
    if (options.enabled === false) return

    fetch()

    const unsubscribe = cache.current.subscribe(key, () => {
      setData(cache.current.get(key))
    })

    if (options.refetchInterval) {
      const interval = setInterval(fetch, options.refetchInterval)
      return () => {
        clearInterval(interval)
        unsubscribe()
      }
    }

    return unsubscribe
  }, [key, fetch, options.enabled, options.refetchInterval])

  return {
    data,
    isLoading,
    error,
    refetch: fetch,
  }
}
```

### 4. Lazy Loading and Code Splitting

```typescript
// Lazy loading with preload
function createLazyComponent<T extends ComponentType<any>>(
    factory: () => Promise<{ default: T }>,
    LoadingComponent: ComponentType = () => null
) {
    let Component: T | null = null;
    let loading = false;
    let loadPromise: Promise<void> | null = null;

    const LazyComponent = (props: ComponentProps<T>) => {
        const [isLoaded, setIsLoaded] = useState(!!Component);

        useEffect(() => {
            if (!loading && !Component) {
                loading = true;
                loadPromise = factory()
                    .then(module => {
                        Component = module.default;
                        setIsLoaded(true);
                    })
                    .finally(() => {
                        loading = false;
                        loadPromise = null;
                    });
            }
        }, []);

        if (!isLoaded) {
            return <LoadingComponent />;
        }

        return Component ? <Component {...props} /> : null;
    };

    // Add preload method
    LazyComponent.preload = () => {
        if (!loading && !Component) {
            loading = true;
            loadPromise = factory()
                .then(module => {
                    Component = module.default;
                })
                .finally(() => {
                    loading = false;
                    loadPromise = null;
                });
        }
        return loadPromise;
    };

    return LazyComponent;
}

// Usage
const HeavyComponent = createLazyComponent(
    () => import('./HeavyComponent'),
    LoadingSpinner
);

// Preload on hover
function NavLink({ to, children }: { to: string; children: React.ReactNode }) {
    const component = useMemo(() =>
        routeComponents[to],
        [to]
    );

    return (
        <Link
            to={to}
            onMouseEnter={() => component.preload()}
            onFocus={() => component.preload()}
        >
            {children}
        </Link>
    );
}
```

## Interview Tips and Tricks

1. **Performance Measurement:**

   - React DevTools Profiler
   - Lighthouse metrics
   - Custom performance tracking

2. **Optimization Strategy:**

   - When to optimize
   - Common bottlenecks
   - Measuring impact

3. **Common Pitfalls:**
   - Over-optimization
   - Premature optimization
   - Unnecessary renders

## Common Interview Questions

1. How do you identify performance bottlenecks in React?
2. What strategies do you use for optimizing large lists?
3. How do you handle form performance in large applications?
4. What are the best practices for code splitting?
5. How do you optimize data fetching and caching?
6. What tools do you use for performance monitoring?
7. How do you balance performance and code maintainability?

Understanding performance patterns is crucial for building scalable React applications. It involves identifying bottlenecks, implementing optimizations, and measuring their impact.
