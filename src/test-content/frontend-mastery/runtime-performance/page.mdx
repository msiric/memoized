# Advanced Frontend: Runtime Performance

## Concept and Use Cases

**Definition:**
Runtime performance optimization involves techniques for improving application speed, responsiveness, and memory usage during execution.

**Common Use Cases:**

- Large lists and tables
- Complex animations
- Real-time updates
- Data visualization
- Form handling
- DOM manipulation
- Memory management
- Complex calculations

### Visual Representation:

```
Performance Optimization Areas:

Rendering → Memory → Computation → Events
    ↓          ↓          ↓          ↓
Virtual DOM  Leaks    Web Workers  Debounce
```

## Key Concepts

1. **Rendering Performance:**

   - Virtual DOM optimization
   - Component lifecycle
   - Tree reconciliation

2. **Memory Management:**

   - Garbage collection
   - Memory leaks
   - Resource cleanup

3. **Computation Optimization:**
   - Task scheduling
   - Web Workers
   - Memoization

## Implementation Examples

### 1. Rendering Optimization

```typescript
// Optimized list rendering
interface VirtualizedListProps<T> {
    items: T[];
    height: number;
    itemHeight: number;
    renderItem: (item: T) => React.ReactNode;
    overscan?: number;
}

function VirtualizedList<T>({
    items,
    height,
    itemHeight,
    renderItem,
    overscan = 3
}: VirtualizedListProps<T>) {
    const containerRef = useRef<HTMLDivElement>(null);
    const [scrollTop, setScrollTop] = useState(0);

    const visibleItems = useMemo(() => {
        const startIndex = Math.max(
            0,
            Math.floor(scrollTop / itemHeight) - overscan
        );
        const endIndex = Math.min(
            items.length,
            Math.ceil((scrollTop + height) / itemHeight) + overscan
        );

        return items.slice(startIndex, endIndex).map((item, index) => ({
            item,
            index: startIndex + index,
            offsetY: (startIndex + index) * itemHeight
        }));
    }, [items, scrollTop, height, itemHeight, overscan]);

    const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
        requestAnimationFrame(() => {
            setScrollTop(e.currentTarget.scrollTop);
        });
    }, []);

    return (
        <div
            ref={containerRef}
            style={{ height, overflow: 'auto' }}
            onScroll={handleScroll}
        >
            <div style={{ height: items.length * itemHeight }}>
                {visibleItems.map(({ item, index, offsetY }) => (
                    <div
                        key={index}
                        style={{
                            position: 'absolute',
                            top: 0,
                            transform: `translateY(${offsetY}px)`,
                            width: '100%',
                            height: itemHeight
                        }}
                    >
                        {renderItem(item)}
                    </div>
                ))}
            </div>
        </div>
    );
}
```

### 2. Memory Leak Detection

```typescript
// Memory leak detection system
class MemoryMonitor {
  private snapshots: WeakMap<object, WeakRef<object>> = new WeakMap()
  private leakDetectionInterval: number = 5000
  private detectionTimer: NodeJS.Timeout | null = null

  startMonitoring(
    component: React.ComponentType,
    onLeakDetected: (details: LeakInfo) => void,
  ): () => void {
    const componentRef = new WeakRef(component)
    this.snapshots.set(component, componentRef)

    this.detectionTimer = setInterval(() => {
      // Force garbage collection if available (dev only)
      if (global.gc) {
        global.gc()
      }

      const ref = this.snapshots.get(component)
      if (ref && !ref.deref()) {
        const leakInfo = this.analyzeLeaks(component)
        onLeakDetected(leakInfo)
      }
    }, this.leakDetectionInterval)

    return () => {
      if (this.detectionTimer) {
        clearInterval(this.detectionTimer)
      }
    }
  }

  private analyzeLeaks(component: object): LeakInfo {
    const leaks: LeakInfo = {
      componentName: component.constructor.name,
      retainedMemory: 0,
      retainedNodes: [],
      eventListeners: [],
      timers: [],
    }

    // Analyze DOM nodes
    this.findRetainedNodes(component, leaks)

    // Analyze event listeners
    this.findEventListeners(component, leaks)

    // Analyze timers
    this.findTimers(component, leaks)

    return leaks
  }

  private findRetainedNodes(component: object, leakInfo: LeakInfo): void {
    // Implementation to find retained DOM nodes
  }

  private findEventListeners(component: object, leakInfo: LeakInfo): void {
    // Implementation to find unremoved event listeners
  }

  private findTimers(component: object, leakInfo: LeakInfo): void {
    // Implementation to find active timers
  }
}

// Usage in components
function useMemoryMonitor(componentName: string) {
  useEffect(() => {
    const monitor = new MemoryMonitor()
    return monitor.startMonitoring({ name: componentName }, (leakInfo) => {
      console.warn('Memory leak detected:', leakInfo)
    })
  }, [componentName])
}
```

### 3. Computation Optimization

```typescript
// Web Worker implementation
class ComputationWorker {
  private worker: Worker
  private taskQueue: Map<
    string,
    { resolve: (value: any) => void; reject: (error: any) => void }
  > = new Map()

  constructor(workerScript: string) {
    this.worker = new Worker(workerScript)
    this.worker.onmessage = this.handleMessage.bind(this)
    this.worker.onerror = this.handleError.bind(this)
  }

  executeTask<T>(taskName: string, data: any): Promise<T> {
    return new Promise((resolve, reject) => {
      const taskId = `${taskName}-${Date.now()}`
      this.taskQueue.set(taskId, { resolve, reject })

      this.worker.postMessage({
        taskId,
        taskName,
        data,
      })
    })
  }

  private handleMessage(event: MessageEvent): void {
    const { taskId, result, error } = event.data
    const task = this.taskQueue.get(taskId)

    if (task) {
      if (error) {
        task.reject(error)
      } else {
        task.resolve(result)
      }
      this.taskQueue.delete(taskId)
    }
  }

  private handleError(error: ErrorEvent): void {
    console.error('Worker error:', error)
  }

  terminate(): void {
    this.worker.terminate()
    this.taskQueue.clear()
  }
}

// React hook for computation offloading
function useComputation<T>(
  computationFn: (data: any) => T,
  deps: any[],
): {
  execute: (data: any) => Promise<T>
  isComputing: boolean
  error: Error | null
} {
  const [isComputing, setIsComputing] = useState(false)
  const [error, setError] = useState<Error | null>(null)
  const workerRef = useRef<ComputationWorker | null>(null)

  useEffect(() => {
    const workerBlob = new Blob(
      [
        `
                self.onmessage = async (event) => {
                    const { taskId, taskName, data } = event.data;
                    try {
                        const result = (${computationFn.toString()})(data);
                        self.postMessage({ taskId, result });
                    } catch (error) {
                        self.postMessage({ taskId, error: error.message });
                    }
                }
            `,
      ],
      { type: 'application/javascript' },
    )

    workerRef.current = new ComputationWorker(URL.createObjectURL(workerBlob))

    return () => {
      if (workerRef.current) {
        workerRef.current.terminate()
      }
    }
  }, deps)

  const execute = useCallback(async (data: any): Promise<T> => {
    if (!workerRef.current) {
      throw new Error('Worker not initialized')
    }

    setIsComputing(true)
    setError(null)

    try {
      const result = await workerRef.current.executeTask<T>('compute', data)
      return result
    } catch (err) {
      setError(err as Error)
      throw err
    } finally {
      setIsComputing(false)
    }
  }, [])

  return { execute, isComputing, error }
}
```

### 4. Event Optimization

```typescript
// Advanced event handling optimization
class EventManager {
  private handlers: Map<string, Set<(event: Event) => void>> = new Map()
  private options: AddEventListenerOptions = {
    passive: true,
    capture: false,
  }

  addHandler(
    element: HTMLElement,
    eventType: string,
    handler: (event: Event) => void,
    options?: AddEventListenerOptions,
  ): () => void {
    const key = this.getEventKey(element, eventType)
    if (!this.handlers.has(key)) {
      this.handlers.set(key, new Set())
      this.addDelegatedHandler(element, eventType)
    }

    this.handlers.get(key)!.add(handler)

    return () => {
      this.removeHandler(element, eventType, handler)
    }
  }

  private removeHandler(
    element: HTMLElement,
    eventType: string,
    handler: (event: Event) => void,
  ): void {
    const key = this.getEventKey(element, eventType)
    const handlers = this.handlers.get(key)

    if (handlers) {
      handlers.delete(handler)
      if (handlers.size === 0) {
        this.handlers.delete(key)
      }
    }
  }

  private getEventKey(element: HTMLElement, eventType: string): string {
    return `${element.id || element.tagName}-${eventType}`
  }

  private addDelegatedHandler(element: HTMLElement, eventType: string): void {
    const handler = (event: Event) => {
      const key = this.getEventKey(element, eventType)
      const handlers = this.handlers.get(key)

      if (handlers) {
        handlers.forEach((h) => h(event))
      }
    }

    element.addEventListener(eventType, handler, this.options)
  }
}
```

## Best Practices

1. **Rendering:**

   - Virtual rendering
   - Tree optimization
   - Layout batching

2. **Memory:**

   - Cleanup resources
   - Monitor leaks
   - Efficient data structures

3. **Computation:**
   - Task scheduling
   - Web Workers
   - Memoization

## Common Challenges

1. **Performance Bottlenecks:**

   - DOM updates
   - Memory leaks
   - Heavy computations

2. **Resource Management:**

   - Memory usage
   - Event listeners
   - Timers

3. **User Experience:**
   - Frame rate
   - Responsiveness
   - Smooth animations

## Interview Tips and Tricks

1. **Performance Analysis:**

   - Profiling tools
   - Metrics interpretation
   - Optimization strategies

2. **Best Practices:**

   - Memory management
   - Event handling
   - Rendering optimization

3. **Problem Solving:**
   - Performance debugging
   - Optimization techniques
   - Trade-off analysis

## Common Interview Questions

1. How do you identify performance bottlenecks?
2. What strategies do you use for memory leak prevention?
3. How do you optimize rendering performance?
4. What tools do you use for performance profiling?
5. How do you handle heavy computations?
6. What are your approaches to event optimization?
7. How do you measure runtime performance?

Understanding runtime performance optimization is crucial for building smooth and responsive applications. It involves identifying bottlenecks, implementing optimizations, and maintaining good performance practices.
