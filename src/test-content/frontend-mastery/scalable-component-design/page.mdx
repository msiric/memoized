# Advanced Frontend: Scalable Component Design

## Concept and Use Cases

**Definition:**
Scalable component design involves creating flexible, maintainable, and reusable components that can adapt to changing requirements while maintaining consistency across large applications.

**Common Use Cases:**

- Design systems
- Component libraries
- Large-scale applications
- Multi-brand platforms
- White-label solutions
- Themeable components
- Accessible components
- Cross-platform components

### Visual Representation:

```
Component Architecture Layers:

Atoms → Molecules → Organisms → Templates → Pages
  ↓         ↓           ↓           ↓          ↓
Basic    Compound    Complex     Layouts    Full Views
```

## Key Concepts

1. **Component Composition:**

   - Compound components
   - Higher-order components
   - Render props
   - Custom hooks

2. **Design Principles:**

   - Single responsibility
   - Encapsulation
   - Composability
   - Extensibility

3. **Component API Design:**
   - Props API
   - Event handling
   - Customization
   - Accessibility

## Implementation Examples

### 1. Compound Component Pattern

```typescript
// Compound component implementation
interface SelectContext {
    selectedValue: string;
    onChange: (value: string) => void;
    isOpen: boolean;
    setIsOpen: (isOpen: boolean) => void;
}

const SelectContext = createContext<SelectContext | null>(null);

interface SelectProps {
    value: string;
    onChange: (value: string) => void;
    children: React.ReactNode;
}

function Select({ value, onChange, children }: SelectProps) {
    const [isOpen, setIsOpen] = useState(false);

    const contextValue = useMemo(
        () => ({
            selectedValue: value,
            onChange,
            isOpen,
            setIsOpen
        }),
        [value, onChange, isOpen]
    );

    return (
        <SelectContext.Provider value={contextValue}>
            <div className="select-container">
                {children}
            </div>
        </SelectContext.Provider>
    );
}

interface TriggerProps {
    children: React.ReactNode;
}

function Trigger({ children }: TriggerProps) {
    const context = useContext(SelectContext);
    if (!context) throw new Error('Must be used within Select');

    return (
        <button
            onClick={() => context.setIsOpen(!context.isOpen)}
            aria-haspopup="listbox"
            aria-expanded={context.isOpen}
        >
            {children || context.selectedValue}
        </button>
    );
}

interface OptionProps {
    value: string;
    children: React.ReactNode;
}

function Option({ value, children }: OptionProps) {
    const context = useContext(SelectContext);
    if (!context) throw new Error('Must be used within Select');

    const isSelected = context.selectedValue === value;

    return (
        <div
            role="option"
            aria-selected={isSelected}
            onClick={() => {
                context.onChange(value);
                context.setIsOpen(false);
            }}
        >
            {children}
        </div>
    );
}

interface OptionsProps {
    children: React.ReactNode;
}

function Options({ children }: OptionsProps) {
    const context = useContext(SelectContext);
    if (!context) throw new Error('Must be used within Select');

    if (!context.isOpen) return null;

    return (
        <div role="listbox">
            {children}
        </div>
    );
}

// Compose the components
Select.Trigger = Trigger;
Select.Option = Option;
Select.Options = Options;

// Usage
function Example() {
    const [value, setValue] = useState('');

    return (
        <Select value={value} onChange={setValue}>
            <Select.Trigger />
            <Select.Options>
                <Select.Option value="1">Option 1</Select.Option>
                <Select.Option value="2">Option 2</Select.Option>
            </Select.Options>
        </Select>
    );
}
```

### 2. Component Factory Pattern

```typescript
// Component factory with customization
interface ComponentConfig<P> {
    defaultProps?: Partial<P>;
    variants?: Record<string, Partial<P>>;
    styles?: Record<string, React.CSSProperties>;
}

function createComponent<P extends object>(
    BaseComponent: React.ComponentType<P>,
    config: ComponentConfig<P>
) {
    const { defaultProps, variants, styles } = config;

    return React.forwardRef<HTMLElement, P & { variant?: string }>(
        ({ variant, style, ...props }, ref) => {
            const variantProps = variant ? variants?.[variant] : {};
            const variantStyles = variant ? styles?.[variant] : {};

            const finalProps = {
                ...defaultProps,
                ...variantProps,
                ...props,
                style: {
                    ...variantStyles,
                    ...style
                }
            };

            return <BaseComponent ref={ref} {...finalProps} />;
        }
    );
}

// Usage
interface ButtonProps {
    size?: 'small' | 'medium' | 'large';
    color?: string;
    disabled?: boolean;
    children: React.ReactNode;
}

const Button = createComponent<ButtonProps>(
    ({ size, color, children, ...props }) => (
        <button {...props}>{children}</button>
    ),
    {
        defaultProps: {
            size: 'medium'
        },
        variants: {
            primary: {
                color: 'blue'
            },
            secondary: {
                color: 'gray'
            }
        },
        styles: {
            primary: {
                backgroundColor: 'blue',
                color: 'white'
            },
            secondary: {
                backgroundColor: 'gray',
                color: 'black'
            }
        }
    }
);
```

### 3. Scalable Form Components

```typescript
// Form component system
interface FieldConfig {
    type: string;
    validation?: (value: any) => string | undefined;
    format?: (value: any) => any;
    parse?: (value: any) => any;
}

interface FormConfig {
    fields: Record<string, FieldConfig>;
    onSubmit: (values: any) => void;
}

function createForm(config: FormConfig) {
    const { fields, onSubmit } = config;

    return function Form() {
        const [values, setValues] = useState<Record<string, any>>({});
        const [errors, setErrors] = useState<Record<string, string>>({});

        const validateField = useCallback(
            (name: string, value: any) => {
                const field = fields[name];
                if (field.validation) {
                    return field.validation(value);
                }
            },
            [fields]
        );

        const handleChange = useCallback(
            (name: string, value: any) => {
                const field = fields[name];
                const parsedValue = field.parse
                    ? field.parse(value)
                    : value;

                setValues(prev => ({
                    ...prev,
                    [name]: parsedValue
                }));

                const error = validateField(name, parsedValue);
                if (error) {
                    setErrors(prev => ({
                        ...prev,
                        [name]: error
                    }));
                } else {
                    setErrors(prev => {
                        const { [name]: _, ...rest } = prev;
                        return rest;
                    });
                }
            },
            [fields, validateField]
        );

        const handleSubmit = useCallback(
            (e: React.FormEvent) => {
                e.preventDefault();
                const newErrors: Record<string, string> = {};

                Object.entries(fields).forEach(([name, field]) => {
                    const error = validateField(name, values[name]);
                    if (error) {
                        newErrors[name] = error;
                    }
                });

                if (Object.keys(newErrors).length === 0) {
                    onSubmit(values);
                } else {
                    setErrors(newErrors);
                }
            },
            [fields, values, validateField, onSubmit]
        );

        const renderField = useCallback(
            (name: string, field: FieldConfig) => {
                const value = values[name];
                const error = errors[name];
                const displayValue = field.format
                    ? field.format(value)
                    : value;

                switch (field.type) {
                    case 'text':
                        return (
                            <input
                                type="text"
                                value={displayValue || ''}
                                onChange={e => handleChange(name, e.target.value)}
                            />
                        );
                    case 'select':
                        // Render select field
                        break;
                    // Add more field types
                }
            },
            [values, errors, handleChange]
        );

        return (
            <form onSubmit={handleSubmit}>
                {Object.entries(fields).map(([name, field]) => (
                    <div key={name}>
                        <label>{name}</label>
                        {renderField(name, field)}
                        {errors[name] && (
                            <span className="error">{errors[name]}</span>
                        )}
                    </div>
                ))}
                <button type="submit">Submit</button>
            </form>
        );
    };
}
```

## Best Practices

1. **Component Architecture:**

   - Clear responsibilities
   - Consistent patterns
   - Proper encapsulation

2. **API Design:**

   - Intuitive interfaces
   - Flexible customization
   - Proper prop types

3. **Documentation:**
   - Component API
   - Usage examples
   - Best practices

## Common Challenges

1. **Complexity Management:**

   - Component boundaries
   - State management
   - Event handling

2. **Reusability:**

   - Abstraction level
   - Customization
   - Composition

3. **Maintenance:**
   - Version management
   - Breaking changes
   - Backwards compatibility

## Interview Tips and Tricks

1. **Component Design:**

   - Composition patterns
   - API design
   - State management

2. **Best Practices:**

   - Code organization
   - Testing strategy
   - Documentation

3. **Common Pitfalls:**
   - Over-engineering
   - Poor abstraction
   - Tight coupling

## Common Interview Questions

1. How do you design component APIs for scalability?
2. What patterns do you use for component composition?
3. How do you handle component customization?
4. What strategies do you use for component testing?
5. How do you manage component dependencies?
6. What are your approaches to component documentation?
7. How do you handle breaking changes in component libraries?

Understanding scalable component design is crucial for building maintainable and reusable React applications. It involves making informed decisions about component architecture, API design, and maintenance strategies.
