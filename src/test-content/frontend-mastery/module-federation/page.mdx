# Advanced Frontend: Module Federation

## Concept and Use Cases

**Definition:**
Module Federation enables multiple independent builds to form a single application, allowing JavaScript applications to dynamically load code from each other at runtime.

**Common Use Cases:**

- Micro-frontends
- Shared component libraries
- Dynamic plugins
- Cross-team collaboration
- Independent deployments
- Code sharing
- Runtime dependencies
- Progressive loading

### Visual Representation:

```
Module Federation Architecture:

Host App → Remote Entry → Shared Scope
   ↓            ↓             ↓
Remotes    Exposed Modules   Dependencies
```

## Key Concepts

1. **Federation Types:**

   - Host applications
   - Remote applications
   - Bi-directional hosts
   - Shared scope

2. **Module Sharing:**

   - Dependency sharing
   - Version management
   - Scope management

3. **Build Configuration:**
   - Webpack setup
   - Dependency configuration
   - Runtime configuration

## Implementation Examples

### 1. Basic Module Federation Setup

```typescript
// webpack.config.ts for host application
import { container } from 'webpack'
const ModuleFederationPlugin = container.ModuleFederationPlugin

interface SharedDependency {
  singleton?: boolean
  strictVersion?: boolean
  requiredVersion?: string
  eager?: boolean
}

interface ModuleFederationConfig {
  name: string
  filename?: string
  remotes?: Record<string, string>
  exposes?: Record<string, string>
  shared?: Record<string, SharedDependency>
}

function createFederationConfig(config: ModuleFederationConfig) {
  return {
    plugins: [
      new ModuleFederationPlugin({
        name: config.name,
        filename: config.filename,
        remotes: config.remotes,
        exposes: config.exposes,
        shared: {
          react: {
            singleton: true,
            strictVersion: true,
            requiredVersion: '^17.0.0',
          },
          'react-dom': {
            singleton: true,
            strictVersion: true,
            requiredVersion: '^17.0.0',
          },
          ...config.shared,
        },
      }),
    ],
  }
}

// Host application configuration
export default createFederationConfig({
  name: 'host',
  remotes: {
    app1: 'app1@http://localhost:3001/remoteEntry.js',
    app2: 'app2@http://localhost:3002/remoteEntry.js',
  },
  shared: {
    '@material-ui/core': {
      singleton: true,
      requiredVersion: '^5.0.0',
    },
    'react-router-dom': {
      singleton: true,
    },
  },
})
```

### 2. Remote Application Loading

```typescript
// Dynamic remote loading utility
interface RemoteConfig {
    url: string;
    scope: string;
    module: string;
}

class RemoteLoader {
    private loadedRemotes: Set<string> = new Set();
    private loadingPromises: Map<string, Promise<void>> = new Map();

    async loadRemote(config: RemoteConfig): Promise<any> {
        const { url, scope, module } = config;

        // Check if already loaded
        if (this.loadedRemotes.has(url)) {
            return this.getRemoteModule(scope, module);
        }

        // Check if currently loading
        if (this.loadingPromises.has(url)) {
            await this.loadingPromises.get(url);
            return this.getRemoteModule(scope, module);
        }

        // Load the remote
        const loadPromise = new Promise<void>(async (resolve, reject) => {
            try {
                // Load remote entry
                await this.loadScript(url);

                // Initialize the share scope
                const container = window[scope];
                await container.init(__webpack_share_scopes__.default);

                this.loadedRemotes.add(url);
                resolve();
            } catch (error) {
                reject(error);
            }
        });

        this.loadingPromises.set(url, loadPromise);

        await loadPromise;
        return this.getRemoteModule(scope, module);
    }

    private async getRemoteModule(scope: string, module: string): Promise<any> {
        const container = window[scope];
        const factory = await container.get(module);
        return factory();
    }

    private loadScript(url: string): Promise<void> {
        return new Promise((resolve, reject) => {
            const script = document.createElement('script');
            script.src = url;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error(`Failed to load ${url}`));
            document.head.appendChild(script);
        });
    }
}

// Usage in React component
function RemoteComponent({ url, scope, module }: RemoteConfig) {
    const [Component, setComponent] = useState<React.ComponentType | null>(null);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        const loader = new RemoteLoader();
        loader.loadRemote({ url, scope, module })
            .then(setComponent)
            .catch(setError);
    }, [url, scope, module]);

    if (error) return <div>Error loading remote component: {error.message}</div>;
    if (!Component) return <div>Loading...</div>;

    return <Component />;
}
```

### 3. Shared Dependencies Management

```typescript
// Shared dependencies configuration
interface SharedConfig {
  eager?: boolean
  singleton?: boolean
  requiredVersion?: string
}

class SharedDependencyManager {
  private sharedDeps: Map<string, SharedConfig> = new Map()

  addSharedDependency(name: string, config: SharedConfig): void {
    this.sharedDeps.set(name, {
      singleton: true,
      ...config,
    })
  }

  getWebpackConfig(): Record<string, SharedConfig> {
    return Object.fromEntries(this.sharedDeps.entries())
  }

  validateSharedDependencies(deps: Record<string, string>): {
    valid: boolean
    errors: string[]
  } {
    const errors: string[] = []

    for (const [name, version] of Object.entries(deps)) {
      const config = this.sharedDeps.get(name)
      if (config?.requiredVersion) {
        if (!this.isVersionCompatible(version, config.requiredVersion)) {
          errors.push(
            `Incompatible version for ${name}: ` +
              `required ${config.requiredVersion}, got ${version}`,
          )
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
    }
  }

  private isVersionCompatible(actual: string, required: string): boolean {
    // Implement semver comparison logic
    return true // Simplified for example
  }
}

// Usage in webpack config
const sharedManager = new SharedDependencyManager()

sharedManager.addSharedDependency('react', {
  singleton: true,
  requiredVersion: '^17.0.0',
})

sharedManager.addSharedDependency('@material-ui/core', {
  singleton: true,
  requiredVersion: '^5.0.0',
})

export default {
  plugins: [
    new ModuleFederationPlugin({
      shared: sharedManager.getWebpackConfig(),
    }),
  ],
}
```

### 4. Runtime Version Control

```typescript
// Version control system for federated modules
class FederationVersionControl {
  private versions: Map<string, string> = new Map()
  private compatibility: Map<string, string[]> = new Map()

  registerVersion(
    moduleName: string,
    version: string,
    compatibleVersions: string[] = [],
  ): void {
    this.versions.set(moduleName, version)
    this.compatibility.set(moduleName, compatibleVersions)
  }

  async loadModule(
    remote: string,
    module: string,
    requiredVersion: string,
  ): Promise<any> {
    const container = window[remote]
    const moduleVersion = this.versions.get(module)

    if (!moduleVersion) {
      throw new Error(`Module ${module} not registered`)
    }

    if (!this.isVersionCompatible(moduleVersion, requiredVersion)) {
      throw new Error(
        `Version mismatch for ${module}: ` +
          `required ${requiredVersion}, got ${moduleVersion}`,
      )
    }

    return container.get(module)()
  }

  private isVersionCompatible(actual: string, required: string): boolean {
    const compatibleVersions = this.compatibility.get(actual) || []
    return compatibleVersions.includes(required)
  }
}
```

## Best Practices

1. **Dependency Management:**

   - Version control
   - Singleton enforcement
   - Compatibility checking

2. **Performance:**

   - Lazy loading
   - Code splitting
   - Caching strategies

3. **Error Handling:**
   - Loading failures
   - Version conflicts
   - Runtime errors

## Common Challenges

1. **Version Management:**

   - Dependency conflicts
   - Compatibility issues
   - Update coordination

2. **Performance:**

   - Initial load time
   - Bundle size
   - Caching

3. **Development:**
   - Local development
   - Debugging
   - Testing

## Interview Tips and Tricks

1. **Architecture Design:**

   - Module boundaries
   - Sharing strategy
   - Version management

2. **Best Practices:**

   - Performance optimization
   - Error handling
   - Development workflow

3. **Common Pitfalls:**
   - Over-sharing
   - Version conflicts
   - Poor boundaries

## Common Interview Questions

1. How does Module Federation work internally?
2. What are the benefits and drawbacks of Module Federation?
3. How do you handle shared dependencies?
4. What strategies do you use for version management?
5. How do you handle Module Federation in development?
6. What are the performance implications of Module Federation?
7. How do you debug issues in federated modules?

Understanding Module Federation is crucial for building scalable micro-frontend applications. It involves making informed decisions about module sharing, dependency management, and runtime configuration.
