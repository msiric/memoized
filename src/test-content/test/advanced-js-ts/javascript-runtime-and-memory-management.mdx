# **JavaScript Runtime & Memory Management**

Understanding the JavaScript runtime environment and memory management is crucial for building performant applications and debugging complex issues. This lesson covers the event loop, memory allocation, garbage collection, and task queues.

## **JavaScript Runtime Environment**

### **Core Components**

1. **Call Stack**

   - LIFO (Last In, First Out) structure
   - Tracks execution context and function calls
   - Single thread of execution

   ```javascript
   function first() {
     console.log('Inside first')
     second()
   }

   function second() {
     console.log('Inside second')
     third()
   }

   function third() {
     console.log('Inside third')
   }

   // Call Stack progression:
   // 1. first()
   // 2. first() -> second()
   // 3. first() -> second() -> third()
   // 4. first() -> second()
   // 5. first()
   // 6. empty
   first()
   ```

2. **Heap Memory**

   - Unstructured memory pool
   - Stores objects and function closures
   - Managed by garbage collector

   ```javascript
   // Objects stored in heap
   const person = {
     name: 'John',
     age: 30,
     hobbies: ['reading', 'music'],
   }

   // Closures in heap
   function createCounter() {
     let count = 0 // Stored in heap due to closure
     return {
       increment: () => ++count,
       decrement: () => --count,
       getCount: () => count,
     }
   }
   ```

3. **Web APIs (Browser) / C++ APIs (Node.js)**

   - setTimeout/setInterval
   - DOM APIs
   - HTTP requests
   - File operations

   ```javascript
   // Web API examples
   // Timer API
   setTimeout(() => {
     console.log('Timer completed')
   }, 1000)

   // DOM API
   document.addEventListener('click', () => {
     console.log('Click event')
   })

   // HTTP API
   fetch('https://api.example.com/data')
     .then((response) => response.json())
     .then((data) => console.log(data))
   ```

## **Event Loop and Message Queues**

### **Event Loop Mechanism**

1. **Basic Operation**

   ```javascript
   console.log('Start')

   setTimeout(() => {
     console.log('Timeout 1')
   }, 0)

   Promise.resolve()
     .then(() => console.log('Promise 1'))
     .then(() => console.log('Promise 2'))

   setTimeout(() => {
     console.log('Timeout 2')
   }, 0)

   console.log('End')

   // Output:
   // Start
   // End
   // Promise 1
   // Promise 2
   // Timeout 1
   // Timeout 2
   ```

2. **Event Loop Phases (Node.js)**

   ```javascript
   // Timers phase
   setTimeout(() => {
     console.log('Timer')
   }, 0)

   // I/O callbacks phase
   const fs = require('fs')
   fs.readFile('file.txt', () => {
     console.log('File read')
   })

   // setImmediate phase
   setImmediate(() => {
     console.log('Immediate')
   })

   // process.nextTick
   process.nextTick(() => {
     console.log('Next tick')
   })
   ```

### **Task Queues**

1. **Macrotask Queue**

   ```javascript
   // Macrotasks examples
   setTimeout(() => console.log('Timeout 1'), 0)
   setInterval(() => console.log('Interval'), 1000)
   setImmediate(() => console.log('Immediate'))
   requestAnimationFrame(() => console.log('Animation frame'))
   ```

2. **Microtask Queue**

   ```javascript
   // Microtasks examples
   Promise.resolve().then(() => console.log('Promise'))
   process.nextTick(() => console.log('Next tick'))
   queueMicrotask(() => console.log('Microtask'))

   // Custom microtask implementation
   function scheduleMicrotask(callback) {
     Promise.resolve()
       .then(callback)
       .catch((err) => console.error('Microtask error:', err))
   }
   ```

3. **Queue Priorities**

   ```javascript
   console.log('Script start')

   setTimeout(() => {
     console.log('Timeout')
   }, 0)

   Promise.resolve()
     .then(() => {
       console.log('Promise 1')
       return Promise.resolve()
     })
     .then(() => {
       console.log('Promise 2')
     })

   queueMicrotask(() => {
     console.log('Microtask')
   })

   console.log('Script end')

   // Output:
   // Script start
   // Script end
   // Promise 1
   // Microtask
   // Promise 2
   // Timeout
   ```

## **Memory Management and Garbage Collection**

### **Memory Allocation**

1. **Value Types**

   ```javascript
   // Stack allocation
   let number = 42
   let string = 'Hello'
   let boolean = true

   // Heap allocation
   let object = { name: 'John' }
   let array = [1, 2, 3]
   let date = new Date()
   ```

2. **Reference Types**

   ```javascript
   // Object references
   let obj1 = { value: 1 }
   let obj2 = obj1 // Creates reference, not copy

   obj2.value = 2
   console.log(obj1.value) // 2

   // Array references
   let arr1 = [1, 2, 3]
   let arr2 = arr1
   arr2.push(4)
   console.log(arr1) // [1, 2, 3, 4]
   ```

### **Garbage Collection Mechanisms**

1. **Mark and Sweep**

   ```javascript
   let obj = { name: 'John' }
   let user = obj // Reference count: 2
   obj = null // Reference count: 1
   user = null // Reference count: 0 (eligible for GC)

   // Complex example
   function createCycle() {
     const obj1 = {}
     const obj2 = {}
     obj1.ref = obj2 // Circular reference
     obj2.ref = obj1 // Circular reference
     return 'cycle created'
   }
   createCycle() // Objects eligible for GC after function ends
   ```

2. **Memory Leaks**

   ```javascript
   // Common memory leak patterns

   // 1. Forgotten event listeners
   function addHandler() {
     const element = document.getElementById('button')
     element.addEventListener('click', () => {
       // This reference is never removed
       heavyObject.doSomething()
     })
   }

   // Fix:
   function addHandlerFixed() {
     const element = document.getElementById('button')
     const handler = () => {
       heavyObject.doSomething()
     }
     element.addEventListener('click', handler)
     return () => element.removeEventListener('click', handler)
   }

   // 2. Closures holding references
   function createLeak() {
     const heavyObject = {
       /* large data */
     }
     const element = document.getElementById('button')

     element.onclick = () => {
       // Closure holds reference to heavyObject
       console.log(heavyObject)
     }
   }

   // 3. Global variables
   function leak() {
     window.leakedVariable = {
       /* large data */
     }
   }
   ```

### **Memory Optimization Techniques**

1. **Object Pooling**

   ```javascript
   class ObjectPool {
     constructor() {
       this.pool = []
     }

     acquire() {
       return (
         this.pool.pop() ||
         {
           /* new object */
         }
       )
     }

     release(obj) {
       // Clean object
       Object.keys(obj).forEach((key) => {
         obj[key] = null
       })
       this.pool.push(obj)
     }
   }

   const pool = new ObjectPool()
   ```

2. **WeakMap and WeakSet**

   ```javascript
   // Using WeakMap for caching
   const cache = new WeakMap()

   function processUser(user) {
     if (cache.has(user)) {
       return cache.get(user)
     }

     const result = expensiveOperation(user)
     cache.set(user, result)
     return result
   }

   // Using WeakSet for object tracking
   const trackedObjects = new WeakSet()

   function track(obj) {
     trackedObjects.add(obj)
   }

   function isTracked(obj) {
     return trackedObjects.has(obj)
   }
   ```

## **Performance Monitoring**

### **Memory Profiling**

1. **Chrome DevTools**

   ```javascript
   // Trigger heap snapshot
   // In Chrome DevTools:
   // 1. Memory tab
   // 2. Take heap snapshot
   // 3. Compare snapshots

   // Create memory pressure
   function createObjects() {
     let arrays = []
     for (let i = 0; i < 1000; i++) {
       arrays.push(new Array(10000).fill('x'))
     }
     return arrays
   }
   ```

2. **Memory Leaks Detection**

   ```javascript
   // Memory leak detector
   class MemoryLeakDetector {
     constructor() {
       this.memoryUsage = []
     }

     startMonitoring() {
       this.interval = setInterval(() => {
         const usage = process.memoryUsage()
         this.memoryUsage.push(usage.heapUsed)

         if (this.memoryUsage.length > 10) {
           this.analyzeMemoryUsage()
         }
       }, 1000)
     }

     analyzeMemoryUsage() {
       const increases = this.memoryUsage
         .slice(1)
         .map((usage, i) => usage - this.memoryUsage[i])

       const consistentIncrease = increases.every((increase) => increase > 0)

       if (consistentIncrease) {
         console.warn('Potential memory leak detected')
       }
     }
   }
   ```

## **Interview Questions**

1. "Explain the difference between microtasks and macrotasks with examples."
2. "How does the event loop handle different types of tasks?"
3. "What are common causes of memory leaks in JavaScript?"
4. "How does garbage collection work in JavaScript?"
5. "Explain the concept of event loop phases in Node.js."
6. "What are WeakMap and WeakSet, and when should you use them?"

## **Practice Problems**

1. Implement a custom event loop simulator
2. Create a memory leak scenario and implement its solution
3. Build a task scheduler that handles both micro and macro tasks
4. Implement a memory-efficient cache using WeakMap

## **Additional Resources**

- [MDN Memory Management](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management)
- [Node.js Event Loop Documentation](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)
- [Chrome DevTools Memory Profiling](https://developers.google.com/web/tools/chrome-devtools/memory-problems)
- [V8 Garbage Collection](https://v8.dev/blog/trash-talk)

Would you like me to:

1. Add more specific examples for any topic?
2. Include additional interview questions?
3. Create more practice problems?
4. Add specific debugging scenarios?
