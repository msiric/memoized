# **TypeScript Advanced Types**

Understanding advanced TypeScript types is crucial for building type-safe applications and leveraging the full power of TypeScript's type system.

## **Conditional Types**

### **Basic Conditional Types**

```typescript
// Basic syntax: T extends U ? X : Y
type IsString<T> = T extends string ? true : false

// Usage
type A = IsString<string> // true
type B = IsString<number> // false

// Practical example
type ArrayOrString<T> = T extends any[] ? T[number] : T

type Test1 = ArrayOrString<string[]> // string
type Test2 = ArrayOrString<string> // string
```

### **Inferring Within Conditional Types**

```typescript
// Using infer keyword
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

// Example usage
function greeting(name: string): string {
  return `Hello, ${name}!`;
}

type GreetingReturn = ReturnType<typeof greeting>;  // string

// Complex inference
type UnpackPromise<T> = T extends Promise<infer U> ? U : T;

type ResolvedType = UnpackPromise<Promise<string>>;  // string
type NonPromiseType = UnpackPromise<number>;         // number

// Multiple infer
type FirstAndLastParameters<T extends (...args: any[]) => any> =
  T extends (...args: [...any[], infer L]) => any
    ? T extends (infer F, ...args: any[]) => any
      ? [F, L]
      : never
    : never;

function example(a: number, b: string, c: boolean): void {}
type Params = FirstAndLastParameters<typeof example>;  // [number, boolean]
```

## **Mapped Types**

### **Basic Mapped Types**

```typescript
// Making all properties optional
type Partial<T> = {
  [P in keyof T]?: T[P]
}

// Making all properties readonly
type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}

// Practical example
interface User {
  id: number
  name: string
  email: string
}

type PartialUser = Partial<User>
type ReadonlyUser = Readonly<User>
```

### **Advanced Mapped Types**

```typescript
// Modifying property modifiers
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
}

// Adding prefixes to properties
type Getters<T> = {
  [P in keyof T as `get${Capitalize<string & P>}`]: () => T[P]
}

interface Person {
  name: string
  age: number
}

type PersonGetters = Getters<Person>
// {
//   getName: () => string;
//   getAge: () => number;
// }

// Filtering properties
type FilterByType<T, U> = {
  [P in keyof T as T[P] extends U ? P : never]: T[P]
}

interface Mixed {
  name: string
  count: number
  isActive: boolean
  tags: string[]
}

type StringProperties = FilterByType<Mixed, string> // { name: string }
```

## **Template Literal Types**

### **Basic Template Literals**

```typescript
// Simple template literals
type Greeting = `Hello, ${string}!`

// Union types in template literals
type Direction = 'top' | 'right' | 'bottom' | 'left'
type Margin = `margin-${Direction}`
// "margin-top" | "margin-right" | "margin-bottom" | "margin-left"

// Multiple unions
type Corner = 'top' | 'bottom'
type Side = 'left' | 'right'
type Position = `${Corner}-${Side}`
// "top-left" | "top-right" | "bottom-left" | "bottom-right"
```

### **Advanced Template Literals**

```typescript
// Event handling
type EventType = 'click' | 'focus' | 'blur'
type EventHandler<T extends string> = `on${Capitalize<T>}`

type DOMEvents = {
  [E in EventType as EventHandler<E>]: (event: Event) => void
}

// URL Pattern
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'
type URLPattern<T extends string> = `/${T}`
type APIEndpoint<T extends string> = `${HTTPMethod} ${URLPattern<T>}`

type UserEndpoints = APIEndpoint<'users' | 'users/:id'>
// "GET /users" | "GET /users/:id" | "POST /users" | ...

// Complex combinations
type CSSProperty<T extends string> =
  | `${T}`
  | `${T}-top`
  | `${T}-right`
  | `${T}-bottom`
  | `${T}-left`
type Padding = CSSProperty<'padding'>
// "padding" | "padding-top" | "padding-right" | "padding-bottom" | "padding-left"
```

## **Type Inference and Guards**

### **Advanced Type Inference**

```typescript
// Parameter type inference
function map<T, U>(array: T[], fn: (item: T) => U): U[] {
  return array.map(fn)
}

// Return type inference
function compose<A, B, C>(f: (a: A) => B, g: (b: B) => C): (a: A) => C {
  return (a) => g(f(a))
}

// Inference in generic constraints
function getProp<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]
}
```

### **Custom Type Guards**

```typescript
// User-defined type guards
interface Bird {
  fly(): void
  layEggs(): void
}

interface Fish {
  swim(): void
  layEggs(): void
}

function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}

// Usage
function moveAnimal(pet: Fish | Bird) {
  if (isFish(pet)) {
    pet.swim() // TypeScript knows pet is Fish
  } else {
    pet.fly() // TypeScript knows pet is Bird
  }
}

// Advanced type guards with generics
function isOfType<T>(value: unknown, property: keyof T): value is T {
  return typeof value === 'object' && value !== null && property in value
}
```

## **Utility Types**

### **Built-in Utility Types**

```typescript
// Record
type PageInfo = Record<
  'home' | 'about' | 'contact',
  { title: string; path: string }
>

// Pick and Omit
interface Todo {
  title: string
  description: string
  completed: boolean
  createdAt: number
}

type TodoPreview = Pick<Todo, 'title' | 'completed'>
type TodoInfo = Omit<Todo, 'completed' | 'createdAt'>

// Extract and Exclude
type T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'> // "a"
type T1 = Exclude<'a' | 'b' | 'c', 'a' | 'f'> // "b" | "c"

// NonNullable
type T2 = NonNullable<string | number | undefined | null> // string | number
```

### **Custom Utility Types**

```typescript
// DeepReadonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]
}

// DeepPartial
type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
}

// UnionToIntersection
type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
  k: infer I,
) => void
  ? I
  : never

// Example usage
type Union = { a: string } | { b: number }
type Intersection = UnionToIntersection<Union> // { a: string } & { b: number }

// ValueOf
type ValueOf<T> = T[keyof T]

// Example
const colors = {
  red: '#ff0000',
  green: '#00ff00',
  blue: '#0000ff',
} as const

type Color = ValueOf<typeof colors> // "#ff0000" | "#00ff00" | "#0000ff"
```

## **Common Pitfalls and Solutions**

### **Type Widening**

```typescript
// Problem
const numbers = [1, 2, 3] // number[]
const tuple = [1, '2', true] // (string | number | boolean)[]

// Solution
const numbers = [1, 2, 3] as const // readonly [1, 2, 3]
const tuple = [1, '2', true] as const // readonly [1, "2", true]

// Generic constraints
function first<T extends any[]>(arr: T): T[0] {
  return arr[0]
}

// Better
function first<T>(arr: readonly T[]): T | undefined {
  return arr[0]
}
```

### **Type Narrowing**

```typescript
// Problem
function process(value: string | number) {
  if (typeof value === 'string') {
    console.log(value.toUpperCase())
  } else {
    console.log(value.toFixed(2))
  }
}

// Advanced narrowing
type Success = { success: true; data: string }
type Error = { success: false; error: string }
type Result = Success | Error

function handleResult(result: Result) {
  if (result.success) {
    console.log(result.data) // TypeScript knows it's Success
  } else {
    console.log(result.error) // TypeScript knows it's Error
  }
}
```

## **Interview Questions**

1. "Explain the difference between `extends` and `implements` in TypeScript."
2. "How do conditional types work and when would you use them?"
3. "What are mapped types and what problems do they solve?"
4. "Explain how template literal types work and provide a practical example."
5. "What is the `infer` keyword and how is it used in conditional types?"
6. "How would you implement a deep partial type?"
7. "Explain the difference between `type` and `interface`."
8. "How would you create a type that extracts the function properties from an object type?"

## **Practice Problems**

1. Implement a utility type that makes all properties of an object required and non-nullable
2. Create a type that extracts all method names from a type
3. Implement a deep readonly type that works with arrays and nested objects
4. Create a type that converts snake_case to camelCase for all properties in an object
5. Implement a utility type that extracts all union members that match a certain condition

## **Additional Resources**

- [TypeScript Handbook: Advanced Types](https://www.typescriptlang.org/docs/handbook/advanced-types.html)
- [TypeScript Deep Dive](https://basarat.gitbook.io/typescript/)
- [Type Challenges](https://github.com/type-challenges/type-challenges)

Would you like me to:

1. Add more practical examples?
2. Include more interview questions?
3. Add more advanced type patterns?
4. Create more practice problems?
