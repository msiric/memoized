# **Advanced JavaScript Patterns: Closures & Scope**

Understanding closures and scope is fundamental to mastering JavaScript. These concepts are crucial for creating modular, maintainable code and are frequently tested in technical interviews.

## **Lexical Scope**

### **Scope Fundamentals**

1. **Scope Types**

   ```javascript
   // Global Scope
   const globalVar = 'I am global'

   // Function Scope
   function functionScope() {
     const functionVar = 'I am function-scoped'
     console.log(globalVar) // Accessible
     console.log(functionVar) // Accessible
   }

   // Block Scope (let/const)
   if (true) {
     let blockVar = 'I am block-scoped'
     const constVar = 'I am also block-scoped'
     var varVariable = 'I leak outside!'
   }
   console.log(varVariable) // Accessible
   console.log(blockVar) // ReferenceError
   ```

2. **Scope Chain**

   ```javascript
   const global = 'GLOBAL'

   function outer() {
     const outerVar = 'OUTER'

     function inner() {
       const innerVar = 'INNER'

       function deepest() {
         const deepestVar = 'DEEPEST'
         console.log(global) // Looks up through scope chain
         console.log(outerVar) // Found in outer scope
         console.log(innerVar) // Found in immediate outer scope
         console.log(deepestVar) // Found in local scope
       }

       deepest()
     }

     inner()
   }

   outer()
   ```

3. **Variable Shadowing**

   ```javascript
   const value = 'global'

   function outer() {
     const value = 'outer'

     function inner() {
       const value = 'inner'
       console.log(value) // 'inner'
     }

     inner()
     console.log(value) // 'outer'
   }

   outer()
   console.log(value) // 'global'
   ```

## **Closure Mechanisms**

### **Basic Closure Pattern**

1. **Function Factory**

   ```javascript
   function createCounter(initialValue = 0) {
     let count = initialValue // Enclosed variable

     return {
       increment: () => ++count,
       decrement: () => --count,
       getCount: () => count,
       reset: () => {
         count = initialValue
         return count
       },
     }
   }

   const counter = createCounter(10)
   console.log(counter.getCount()) // 10
   console.log(counter.increment()) // 11
   console.log(counter.decrement()) // 10
   console.log(counter.reset()) // 10
   ```

2. **Data Privacy**

   ```javascript
   function createBankAccount(initialBalance = 0) {
     let balance = initialBalance

     return {
       deposit: (amount) => {
         if (amount > 0) {
           balance += amount
           return `Deposited ${amount}. New balance: ${balance}`
         }
         return 'Invalid deposit amount'
       },

       withdraw: (amount) => {
         if (amount > 0 && amount <= balance) {
           balance -= amount
           return `Withdrawn ${amount}. New balance: ${balance}`
         }
         return 'Invalid withdrawal amount'
       },

       getBalance: () => balance,
     }
   }

   const account = createBankAccount(100)
   console.log(account.getBalance()) // 100
   console.log(account.deposit(50)) // Deposited 50. New balance: 150
   console.log(account.withdraw(30)) // Withdrawn 30. New balance: 120
   console.log(account.balance) // undefined (private)
   ```

### **Advanced Closure Patterns**

1. **Partial Application**

   ```javascript
   function partial(fn, ...args) {
     return function partiallyApplied(...moreArgs) {
       return fn(...args, ...moreArgs)
     }
   }

   function greet(greeting, name) {
     return `${greeting}, ${name}!`
   }

   const sayHello = partial(greet, 'Hello')
   console.log(sayHello('John')) // Hello, John!
   console.log(sayHello('Jane')) // Hello, Jane!

   // More practical example
   function fetchFromAPI(baseURL, endpoint) {
     return fetch(`${baseURL}${endpoint}`)
   }

   const fetchFromUsers = partial(fetchFromAPI, 'https://api.example.com/users')
   fetchFromUsers('/123') // Fetches from https://api.example.com/users/123
   fetchFromUsers('/456') // Fetches from https://api.example.com/users/456
   ```

2. **Memoization**

   ```javascript
   function memoize(fn) {
     const cache = new Map()

     return function memoized(...args) {
       const key = JSON.stringify(args)

       if (cache.has(key)) {
         console.log('Fetching from cache')
         return cache.get(key)
       }

       console.log('Computing result')
       const result = fn.apply(this, args)
       cache.set(key, result)
       return result
     }
   }

   // Example with expensive computation
   function fibonacci(n) {
     if (n <= 1) return n
     return fibonacci(n - 1) + fibonacci(n - 2)
   }

   const memoizedFib = memoize(fibonacci)
   console.log(memoizedFib(40)) // Computes
   console.log(memoizedFib(40)) // Returns from cache
   ```

3. **Currying**

   ```javascript
   function curry(fn) {
     return function curried(...args) {
       if (args.length >= fn.length) {
         return fn.apply(this, args)
       }

       return function (...moreArgs) {
         return curried.apply(this, args.concat(moreArgs))
       }
     }
   }

   // Example usage
   function add(a, b, c) {
     return a + b + c
   }

   const curriedAdd = curry(add)
   console.log(curriedAdd(1)(2)(3)) // 6
   console.log(curriedAdd(1, 2)(3)) // 6
   console.log(curriedAdd(1)(2, 3)) // 6

   // Practical example
   const formatMessage = curry((template, value) =>
     template.replace('%s', value),
   )
   const formatError = formatMessage('Error: %s')
   const formatSuccess = formatMessage('Success: %s')

   console.log(formatError('Not found')) // Error: Not found
   console.log(formatSuccess('Saved!')) // Success: Saved!
   ```

## **Module Patterns**

### **Classic Module Pattern**

1. **Basic Module**

   ```javascript
   const calculator = (function () {
     // Private variables and functions
     let result = 0

     function validate(num) {
       return typeof num === 'number' && !isNaN(num)
     }

     // Public API
     return {
       add: function (num) {
         if (validate(num)) {
           result += num
         }
         return this
       },

       subtract: function (num) {
         if (validate(num)) {
           result -= num
         }
         return this
       },

       getResult: function () {
         return result
       },
     }
   })()

   calculator.add(5).subtract(3)
   console.log(calculator.getResult()) // 2
   console.log(calculator.result) // undefined (private)
   ```

2. **Revealing Module Pattern**

   ```javascript
   const userModule = (function () {
     // Private members
     const users = new Map()

     function addUser(id, user) {
       users.set(id, user)
     }

     function getUser(id) {
       return users.get(id)
     }

     function removeUser(id) {
       users.delete(id)
     }

     // Reveal public API
     return {
       add: addUser,
       get: getUser,
       remove: removeUser,
     }
   })()

   userModule.add(1, { name: 'John' })
   console.log(userModule.get(1)) // { name: 'John' }
   userModule.remove(1)
   console.log(userModule.get(1)) // undefined
   ```

### **ES Modules**

```javascript
// mathUtils.js
const privateValue = 'This is private'

export function add(a, b) {
  return a + b
}

export function multiply(a, b) {
  return a * b
}

export default {
  add,
  multiply,
}

// main.js
import mathUtils, { add, multiply } from './mathUtils.js'

console.log(add(2, 3)) // 5
console.log(multiply(2, 3)) // 6
console.log(privateValue) // ReferenceError
```

## **Common Pitfalls and Solutions**

1. **Loop Closures**

   ```javascript
   // Problem
   function createFunctions() {
     const functions = []

     for (var i = 0; i < 3; i++) {
       functions.push(function () {
         console.log(i)
       })
     }

     return functions
   }

   const fns = createFunctions()
   fns[0]() // 3
   fns[1]() // 3
   fns[2]() // 3

   // Solution 1: Using let
   function createFunctionsFixed1() {
     const functions = []

     for (let i = 0; i < 3; i++) {
       functions.push(function () {
         console.log(i)
       })
     }

     return functions
   }

   // Solution 2: Using IIFE
   function createFunctionsFixed2() {
     const functions = []

     for (var i = 0; i < 3; i++) {
       functions.push(
         (function (value) {
           return function () {
             console.log(value)
           }
         })(i),
       )
     }

     return functions
   }
   ```

2. **Memory Leaks**

   ```javascript
   // Problem
   function setupHandler() {
     let element = document.getElementById('button')
     let heavyData = new Array(1000000)

     element.addEventListener('click', function () {
       console.log(heavyData.length)
     })
   }

   // Solution
   function setupHandlerFixed() {
     let element = document.getElementById('button')
     let heavyData = new Array(1000000)

     function handler() {
       console.log(heavyData.length)
     }

     element.addEventListener('click', handler)

     // Cleanup function
     return function cleanup() {
       element.removeEventListener('click', handler)
       heavyData = null
     }
   }
   ```

3. **this Context**

   ```javascript
   // Problem
   const user = {
     name: 'John',
     greetLater: function () {
       setTimeout(function () {
         console.log(`Hello, ${this.name}`)
       }, 1000)
     },
   }

   user.greetLater() // Hello, undefined

   // Solution 1: Arrow Function
   const user1 = {
     name: 'John',
     greetLater: function () {
       setTimeout(() => {
         console.log(`Hello, ${this.name}`)
       }, 1000)
     },
   }

   // Solution 2: Bind
   const user2 = {
     name: 'John',
     greetLater: function () {
       setTimeout(
         function () {
           console.log(`Hello, ${this.name}`)
         }.bind(this),
         1000,
       )
     },
   }
   ```

## **Performance Considerations**

1. **Memory Usage**

   ```javascript
   // Memory-intensive
   function createLargeClosures() {
     const largeData = new Array(1000000)

     return function () {
       return largeData
     }
   }

   // Better approach
   const largeData = new Array(1000000)

   function accessData() {
     return largeData
   }
   ```

2. **Scope Chain Depth**

   ```javascript
   // Deep scope chain (slower variable lookup)
   function outer() {
     const a = 1
     return function middle() {
       const b = 2
       return function inner() {
         const c = 3
         return a + b + c
       }
     }
   }

   // Flatter scope (faster variable lookup)
   const a = 1
   const b = 2

   function calculate() {
     const c = 3
     return a + b + c
   }
   ```

## **Interview Questions**

1. "Explain how closures work in JavaScript and provide an example."
2. "What is the difference between lexical scope and dynamic scope?"
3. "How would you implement a private variable in JavaScript using closures?"
4. "Explain the module pattern and its benefits."
5. "How does variable hoisting affect closures?"
6. "What are the potential memory implications of closures?"

## **Practice Problems**

1. Implement a memoization function that can cache based on multiple arguments
2. Create a throttle function using closures
3. Build a simple event emitter using the module pattern
4. Implement a currying function that works with any number of arguments

## **Additional Resources**

- [MDN Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
- [JavaScript Module Pattern](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#modulepatternjavascript)
- [You Don't Know JS: Scope & Closures](https://github.com/getify/You-Dont-Know-JS/tree/2nd-ed/scope-closures)

Would you like me to:

1. Add more practical examples?
2. Include more interview questions?
3. Add more performance optimization techniques?
4. Create more practice problems?
