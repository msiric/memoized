# **TypeScript System Design**

Mastering TypeScript system design involves understanding how to create scalable, maintainable architectures while leveraging TypeScript's type system for robust application design.

## **Advanced Generics**

### **Generic Constraints and Defaults**

```typescript
// Generic constraints with interfaces
interface HasId {
  id: string | number
}

interface HasTimestamps {
  createdAt: Date
  updatedAt: Date
}

// Repository pattern with constrained generics
class Repository<T extends HasId & HasTimestamps> {
  private items: T[] = []

  findById(id: T['id']): T | undefined {
    return this.items.find((item) => item.id === id)
  }

  findRecent(days: number): T[] {
    const cutoff = new Date()
    cutoff.setDate(cutoff.getDate() - days)
    return this.items.filter((item) => item.createdAt >= cutoff)
  }
}

// Usage
interface User extends HasId, HasTimestamps {
  name: string
  email: string
}

const userRepo = new Repository<User>()
```

### **Advanced Generic Patterns**

```typescript
// Factory with generics
interface Model {
  id: string
}

class ModelFactory<T extends Model> {
  private static instances = new Map<string, Model>()

  static create<U extends Model>(
    this: new () => U,
    data: Omit<U, keyof Model>,
  ): U {
    const instance = new this()
    Object.assign(instance, data)
    this.instances.set(instance.id, instance)
    return instance
  }
}

// Service layer with generics
interface CrudOperations<T, ID> {
  create(data: Omit<T, 'id'>): Promise<T>
  read(id: ID): Promise<T | null>
  update(id: ID, data: Partial<T>): Promise<T>
  delete(id: ID): Promise<boolean>
}

class BaseService<T extends HasId> implements CrudOperations<T, string> {
  constructor(private readonly repository: Repository<T>) {}

  async create(data: Omit<T, 'id'>): Promise<T> {
    // Implementation
  }

  async read(id: string): Promise<T | null> {
    // Implementation
  }

  async update(id: string, data: Partial<T>): Promise<T> {
    // Implementation
  }

  async delete(id: string): Promise<boolean> {
    // Implementation
  }
}
```

## **Decorators and Metadata**

### **Class and Method Decorators**

```typescript
// Method decorator for logging
function log(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value

  descriptor.value = function (...args: any[]) {
    console.log(`Calling ${propertyKey} with args:`, args)
    const result = originalMethod.apply(this, args)
    console.log(`${propertyKey} returned:`, result)
    return result
  }

  return descriptor
}

// Validation decorator
function validate(schema: any) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor,
  ) {
    const originalMethod = descriptor.value

    descriptor.value = function (...args: any[]) {
      const valid = schema.validate(args[0])
      if (!valid) {
        throw new Error('Validation failed')
      }
      return originalMethod.apply(this, args)
    }

    return descriptor
  }
}

// Usage
class UserService {
  @log
  @validate(userSchema)
  async createUser(userData: any) {
    // Implementation
  }
}
```

### **Property Decorators**

```typescript
// Property validation decorator
function required(target: any, propertyKey: string) {
  let value: any

  const getter = function () {
    return value
  }

  const setter = function (newVal: any) {
    if (newVal === undefined || newVal === null) {
      throw new Error(`${propertyKey} is required`)
    }
    value = newVal
  }

  Object.defineProperty(target, propertyKey, {
    get: getter,
    set: setter,
    enumerable: true,
    configurable: true,
  })
}

// Usage
class User {
  @required
  name!: string

  @required
  email!: string
}
```

## **Abstract Classes and Interfaces**

### **Abstract Service Layer**

```typescript
// Abstract base service
abstract class BaseService<T extends HasId> {
  abstract getRepository(): Repository<T>

  async findById(id: string): Promise<T | null> {
    return this.getRepository().findById(id)
  }

  async create(data: Omit<T, 'id'>): Promise<T> {
    return this.getRepository().create(data)
  }
}

// Implementation
class UserService extends BaseService<User> {
  private repository: Repository<User>

  constructor() {
    super()
    this.repository = new Repository<User>()
  }

  getRepository(): Repository<User> {
    return this.repository
  }

  // Additional user-specific methods
  async findByEmail(email: string): Promise<User | null> {
    // Implementation
  }
}
```

### **Interface Segregation**

```typescript
// Core interfaces
interface Readable<T, ID> {
  read(id: ID): Promise<T | null>
  list(filters?: Partial<T>): Promise<T[]>
}

interface Writable<T, ID> {
  create(data: Omit<T, 'id'>): Promise<T>
  update(id: ID, data: Partial<T>): Promise<T>
  delete(id: ID): Promise<boolean>
}

interface Searchable<T> {
  search(query: string): Promise<T[]>
}

// Combined service interface
interface FullService<T, ID>
  extends Readable<T, ID>,
    Writable<T, ID>,
    Searchable<T> {}

// Implementation
class UserService implements FullService<User, string> {
  // Implementation of all interface methods
}
```

## **Module Patterns**

### **Feature Module Pattern**

```typescript
// feature/user/types.ts
export interface User {
  id: string
  name: string
  email: string
}

// feature/user/repository.ts
export class UserRepository extends Repository<User> {
  // User-specific repository methods
}

// feature/user/service.ts
export class UserService extends BaseService<User> {
  // User-specific service methods
}

// feature/user/index.ts
export * from './types'
export * from './repository'
export * from './service'

// Usage
import { UserService } from './feature/user'
```

### **Dependency Injection Pattern**

```typescript
// Container setup
type Constructor<T = any> = new (...args: any[]) => T

class Container {
  private services = new Map<string, any>()

  register<T>(token: string, service: Constructor<T>) {
    this.services.set(token, new service())
  }

  resolve<T>(token: string): T {
    const service = this.services.get(token)
    if (!service) {
      throw new Error(`Service ${token} not found`)
    }
    return service
  }
}

// Usage
const container = new Container()
container.register('UserService', UserService)
const userService = container.resolve<UserService>('UserService')
```

## **Performance Optimization**

### **Type-Level Optimization**

```typescript
// Using interfaces instead of types for better compilation
interface State {
  user: User
  settings: Settings
}

// Instead of
type State = {
  user: User
  settings: Settings
}

// Using type literals for better inference
const createAction = <T extends string, P = void>(
  type: T,
): P extends void ? { type: T } : { type: T; payload: P } => {
  return { type } as any
}
```

### **Runtime Optimization**

```typescript
// Memoization with correct typing
function memoize<T extends (...args: any[]) => any>(fn: T): T {
  const cache = new Map()

  return ((...args: Parameters<T>): ReturnType<T> => {
    const key = JSON.stringify(args)
    if (cache.has(key)) {
      return cache.get(key)
    }
    const result = fn(...args)
    cache.set(key, result)
    return result
  }) as T
}

// Lazy loading with types
const lazyLoad = <T>(loader: () => Promise<T>): (() => Promise<T>) => {
  let instance: T | null = null
  return async () => {
    if (!instance) {
      instance = await loader()
    }
    return instance
  }
}
```

## **Compiler Configuration and API**

### **Advanced tsconfig.json**

```json
{
  "compilerOptions": {
    "target": "es2020",
    "module": "esnext",
    "strict": true,
    "moduleResolution": "node",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "sourceMap": true,
    "declaration": true,
    "declarationMap": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "forceConsistentCasingInFileNames": true,
    "paths": {
      "@/*": ["src/*"]
    }
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### **Custom Type Definitions**

```typescript
// global.d.ts
declare global {
  interface Window {
    __INITIAL_STATE__: any
  }
}

// module.d.ts
declare module 'my-module' {
  export interface Options {
    timeout?: number
    retries?: number
  }

  export function initialize(options?: Options): void
}
```

## **Interview Questions**

1. "How would you design a type-safe event system in TypeScript?"
2. "Explain how you would implement dependency injection in TypeScript."
3. "What are the benefits of using abstract classes vs interfaces?"
4. "How would you handle API responses with TypeScript?"
5. "Explain the role of decorators in TypeScript system design."

## **Practice Problems**

1. Implement a type-safe event emitter system
2. Create a dependency injection container with type safety
3. Design a repository pattern with generic types
4. Implement a type-safe API client

## **Additional Resources**

- [TypeScript Design Patterns](https://refactoring.guru/design-patterns/typescript)
- [TypeScript Compiler API](https://github.com/Microsoft/TypeScript/wiki/Using-the-Compiler-API)
- [Clean Code TypeScript](https://github.com/labs42io/clean-code-typescript)

Would you like me to:

1. Add more practical examples?
2. Include more interview questions?
3. Add more design patterns?
4. Create more practice problems?
