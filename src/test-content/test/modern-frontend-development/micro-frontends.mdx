# **Micro-Frontend Architecture: Core Concepts & Implementation**

This lesson covers fundamental concepts of micro-frontends and their implementation using modern web technologies.

## **Module Federation**

### **Basic Configuration**

```typescript
// webpack.config.js for host application
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin')

module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'host',
      filename: 'remoteEntry.js',
      remotes: {
        dashboard: 'dashboard@http://localhost:3001/remoteEntry.js',
        profile: 'profile@http://localhost:3002/remoteEntry.js',
      },
      shared: {
        react: { singleton: true, requiredVersion: '^17.0.0' },
        'react-dom': { singleton: true, requiredVersion: '^17.0.0' },
      },
    }),
  ],
}

// webpack.config.js for remote application
module.exports = {
  plugins: [
    new ModuleFederationPlugin({
      name: 'dashboard',
      filename: 'remoteEntry.js',
      exposes: {
        './DashboardApp': './src/bootstrap',
      },
      shared: {
        react: { singleton: true, requiredVersion: '^17.0.0' },
        'react-dom': { singleton: true, requiredVersion: '^17.0.0' },
      },
    }),
  ],
}
```

### **Dynamic Module Loading**

```typescript
// Dynamic import wrapper
const loadRemoteModule = async (scope: string, module: string) => {
  // Initializes the share scope
  await __webpack_init_sharing__('default');

  const container = window[scope];
  await container.init(__webpack_share_scopes__.default);

  const factory = await container.get(module);
  return factory();
};

// React component for loading remote modules
interface RemoteComponentProps {
  scope: string;
  module: string;
  fallback?: React.ReactNode;
}

const RemoteComponent: React.FC<RemoteComponentProps> = ({
  scope,
  module,
  fallback = null
}) => {
  const [Component, setComponent] = useState<React.ComponentType | null>(null);

  useEffect(() => {
    loadRemoteModule(scope, module)
      .then(module => setComponent(() => module.default))
      .catch(err => console.error(`Error loading ${scope}/${module}:`, err));
  }, [scope, module]);

  if (!Component) return fallback;
  return <Component />;
};

// Usage
const App = () => (
  <div>
    <RemoteComponent
      scope="dashboard"
      module="./DashboardApp"
      fallback={<div>Loading Dashboard...</div>}
    />
  </div>
);
```

## **Routing and Navigation**

### **Federated Routing**

```typescript
// Routing configuration for micro-frontends
interface RouteConfig {
  path: string;
  scope: string;
  module: string;
  exact?: boolean;
}

const routes: RouteConfig[] = [
  {
    path: '/dashboard',
    scope: 'dashboard',
    module: './DashboardApp',
    exact: true
  },
  {
    path: '/profile',
    scope: 'profile',
    module: './ProfileApp',
    exact: true
  }
];

// Router implementation
const FederatedRouter: React.FC = () => {
  return (
    <Router>
      <Switch>
        {routes.map(route => (
          <Route
            key={route.path}
            path={route.path}
            exact={route.exact}
            render={() => (
              <RemoteComponent
                scope={route.scope}
                module={route.module}
                fallback={<div>Loading...</div>}
              />
            )}
          />
        ))}
      </Switch>
    </Router>
  );
};

// Navigation service
class NavigationService {
  private listeners = new Set<(path: string) => void>();

  navigate(path: string) {
    window.history.pushState(null, '', path);
    this.notifyListeners(path);
  }

  subscribe(listener: (path: string) => void) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private notifyListeners(path: string) {
    this.listeners.forEach(listener => listener(path));
  }
}
```

## **Shared Dependencies**

### **Dependency Management**

```typescript
// shared-deps.ts
export const sharedDeps = {
  react: { singleton: true, requiredVersion: '^17.0.0' },
  'react-dom': { singleton: true, requiredVersion: '^17.0.0' },
  '@material-ui/core': { singleton: true, requiredVersion: '^4.0.0' },
  'styled-components': { singleton: true, requiredVersion: '^5.0.0' },
}

// Version compatibility checker
const checkVersionCompatibility = (
  required: string,
  actual: string,
): boolean => {
  const [reqMajor, reqMinor] = required.replace('^', '').split('.')
  const [actualMajor, actualMinor] = actual.split('.')

  return actualMajor === reqMajor && parseInt(actualMinor) >= parseInt(reqMinor)
}

// Shared dependency loader
const loadSharedModule = async (
  moduleName: string,
  version: string,
): Promise<any> => {
  const moduleMap = await window.__webpack_share_scopes__.default

  if (
    moduleMap[moduleName] &&
    checkVersionCompatibility(version, moduleMap[moduleName].version)
  ) {
    return moduleMap[moduleName].get()
  }

  throw new Error(`Shared module ${moduleName}@${version} not found`)
}
```

## **Communication Patterns**

### **Event Bus Implementation**

```typescript
// Event bus for micro-frontend communication
type EventCallback = (data: any) => void

class EventBus {
  private events: Map<string, Set<EventCallback>> = new Map()

  subscribe(event: string, callback: EventCallback): () => void {
    if (!this.events.has(event)) {
      this.events.set(event, new Set())
    }

    this.events.get(event)!.add(callback)

    return () => {
      const callbacks = this.events.get(event)
      if (callbacks) {
        callbacks.delete(callback)
        if (callbacks.size === 0) {
          this.events.delete(event)
        }
      }
    }
  }

  publish(event: string, data: any): void {
    const callbacks = this.events.get(event)
    if (callbacks) {
      callbacks.forEach((callback) => callback(data))
    }
  }
}

// React hook for event bus
const useEventBus = (event: string, callback: EventCallback): void => {
  useEffect(() => {
    const unsubscribe = eventBus.subscribe(event, callback)
    return unsubscribe
  }, [event, callback])
}

// Custom event emitter
const createCustomEvent = (name: string, detail: any): CustomEvent => {
  return new CustomEvent(name, {
    bubbles: true,
    detail,
  })
}
```

### **Shared State Management**

```typescript
// Global state manager for micro-frontends
class SharedStateManager {
  private state: Map<string, any> = new Map()
  private subscribers: Map<string, Set<(value: any) => void>> = new Map()

  setState(key: string, value: any): void {
    this.state.set(key, value)
    this.notifySubscribers(key, value)
  }

  getState(key: string): any {
    return this.state.get(key)
  }

  subscribe(key: string, callback: (value: any) => void): () => void {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set())
    }

    this.subscribers.get(key)!.add(callback)

    return () => {
      const callbacks = this.subscribers.get(key)
      if (callbacks) {
        callbacks.delete(callback)
      }
    }
  }

  private notifySubscribers(key: string, value: any): void {
    const callbacks = this.subscribers.get(key)
    if (callbacks) {
      callbacks.forEach((callback) => callback(value))
    }
  }
}

// React hook for shared state
const useSharedState = <T>(
  key: string,
  initialValue: T,
): [T, (value: T) => void] => {
  const [state, setState] = useState<T>(() => {
    const existing = sharedStateManager.getState(key)
    return existing ?? initialValue
  })

  useEffect(() => {
    const unsubscribe = sharedStateManager.subscribe(key, (value) =>
      setState(value),
    )
    return unsubscribe
  }, [key])

  const updateState = useCallback(
    (value: T) => {
      sharedStateManager.setState(key, value)
    },
    [key],
  )

  return [state, updateState]
}
```

## **Build System Setup**

### **Build Configuration**

```typescript
// webpack.common.js
const path = require('path')
const ModuleFederationPlugin = require('webpack/lib/container/ModuleFederationPlugin')
const { sharedDeps } = require('./shared-deps')

module.exports = (name, exposes = {}) => ({
  output: {
    path: path.resolve(__dirname, 'dist'),
    publicPath: 'auto',
  },
  resolve: {
    extensions: ['.ts', '.tsx', '.js'],
  },
  module: {
    rules: [
      {
        test: /\.tsx?$/,
        loader: 'ts-loader',
        exclude: /node_modules/,
      },
    ],
  },
  plugins: [
    new ModuleFederationPlugin({
      name,
      filename: 'remoteEntry.js',
      exposes,
      shared: sharedDeps,
    }),
  ],
})

// webpack.dev.js
const { merge } = require('webpack-merge')
const common = require('./webpack.common')

module.exports = merge(
  common('dashboard', {
    './DashboardApp': './src/bootstrap',
  }),
  {
    mode: 'development',
    devServer: {
      port: 3001,
      historyApiFallback: true,
      headers: {
        'Access-Control-Allow-Origin': '*',
      },
    },
  },
)
```

### **TypeScript Configuration**

```typescript
// tsconfig.json for micro-frontends
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react",
    "baseUrl": "src"
  },
  "include": ["src"]
}

// Module declaration for remote types
declare module "dashboard/DashboardApp" {
  const DashboardApp: React.ComponentType;
  export default DashboardApp;
}
```

## **Interview Questions**

1. "What are the key benefits and challenges of implementing micro-frontends?"
2. "How would you handle shared dependencies between micro-frontends?"
3. "Explain the different approaches to micro-frontend communication."
4. "How would you implement routing in a micro-frontend architecture?"
5. "What strategies would you use for sharing state between micro-frontends?"
6. "How would you handle version conflicts in shared dependencies?"

## **Practice Problems**

1. Implement a micro-frontend architecture with module federation
2. Create a shared state management system for micro-frontends
3. Build a routing system that works across micro-frontends
4. Implement an event bus for micro-frontend communication

## **Additional Resources**

- [Webpack Module Federation](https://webpack.js.org/concepts/module-federation/)
- [Micro-Frontends](https://micro-frontends.org/)
- [Module Federation Examples](https://github.com/module-federation/module-federation-examples)

Would you like me to:

1. Add more practical examples?
2. Include more interview questions?
3. Add more implementation patterns?
4. Create more practice problems?
