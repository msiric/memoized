export const metadata = {
  title: 'Comprehensive Guide to K-way Merge in JavaScript',
  description: 'Merge multiple sorted arrays. Understand the k-way merge technique, performance considerations, and practical examples.',
}

# **K-way Merge**

The K-way Merge technique is used to efficiently merge multiple sorted arrays (or lists) into one sorted array. This technique leverages a min-heap (priority queue) to keep track of the smallest elements across all arrays, ensuring that the final merged array is sorted.

## **Concept and Use Cases**

**Definition:**
K-way Merge involves merging K sorted arrays (or lists) into a single sorted array. A min-heap is commonly used to keep track of the smallest elements from each array, allowing for efficient merging.

**Common Use Cases:**
- Merging K sorted arrays.
- Implementing external sorting algorithms.
- Merging K sorted linked lists.
- Solving problems involving sorted data streams.

## **When to Use**
- When you need to merge multiple sorted arrays or lists into a single sorted array.
- When solving problems that require maintaining a sorted order across multiple data streams.
- When dealing with large data sets that do not fit into memory (external sorting).

## **Time and Space Complexity**

**Time Complexity:** 
- O(N log K), where N is the total number of elements across all K arrays. Each element is inserted into and removed from the heap, which has a log K complexity.

**Space Complexity:**
- O(K) for storing the heap of size K.

## **Merging K Sorted Arrays**

**Problem:** Given K sorted arrays, merge them into a single sorted array.

**Step-by-Step Solution:**
1. Use a min-heap to keep track of the smallest elements from each array.
2. Insert the first element of each array into the heap along with the array index and element index.
3. Extract the smallest element from the heap and add it to the result array.
4. If the extracted element has a next element in the same array, insert the next element into the heap.
5. Repeat steps 3-4 until the heap is empty.

**Code Example:**
```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.heap[0];
    }

    insert(value) {
        this.heap.push(value);
        this._heapifyUp();
    }

    extractMin() {
        if (this.size() === 1) return this.heap.pop();
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._heapifyDown();
        return min;
    }

    _heapifyUp() {
        let index = this.size() - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].value >= this.heap[parentIndex].value) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    _heapifyDown() {
        let index = 0;
        const length = this.size();
        const element = this.heap[0];
        while (true) {
            let leftChildIndex = 2 * index + 1;
            let rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swap = null;

            if (leftChildIndex < length) {
                leftChild = this.heap[leftChildIndex];
                if (leftChild.value < element.value) swap = leftChildIndex;
            }

            if (rightChildIndex < length) {
                rightChild = this.heap[rightChildIndex];
                if ((swap === null && rightChild.value < element.value) || (swap !== null && rightChild.value < leftChild.value)) {
                    swap = rightChildIndex;
                }
            }

            if (swap === null) break;
            [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];
            index = swap;
        }
    }
}

function mergeKSortedArrays(arrays) {
    const minHeap = new MinHeap();
    const result = [];

    // Insert the first element of each array into the heap
    for (let i = 0; i < arrays.length; i++) {
        if (arrays[i].length > 0) {
            minHeap.insert({ value: arrays[i][0], arrayIndex: i, elementIndex: 0 });
        }
    }

    while (minHeap.size() > 0) {
        const { value, arrayIndex, elementIndex } = minHeap.extractMin();
        result.push(value);

        // If there is a next element in the same array, insert it into the heap
        if (elementIndex + 1 < arrays[arrayIndex].length) {
            minHeap.insert({ value: arrays[arrayIndex][elementIndex + 1], arrayIndex, elementIndex: elementIndex + 1 });
        }
    }

    return result;
}

// Example usage:
const arrays = [
    [1, 4, 7],
    [2, 5, 8],
    [3, 6, 9]
];
console.log(mergeKSortedArrays(arrays));  // Output: [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**Tips and Tricks:**
- Use a min-heap to efficiently keep track of the smallest elements from each array.
- Insert the first element of each array into the heap to initialize it.
- Ensure to check for the next element in the array before inserting it into the heap.

**Frequent Gotchas:**
- Forgetting to insert the next element from the same array into the heap.
- Not maintaining the heap property correctly during insertion and extraction.
- Handling edge cases where arrays are empty or of different lengths.

## **Merging K Sorted Linked Lists**

**Problem:** Given K sorted linked lists, merge them into a single sorted linked list.

**Step-by-Step Solution:**
1. Use a min-heap to keep track of the smallest elements from each linked list.
2. Insert the head of each linked list into the heap along with the list node.
3. Extract the smallest element from the heap and add it to the result linked list.
4. If the extracted element has a next node, insert the next node into the heap.
5. Repeat steps 3-4 until the heap is empty.

**Code Example:**
```javascript
class ListNode {
    constructor(value = 0, next = null) {
        this.value = value;
        this.next = next;
    }
}

class MinHeap {
    constructor() {
        this.heap = [];
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.heap[0];
    }

    insert(node) {
        this.heap.push(node);
        this._heapifyUp();
    }

    extractMin() {
        if (this.size() === 1) return this.heap.pop();
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._heapifyDown();
        return min;
    }

    _heapifyUp() {
        let index = this.size() - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].value >= this.heap[parentIndex].value) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    _heapifyDown() {
        let index = 0;
        const length = this.size();
        const element = this.heap[0];
        while (true) {
            let leftChildIndex = 2 * index + 1;
            let rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swap = null;

            if (leftChildIndex < length) {
                leftChild = this.heap[leftChildIndex];
                if (leftChild.value < element.value) swap = leftChildIndex;
            }

            if (rightChildIndex < length) {
                rightChild = this.heap[rightChildIndex];
                if ((swap === null && rightChild.value < element.value) || (swap !== null && rightChild.value < leftChild.value)) {
                    swap = rightChildIndex;
                }
            }

            if (swap === null) break;
            [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];
            index = swap;
        }
    }
}

function mergeKLists(lists) {
    const minHeap = new MinHeap();
    const dummy = new ListNode(0);
    let current = dummy;

    // Insert the head of each linked list into the heap
    for (const list of lists) {
        if (list) {
            minHeap.insert(list);
        }
    }

    while (minHeap.size() > 0) {
        const node = minHeap.extractMin();
        current.next = node;
        current = current.next;

        // If there is a next node in the same list, insert it into the heap
        if (node.next) {
            minHeap.insert(node.next);
        }
    }

    return dummy.next;
}

// Example usage:
const list1 = new ListNode(1, new ListNode(4, new ListNode(7)));
const list2 = new ListNode(2, new ListNode(5, new ListNode(8)));
const list3 = new ListNode(3, new ListNode(6, new ListNode(9)));

const lists = [list1, list2, list3];
const mergedList = mergeKLists(lists);

let current = mergedList

;
while (current) {
    console.log(current.value);  // Output: 1, 2, 3, 4, 5, 6, 7, 8, 9
    current = current.next;
}
```

**Tips and Tricks:**
- Use a min-heap to efficiently keep track of the smallest elements from each linked list.
- Insert the head of each linked list into the heap to initialize it.
- Ensure to check for the next node in the list before inserting it into the heap.

**Frequent Gotchas:**
- Forgetting to insert the next node from the same list into the heap.
- Not maintaining the heap property correctly during insertion and extraction.
- Handling edge cases where lists are empty or of different lengths.

By mastering the K-way Merge technique, you can efficiently solve a variety of problems involving merging multiple sorted arrays or lists into a single sorted array or list. This technique is essential for optimizing time complexity and handling heap-related problems effectively in both technical interviews and real-world applications.

