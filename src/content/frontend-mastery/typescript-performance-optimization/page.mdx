# Advanced TypeScript: Performance Optimization

## Concept and Use Cases

**Definition:**
TypeScript performance optimization involves both compile-time and runtime optimizations to improve build times, reduce bundle sizes, and enhance runtime execution speed.

**Common Use Cases:**

- Large-scale applications
- Build pipeline optimization
- Runtime performance tuning
- Memory management
- Bundle size reduction
- Type checking optimization
- Hot module replacement
- Development workflow improvement

### Visual Representation:

```
Performance Optimization Areas:

Compile Time        Runtime           Bundle Size
    ↓                 ↓                  ↓
Type Checking     Execution Speed    Code Splitting
    ↓                 ↓                  ↓
Build Speed      Memory Usage       Tree Shaking
```

## Key Concepts

1. **Compile-Time Optimization:**

   - Type checking strategies
   - Project configuration
   - Build tools optimization

2. **Runtime Performance:**

   - Memory management
   - Code execution
   - Data structures

3. **Bundle Optimization:**
   - Code splitting
   - Tree shaking
   - Module organization

## Compile-Time Optimization

### 1. tsconfig.json Optimization

```json
{
  "compilerOptions": {
    // Faster incremental builds
    "incremental": true,
    "tsBuildInfoFile": "./buildcache",

    // Optimize for modern JS engines
    "target": "ES2020",
    "module": "ESNext",

    // Skip type checking of declaration files
    "skipLibCheck": true,

    // Strict type checking options
    "strict": true,

    // Module resolution optimization
    "moduleResolution": "node",
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"]
    },

    // Enable faster builds with separate type checking
    "isolatedModules": true,

    // Improve build performance
    "preserveWatchOutput": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "build"]
}
```

### 2. Project References

```typescript
// project-references.json
{
    "references": [
        { "path": "./packages/core" },
        { "path": "./packages/ui" },
        { "path": "./packages/utils" }
    ]
}

// packages/core/tsconfig.json
{
    "compilerOptions": {
        "composite": true,
        "outDir": "./dist",
        "rootDir": "./src"
    }
}
```

## Runtime Performance

### 1. Memory Management

```typescript
// Bad: Memory leak through closure
function createLeakyCache() {
  const cache = new Map<string, any>()

  return {
    set: (key: string, value: any) => {
      cache.set(key, value)
    },
    get: (key: string) => cache.get(key),
  }
}

// Good: Proper cleanup
class Cache<T> {
  private cache = new Map<string, T>()
  private maxSize: number

  constructor(maxSize: number = 1000) {
    this.maxSize = maxSize
  }

  set(key: string, value: T): void {
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value
      this.cache.delete(firstKey)
    }
    this.cache.set(key, value)
  }

  get(key: string): T | undefined {
    return this.cache.get(key)
  }

  clear(): void {
    this.cache.clear()
  }
}
```

### 2. Data Structure Optimization

```typescript
// Optimized array operations
class OptimizedArray<T> {
  private items: T[]
  private size: number

  constructor(capacity: number = 10) {
    this.items = new Array(capacity)
    this.size = 0
  }

  push(item: T): void {
    if (this.size === this.items.length) {
      this.resize()
    }
    this.items[this.size++] = item
  }

  private resize(): void {
    const newItems = new Array(this.items.length * 2)
    for (let i = 0; i < this.size; i++) {
      newItems[i] = this.items[i]
    }
    this.items = newItems
  }

  // Optimized iteration
  forEach(callback: (item: T, index: number) => void): void {
    for (let i = 0; i < this.size; i++) {
      callback(this.items[i], i)
    }
  }
}

// Optimized Set operations
class FastSet<T> {
  private map = new Map<T, boolean>()

  add(item: T): void {
    this.map.set(item, true)
  }

  has(item: T): boolean {
    return this.map.has(item)
  }

  delete(item: T): void {
    this.map.delete(item)
  }
}
```

### 3. Function Optimization

```typescript
// Function optimizations
class PerformanceOptimizations {
  // Memoization
  private memoize<T, R>(fn: (arg: T) => R): (arg: T) => R {
    const cache = new Map<T, R>()

    return (arg: T): R => {
      if (cache.has(arg)) {
        return cache.get(arg)!
      }
      const result = fn(arg)
      cache.set(arg, result)
      return result
    }
  }

  // Object pool
  private objectPool<T>(
    factory: () => T,
    size: number = 1000,
  ): {
    acquire: () => T
    release: (obj: T) => void
  } {
    const pool: T[] = Array.from({ length: size }, factory)

    return {
      acquire: () => pool.pop() ?? factory(),
      release: (obj: T) => {
        if (pool.length < size) {
          pool.push(obj)
        }
      },
    }
  }
}
```

## Bundle Optimization

### 1. Code Splitting

```typescript
// Dynamic imports for code splitting
class Router {
  async loadRoute(route: string): Promise<void> {
    switch (route) {
      case 'home':
        const { HomeComponent } = await import('./routes/home')
        return new HomeComponent()
      case 'dashboard':
        const { DashboardComponent } = await import('./routes/dashboard')
        return new DashboardComponent()
      default:
        const { NotFoundComponent } = await import('./routes/not-found')
        return new NotFoundComponent()
    }
  }
}

// Conditional imports
async function loadFeature(feature: string): Promise<void> {
  if (process.env.NODE_ENV === 'development') {
    const { DevFeature } = await import('./features/dev')
    return new DevFeature()
  } else {
    const { ProdFeature } = await import('./features/prod')
    return new ProdFeature()
  }
}
```

### 2. Tree Shaking Optimization

```typescript
// Optimized for tree shaking
// Good
export const utils = {
  formatDate: (date: Date) => date.toISOString(),
  capitalize: (str: string) => str.charAt(0).toUpperCase() + str.slice(1),
}

// Better
export const formatDate = (date: Date) => date.toISOString()
export const capitalize = (str: string) =>
  str.charAt(0).toUpperCase() + str.slice(1)

// Usage
import { formatDate } from './utils'
```

## Advanced Optimization Techniques

### 1. Worker Thread Optimization

```typescript
// worker.ts
const ctx: Worker = self as any

ctx.addEventListener('message', (event: MessageEvent) => {
  const result = heavyComputation(event.data)
  ctx.postMessage(result)
})

// main.ts
class WorkerPool {
  private workers: Worker[] = []
  private queue: Function[] = []
  private activeWorkers = 0

  constructor(private maxWorkers: number = navigator.hardwareConcurrency) {
    for (let i = 0; i < maxWorkers; i++) {
      this.workers.push(new Worker('./worker.ts'))
    }
  }

  async execute<T>(data: T): Promise<T> {
    return new Promise((resolve) => {
      const task = () => {
        const worker = this.workers[this.activeWorkers % this.maxWorkers]
        this.activeWorkers++

        worker.onmessage = (e: MessageEvent) => {
          this.activeWorkers--
          resolve(e.data)
          this.processQueue()
        }

        worker.postMessage(data)
      }

      if (this.activeWorkers < this.maxWorkers) {
        task()
      } else {
        this.queue.push(task)
      }
    })
  }

  private processQueue(): void {
    if (this.queue.length > 0 && this.activeWorkers < this.maxWorkers) {
      const task = this.queue.shift()
      task?.()
    }
  }
}
```

### 2. Memory Profiling

```typescript
class MemoryProfiler {
  private snapshots: any[] = []

  takeSnapshot(): void {
    if (process.env.NODE_ENV === 'development') {
      const snapshot = (performance as any).memory
      this.snapshots.push({
        timestamp: Date.now(),
        usedJSHeapSize: snapshot.usedJSHeapSize,
        totalJSHeapSize: snapshot.totalJSHeapSize,
      })
    }
  }

  analyzeMemoryUsage(): void {
    const lastSnapshot = this.snapshots[this.snapshots.length - 1]
    const firstSnapshot = this.snapshots[0]

    console.log('Memory usage analysis:', {
      duration: lastSnapshot.timestamp - firstSnapshot.timestamp,
      heapGrowth: lastSnapshot.usedJSHeapSize - firstSnapshot.usedJSHeapSize,
      maxHeapSize: Math.max(...this.snapshots.map((s) => s.totalJSHeapSize)),
    })
  }
}
```

## Interview Tips and Tricks

1. **Performance Metrics:**

   - Understanding key performance indicators
   - Measuring performance impact
   - Profiling tools

2. **Optimization Strategies:**

   - When to optimize
   - Cost-benefit analysis
   - Testing performance improvements

3. **Common Pitfalls:**
   - Premature optimization
   - Memory leaks
   - Bundle size bloat

## Common Interview Questions

1. How can you optimize TypeScript compilation time?
2. What are the best practices for reducing bundle size?
3. How do you identify and fix memory leaks?
4. What are the trade-offs of different optimization techniques?
5. How do you measure the impact of performance optimizations?
6. What are some common causes of poor runtime performance?
7. How do you optimize code for tree shaking?

Understanding performance optimization in TypeScript is crucial for building efficient applications. It involves a combination of compile-time optimizations, runtime performance improvements, and bundle size reduction techniques.
