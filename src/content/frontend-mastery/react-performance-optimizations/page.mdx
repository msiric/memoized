# Advanced React: Performance Optimization

## Concept and Use Cases

**Definition:**
React performance optimization involves techniques and patterns to minimize unnecessary renders, reduce bundle size, and improve application responsiveness.

**Common Use Cases:**

- Large lists and tables
- Complex forms
- Real-time data updates
- Heavy computations
- Animation handling
- State management
- Data visualization
- Infinite scrolling

### Visual Representation:

```
Performance Optimization Areas:

Rendering → Bundle Size → Runtime → Memory
    ↓           ↓           ↓         ↓
Memoization  Code Split   Workers   Cleanup
    ↓           ↓           ↓         ↓
Components   Dynamic     Throttle   References
```

## Key Concepts

1. **Component Optimization:**

   - Render optimization
   - Props management
   - State strategies

2. **Code Organization:**

   - Code splitting
   - Bundle optimization
   - Tree shaking

3. **Resource Management:**
   - Memory leaks
   - Event cleanup
   - Cache strategies

## Implementation Examples

### 1. Component Memoization

```typescript
// Proper use of memo
interface ComplexListProps {
    items: Item[];
    onItemClick: (id: string) => void;
}

const ComplexList = memo(function ComplexList({
    items,
    onItemClick
}: ComplexListProps) {
    return (
        <div>
            {items.map(item => (
                <ComplexItem
                    key={item.id}
                    item={item}
                    onClick={onItemClick}
                />
            ))}
        </div>
    );
}, arePropsEqual);

// Custom comparison function
function arePropsEqual(
    prevProps: ComplexListProps,
    nextProps: ComplexListProps
): boolean {
    return (
        prevProps.items.length === nextProps.items.length &&
        prevProps.items.every((item, index) =>
            item.id === nextProps.items[index].id
        ) &&
        prevProps.onItemClick === nextProps.onItemClick
    );
}

// Usage with callback memoization
function ParentComponent() {
    const [items, setItems] = useState<Item[]>([]);

    const handleItemClick = useCallback((id: string) => {
        console.log('Item clicked:', id);
    }, []);

    return (
        <ComplexList
            items={items}
            onItemClick={handleItemClick}
        />
    );
}
```

### 2. State Management Optimization

```typescript
// Optimized state updates
function OptimizedForm() {
    const [formState, setFormState] = useState({
        name: '',
        email: '',
        preferences: {}
    });

    // Batch multiple state updates
    const handleSubmit = (e: FormEvent) => {
        e.preventDefault();
        ReactDOM.flushSync(() => {
            setFormState(prev => ({
                ...prev,
                submitTime: Date.now()
            }));
            setFormState(prev => ({
                ...prev,
                status: 'submitting'
            }));
        });
    };

    // Use functional updates for dependent state
    const updateField = (field: string, value: string) => {
        setFormState(prev => ({
            ...prev,
            [field]: value,
            lastUpdated: Date.now()
        }));
    };

    return (
        <form onSubmit={handleSubmit}>
            {/* Form fields */}
        </form>
    );
}

// State splitting for better performance
function ComplexDashboard() {
    const [visibleSection, setVisibleSection] = useState('overview');
    const [filters, setFilters] = useState({});
    const [data, setData] = useState([]);

    // Each state update only affects relevant components
    const updateFilters = useCallback((newFilters) => {
        setFilters(prev => ({
            ...prev,
            ...newFilters
        }));
    }, []);

    return (
        <div>
            <Navigation
                currentSection={visibleSection}
                onNavigate={setVisibleSection}
            />
            <Filters
                filters={filters}
                onFilterChange={updateFilters}
            />
            <DataDisplay data={data} />
        </div>
    );
}
```

### 3. List Virtualization

```typescript
// Virtual list implementation
interface VirtualListProps<T> {
    items: T[];
    height: number;
    itemHeight: number;
    renderItem: (item: T, index: number) => React.ReactNode;
}

function VirtualList<T>({
    items,
    height,
    itemHeight,
    renderItem
}: VirtualListProps<T>) {
    const [scrollTop, setScrollTop] = useState(0);
    const containerRef = useRef<HTMLDivElement>(null);

    const visibleItems = useMemo(() => {
        const startIndex = Math.floor(scrollTop / itemHeight);
        const endIndex = Math.min(
            startIndex + Math.ceil(height / itemHeight) + 1,
            items.length
        );

        return items
            .slice(startIndex, endIndex)
            .map((item, index) => ({
                item,
                index: startIndex + index
            }));
    }, [items, scrollTop, height, itemHeight]);

    const handleScroll = useCallback((e: React.UIEvent<HTMLDivElement>) => {
        setScrollTop(e.currentTarget.scrollTop);
    }, []);

    return (
        <div
            ref={containerRef}
            style={{ height, overflow: 'auto' }}
            onScroll={handleScroll}
        >
            <div style={{ height: items.length * itemHeight }}>
                <div
                    style={{
                        transform: `translateY(${Math.floor(scrollTop / itemHeight) * itemHeight}px)`
                    }}
                >
                    {visibleItems.map(({ item, index }) => (
                        <div
                            key={index}
                            style={{ height: itemHeight }}
                        >
                            {renderItem(item, index)}
                        </div>
                    ))}
                </div>
            </div>
        </div>
    );
}

// Usage
function LargeList() {
    const items = useMemo(() =>
        Array.from({ length: 10000 }, (_, i) => ({
            id: i,
            text: `Item ${i}`
        })),
        []
    );

    return (
        <VirtualList
            items={items}
            height={400}
            itemHeight={40}
            renderItem={(item) => (
                <div className="list-item">
                    {item.text}
                </div>
            )}
        />
    );
}
```

### 4. Code Splitting and Lazy Loading

```typescript
// Route-based code splitting
const Dashboard = lazy(() => import('./pages/Dashboard'));
const Settings = lazy(() => import('./pages/Settings'));
const Profile = lazy(() => import('./pages/Profile'));

function App() {
    return (
        <Suspense fallback={<Loading />}>
            <Routes>
                <Route path="/" element={<Dashboard />} />
                <Route path="/settings" element={<Settings />} />
                <Route path="/profile" element={<Profile />} />
            </Routes>
        </Suspense>
    );
}

// Component-based code splitting
function ComplexFeature() {
    const [showAdvanced, setShowAdvanced] = useState(false);
    const AdvancedChart = lazy(() => import('./components/AdvancedChart'));

    return (
        <div>
            <button onClick={() => setShowAdvanced(true)}>
                Show Advanced
            </button>

            {showAdvanced && (
                <Suspense fallback={<Loading />}>
                    <AdvancedChart />
                </Suspense>
            )}
        </div>
    );
}
```

### 5. Memory Management

```typescript
// Cleanup pattern for subscriptions
function DataSubscriber() {
    const [data, setData] = useState(null);

    useEffect(() => {
        let mounted = true;
        const subscription = subscribeToData((newData) => {
            if (mounted) {
                setData(newData);
            }
        });

        return () => {
            mounted = false;
            subscription.unsubscribe();
        };
    }, []);

    return <div>{/* render data */}</div>;
}

// Cache management
function useMemoizedData<T>(key: string, fetcher: () => Promise<T>) {
    const cache = useRef(new Map<string, T>());

    useEffect(() => {
        return () => {
            cache.current.clear();
        };
    }, []);

    const getData = useCallback(async () => {
        if (cache.current.has(key)) {
            return cache.current.get(key)!;
        }

        const data = await fetcher();
        cache.current.set(key, data);
        return data;
    }, [key, fetcher]);

    return getData;
}
```

## Interview Tips and Tricks

1. **Performance Measurement:**

   - React DevTools Profiler
   - Performance monitoring
   - Identifying bottlenecks

2. **Optimization Strategies:**

   - When to optimize
   - Cost-benefit analysis
   - Measuring impact

3. **Common Pitfalls:**
   - Premature optimization
   - Over-memoization
   - Memory leaks

## Common Interview Questions

1. When should you use memo and useMemo?
2. How do you identify performance bottlenecks in React?
3. What are the best practices for optimizing large lists?
4. How does code splitting improve performance?
5. What are common causes of memory leaks in React?
6. How do you optimize context usage?
7. What are the trade-offs of different optimization techniques?

Understanding performance optimization in React is crucial for building scalable applications. It involves a combination of proper component architecture, state management, and resource optimization.
