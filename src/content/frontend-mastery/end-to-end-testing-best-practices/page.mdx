# Advanced Frontend: End-to-End Testing

## Concept and Use Cases

**Definition:**
End-to-End testing verifies the entire application flow from start to finish, ensuring all system components work together in a production-like environment.

**Common Use Cases:**

- User flows
- Critical paths
- Business processes
- Payment flows
- Authentication
- Form submissions
- Navigation
- Visual regression

### Visual Representation:

```
E2E Testing Layers:

UI → Business Logic → API → Database
 ↓         ↓           ↓        ↓
User    Validation   Network   Data
Flow    Rules        Calls     State
```

## Key Concepts

1. **Test Environment:**

   - Browser automation
   - Test isolation
   - Data seeding
   - Network handling

2. **Testing Approaches:**

   - User flow testing
   - Visual testing
   - Network simulation
   - State verification

3. **Testing Tools:**
   - Cypress
   - Playwright
   - TestCafe
   - Percy

## Implementation Examples

### 1. Advanced Cypress Testing

```typescript
// Complex user flow testing
describe('E-commerce Checkout Flow', () => {
  beforeEach(() => {
    // Custom command for authentication
    cy.login('test@example.com', 'password')

    // Seed test data
    cy.seedTestData({
      products: [
        {
          id: '1',
          name: 'Test Product',
          price: 99.99,
        },
      ],
      cart: [],
    })
  })

  it('completes checkout process', () => {
    // Custom command to intercept and wait for API calls
    cy.interceptAPI('GET', '/api/products', {
      fixture: 'products.json',
    })

    // Start at product page
    cy.visit('/products')

    // Add product to cart
    cy.get('[data-testid="product-1"]').should('be.visible').click()

    cy.get('[data-testid="add-to-cart"]').click()

    // Verify cart update
    cy.get('[data-testid="cart-count"]').should('have.text', '1')

    // Proceed to checkout
    cy.get('[data-testid="checkout-button"]').click()

    // Fill shipping form
    cy.fillShippingForm({
      name: 'John Doe',
      address: '123 Test St',
      city: 'Test City',
      zip: '12345',
    })

    // Fill payment form
    cy.fillPaymentForm({
      cardNumber: '4242424242424242',
      expiry: '12/25',
      cvv: '123',
    })

    // Confirm order
    cy.interceptAPI('POST', '/api/orders', {
      statusCode: 200,
      body: { orderId: '12345' },
    })

    cy.get('[data-testid="confirm-order"]').click()

    // Verify success
    cy.url().should('include', '/order-confirmation')

    cy.get('[data-testid="order-id"]').should('contain', '12345')
  })

  // Custom Cypress commands
  Cypress.Commands.add('fillShippingForm', (data) => {
    cy.get('[data-testid="shipping-name"]').type(data.name)
    cy.get('[data-testid="shipping-address"]').type(data.address)
    cy.get('[data-testid="shipping-city"]').type(data.city)
    cy.get('[data-testid="shipping-zip"]').type(data.zip)
  })

  Cypress.Commands.add('interceptAPI', (method, url, response) => {
    cy.intercept(method, url, (req) => {
      req.reply(response)
    }).as('apiCall')
    cy.wait('@apiCall')
  })
})
```

### 2. Visual Regression Testing

```typescript
// Visual regression with Percy
describe('Visual Regression Tests', () => {
  beforeEach(() => {
    // Set viewport sizes for testing
    cy.viewport(1920, 1080)
  })

  it('captures homepage in different states', () => {
    // Default state
    cy.visit('/')
    cy.percySnapshot('Homepage - Default')

    // Logged in state
    cy.login('test@example.com', 'password')
    cy.visit('/')
    cy.percySnapshot('Homepage - Logged In')

    // Mobile menu
    cy.viewport('iphone-x')
    cy.get('[data-testid="mobile-menu"]').click()
    cy.percySnapshot('Homepage - Mobile Menu Open')
  })

  it('captures dynamic content variations', () => {
    cy.visit('/products')

    // Loading state
    cy.interceptAPI('GET', '/api/products', {
      delay: 1000,
      fixture: 'products.json',
    })
    cy.percySnapshot('Products - Loading')

    // Empty state
    cy.interceptAPI('GET', '/api/products', {
      body: [],
    })
    cy.percySnapshot('Products - Empty')

    // Error state
    cy.interceptAPI('GET', '/api/products', {
      statusCode: 500,
      body: { error: 'Server Error' },
    })
    cy.percySnapshot('Products - Error')

    // Success state with data
    cy.interceptAPI('GET', '/api/products', {
      fixture: 'products.json',
    })
    cy.percySnapshot('Products - Loaded')
  })
})
```

### 3. Network Testing

```typescript
// Advanced network testing
describe('Network Resilience Tests', () => {
  it('handles offline mode', () => {
    cy.visit('/')

    // Enable offline mode
    cy.window().then((win) => {
      win.dispatchEvent(new Event('offline'))
    })

    // Verify offline UI
    cy.get('[data-testid="offline-banner"]').should('be.visible')

    // Try operations
    cy.get('[data-testid="save-button"]').click()

    // Verify data queued
    cy.get('[data-testid="pending-operations"]').should('have.length.gt', 0)

    // Enable online mode
    cy.window().then((win) => {
      win.dispatchEvent(new Event('online'))
    })

    // Verify sync
    cy.get('[data-testid="sync-complete"]').should('be.visible')
  })

  it('handles slow network', () => {
    // Simulate slow network
    cy.intercept('**/*', (req) => {
      req.on('response', (res) => {
        res.setDelay(2000)
      })
    })

    cy.visit('/')

    // Verify loading states
    cy.get('[data-testid="loading-skeleton"]').should('be.visible')

    // Verify content loads eventually
    cy.get('[data-testid="content"]').should('be.visible')
  })
})
```

### 4. State Management Testing

```typescript
// Complex state testing
describe('Application State Tests', () => {
  it('maintains state across navigation', () => {
    cy.visit('/')

    // Set up initial state
    cy.window().then((win) => {
      win.localStorage.setItem('theme', 'dark')
      win.localStorage.setItem(
        'preferences',
        JSON.stringify({
          notifications: true,
        }),
      )
    })

    // Perform actions
    cy.get('[data-testid="theme-toggle"]').click()

    // Navigate away
    cy.visit('/settings')

    // Verify state persistence
    cy.window().then((win) => {
      expect(JSON.parse(win.localStorage.getItem('theme'))).to.equal('light')
    })
  })

  it('handles complex state transitions', () => {
    cy.visit('/editor')

    // Create document
    cy.get('[data-testid="new-doc"]').click()

    // Type content
    cy.get('[data-testid="editor"]').type('Test content')

    // Save draft
    cy.get('[data-testid="save-draft"]').click()

    // Verify autosave
    cy.get('[data-testid="save-status"]').should('contain', 'Saved')

    // Close editor
    cy.get('[data-testid="close-editor"]').click()

    // Reopen document
    cy.get('[data-testid="drafts"]').first().click()

    // Verify content restored
    cy.get('[data-testid="editor"]').should('have.value', 'Test content')
  })
})
```

## Best Practices

1. **Test Structure:**

   - Realistic scenarios
   - Proper setup
   - Clean teardown

2. **Reliability:**

   - Retry strategies
   - Timeouts
   - Error handling

3. **Performance:**
   - Parallelization
   - Resource usage
   - Test speed

## Common Challenges

1. **Test Stability:**

   - Flaky tests
   - Race conditions
   - Network issues

2. **Test Maintenance:**

   - Brittle selectors
   - State management
   - Environment issues

3. **Performance:**
   - Slow tests
   - Resource usage
   - CI/CD integration

## Interview Tips and Tricks

1. **Testing Strategy:**

   - Test coverage
   - Tool selection
   - Environment setup

2. **Best Practices:**

   - Reliable tests
   - Performance
   - Maintenance

3. **Problem Solving:**
   - Debugging strategies
   - Error handling
   - Edge cases

## Common Interview Questions

1. How do you ensure E2E test reliability?
2. What strategies do you use for visual testing?
3. How do you handle network conditions in E2E tests?
4. What tools do you prefer for E2E testing and why?
5. How do you manage test data in E2E tests?
6. What approaches do you use for test parallelization?
7. How do you debug failing E2E tests?

Understanding E2E testing is crucial for ensuring application quality. It involves creating reliable tests that verify entire user flows while maintaining good performance and maintainability.
