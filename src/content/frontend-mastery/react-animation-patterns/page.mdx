# Advanced React: Animation Patterns

## Concept and Use Cases

**Definition:**
Advanced animation patterns involve creating smooth, performant, and accessible animations in React while maintaining good architecture and reusability.

**Common Use Cases:**

- Page transitions
- Component mounting/unmounting
- List animations
- Modal animations
- Drag and drop
- Gesture-based interactions
- Loading states
- Data visualization

### Visual Representation:

```
Animation Pattern Layers:

CSS → FLIP → Spring Physics → Gesture
 ↓        ↓          ↓           ↓
Basic   Layout    Interactive   Touch
```

## Key Concepts

1. **Animation Types:**

   - CSS transitions
   - FLIP animations
   - Spring physics
   - Gesture-based

2. **Performance:**

   - GPU acceleration
   - Layout thrashing
   - RAF scheduling

3. **Accessibility:**
   - Reduced motion
   - ARIA attributes
   - Focus management

## Implementation Examples

### 1. Advanced Animation Hook

```typescript
// Custom animation hook with physics
interface AnimationConfig {
    tension?: number;
    friction?: number;
    precision?: number;
}

interface SpringState {
    position: number;
    velocity: number;
}

function useSpringAnimation(
    target: number,
    config: AnimationConfig = {}
) {
    const {
        tension = 170,
        friction = 26,
        precision = 0.01
    } = config;

    const [state, setState] = useState<SpringState>({
        position: target,
        velocity: 0
    });

    const frameRef = useRef<number>();
    const prevTimeRef = useRef<number>();

    const animate = useCallback((time: number) => {
        if (!prevTimeRef.current) {
            prevTimeRef.current = time;
            frameRef.current = requestAnimationFrame(animate);
            return;
        }

        const deltaTime = Math.min(time - prevTimeRef.current, 64) / 1000;
        prevTimeRef.current = time;

        const spring = -(state.position - target) * tension;
        const damper = -state.velocity * friction;
        const acceleration = (spring + damper) / 1;

        const newPosition = state.position + state.velocity * deltaTime;
        const newVelocity = state.velocity + acceleration * deltaTime;

        if (
            Math.abs(newPosition - target) < precision &&
            Math.abs(newVelocity) < precision
        ) {
            setState({ position: target, velocity: 0 });
            return;
        }

        setState({
            position: newPosition,
            velocity: newVelocity
        });

        frameRef.current = requestAnimationFrame(animate);
    }, [state, target, tension, friction, precision]);

    useEffect(() => {
        frameRef.current = requestAnimationFrame(animate);
        return () => {
            if (frameRef.current) {
                cancelAnimationFrame(frameRef.current);
            }
        };
    }, [animate]);

    return state.position;
}

// Usage with animation component
interface AnimatedValueProps {
    value: number;
    render: (value: number) => React.ReactNode;
}

function AnimatedValue({ value, render }: AnimatedValueProps) {
    const animatedValue = useSpringAnimation(value);
    return <>{render(animatedValue)}</>;
}
```

### 2. FLIP Animation System

```typescript
// FLIP animation implementation
interface FLIPConfig {
    duration?: number;
    easing?: string;
    onComplete?: () => void;
}

function useFLIP(
    elementRef: React.RefObject<HTMLElement>,
    config: FLIPConfig = {}
) {
    const {
        duration = 300,
        easing = 'cubic-bezier(0.4, 0, 0.2, 1)',
        onComplete
    } = config;

    const firstRef = useRef<DOMRect>();
    const animationRef = useRef<Animation>();

    const recordFirst = useCallback(() => {
        if (elementRef.current) {
            firstRef.current = elementRef.current.getBoundingClientRect();
        }
    }, [elementRef]);

    const play = useCallback(() => {
        if (!elementRef.current || !firstRef.current) return;

        const last = elementRef.current.getBoundingClientRect();
        const deltaX = firstRef.current.left - last.left;
        const deltaY = firstRef.current.top - last.top;
        const deltaW = firstRef.current.width / last.width;
        const deltaH = firstRef.current.height / last.height;

        if (animationRef.current) {
            animationRef.current.cancel();
        }

        animationRef.current = elementRef.current.animate([
            {
                transform: `translate(${deltaX}px, ${deltaY}px) scale(${deltaW}, ${deltaH})`
            },
            {
                transform: 'none'
            }
        ], {
            duration,
            easing,
            fill: 'both'
        });

        animationRef.current.onfinish = () => {
            onComplete?.();
        };
    }, [elementRef, duration, easing, onComplete]);

    useEffect(() => {
        return () => {
            if (animationRef.current) {
                animationRef.current.cancel();
            }
        };
    }, []);

    return { recordFirst, play };
}

// FLIP list component
interface FLIPListProps<T> {
    items: T[];
    getKey: (item: T) => string;
    renderItem: (item: T) => React.ReactNode;
}

function FLIPList<T>({
    items,
    getKey,
    renderItem
}: FLIPListProps<T>) {
    const listRef = useRef<HTMLDivElement>(null);
    const itemRefs = useRef(new Map<string, HTMLElement>());

    useEffect(() => {
        const elements = Array.from(itemRefs.current.values());
        const animations = elements.map(element => {
            const first = element.getBoundingClientRect();
            return { element, first };
        });

        // Force reflow
        elements.forEach(element => element.getBoundingClientRect());

        animations.forEach(({ element, first }) => {
            const last = element.getBoundingClientRect();
            const deltaX = first.left - last.left;
            const deltaY = first.top - last.top;

            element.animate([
                {
                    transform: `translate(${deltaX}px, ${deltaY}px)`
                },
                {
                    transform: 'none'
                }
            ], {
                duration: 300,
                easing: 'cubic-bezier(0.4, 0, 0.2, 1)'
            });
        });
    }, [items]);

    return (
        <div ref={listRef}>
            {items.map(item => {
                const key = getKey(item);
                return (
                    <div
                        key={key}
                        ref={element => {
                            if (element) {
                                itemRefs.current.set(key, element);
                            } else {
                                itemRefs.current.delete(key);
                            }
                        }}
                    >
                        {renderItem(item)}
                    </div>
                );
            })}
        </div>
    );
}
```

### 3. Gesture-Based Animations

```typescript
// Gesture system with animations
interface GestureState {
    x: number;
    y: number;
    dx: number;
    dy: number;
    velocity: number;
    direction: number;
}

interface GestureConfig {
    threshold?: number;
    velocity?: number;
    direction?: 'horizontal' | 'vertical';
}

function useGesture(
    config: GestureConfig = {}
) {
    const {
        threshold = 10,
        velocity: minVelocity = 0.5,
        direction = 'horizontal'
    } = config;

    const [state, setState] = useState<GestureState>({
        x: 0,
        y: 0,
        dx: 0,
        dy: 0,
        velocity: 0,
        direction: 0
    });

    const timeRef = useRef<number>();
    const positionRef = useRef<{ x: number; y: number }>();

    const handleStart = useCallback((e: React.TouchEvent | React.MouseEvent) => {
        const point = 'touches' in e ? e.touches[0] : e;
        positionRef.current = { x: point.clientX, y: point.clientY };
        timeRef.current = Date.now();
    }, []);

    const handleMove = useCallback((e: React.TouchEvent | React.MouseEvent) => {
        if (!positionRef.current || !timeRef.current) return;

        const point = 'touches' in e ? e.touches[0] : e;
        const deltaTime = Date.now() - timeRef.current;
        const dx = point.clientX - positionRef.current.x;
        const dy = point.clientY - positionRef.current.y;
        const delta = direction === 'horizontal' ? dx : dy;

        if (Math.abs(delta) > threshold) {
            const velocity = Math.abs(delta) / deltaTime;
            setState({
                x: point.clientX,
                y: point.clientY,
                dx,
                dy,
                velocity,
                direction: Math.sign(delta)
            });
        }
    }, [threshold, direction]);

    const handleEnd = useCallback(() => {
        const velocity = state.velocity;
        if (velocity > minVelocity) {
            // Trigger animation based on velocity and direction
        }

        positionRef.current = undefined;
        timeRef.current = undefined;
    }, [state.velocity, minVelocity]);

    return {
        state,
        handlers: {
            onTouchStart: handleStart,
            onTouchMove: handleMove,
            onTouchEnd: handleEnd,
            onMouseDown: handleStart,
            onMouseMove: handleMove,
            onMouseUp: handleEnd
        }
    };
}

// Swipeable component
interface SwipeableProps {
    onSwipe?: (direction: number) => void;
    children: React.ReactNode;
}

function Swipeable({ onSwipe, children }: SwipeableProps) {
    const { state, handlers } = useGesture({
        direction: 'horizontal',
        threshold: 50,
        velocity: 0.5
    });

    useEffect(() => {
        if (Math.abs(state.velocity) > 0.5) {
            onSwipe?.(state.direction);
        }
    }, [state, onSwipe]);

    return (
        <div {...handlers}>
            {children}
        </div>
    );
}
```

## Performance Considerations

1. **RAF and Layout Thrashing:**

   - Use requestAnimationFrame
   - Batch DOM reads/writes
   - Debounce animations

2. **GPU Acceleration:**

   - Use transform/opacity
   - Will-change property
   - Layer promotion

3. **Animation Scheduling:**
   - Priority scheduling
   - Frame dropping
   - Animation queuing

## Accessibility

1. **Reduced Motion:**

   - Respect user preferences
   - Alternative animations
   - Static fallbacks

2. **ARIA Support:**
   - Live regions
   - Status updates
   - Focus management

## Interview Tips and Tricks

1. **Animation Strategy:**

   - Choose appropriate technique
   - Performance considerations
   - Browser support

2. **Best Practices:**

   - Accessibility
   - Performance
   - Code organization

3. **Common Pitfalls:**
   - Layout thrashing
   - Memory leaks
   - Janky animations

## Common Interview Questions

1. How do you implement performant animations?
2. What strategies do you use for complex animations?
3. How do you handle gesture-based animations?
4. What are your approaches to animation accessibility?
5. How do you optimize animation performance?
6. What tools do you use for React animations?
7. How do you test animations?

Understanding animation patterns in React is crucial for creating engaging user experiences while maintaining performance and accessibility.
