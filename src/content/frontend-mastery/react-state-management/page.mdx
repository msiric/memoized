# Advanced React: State Management

## Concept and Use Cases

**Definition:**
State management in React involves organizing, handling, and synchronizing application state across components using various patterns and tools.

**Common Use Cases:**

- Complex application state
- Global state management
- Server state synchronization
- Form state management
- Authentication state
- UI state management
- Data caching
- Real-time updates

### Visual Representation:

```
State Management Hierarchy:

Local State → Component Tree State → Global State → Server State
     ↓               ↓                    ↓              ↓
useState       Context/Reducers        Stores      Query Management
```

## Key Concepts

1. **State Types:**

   - Local state
   - Shared state
   - Server state
   - UI state

2. **State Patterns:**

   - Flux architecture
   - Command pattern
   - Observer pattern
   - Repository pattern

3. **State Updates:**
   - Immutability
   - Batching
   - Selectors
   - Actions

## Implementation Examples

### 1. Advanced Context Patterns

```typescript
// Context with reducer
interface State {
    user: User | null;
    theme: Theme;
    settings: Settings;
}

type Action =
    | { type: 'SET_USER'; payload: User }
    | { type: 'UPDATE_THEME'; payload: Theme }
    | { type: 'UPDATE_SETTINGS'; payload: Partial<Settings> };

const AppStateContext = createContext<{
    state: State;
    dispatch: Dispatch<Action>;
} | null>(null);

// Context provider with reducer
function AppStateProvider({ children }: { children: React.ReactNode }) {
    const [state, dispatch] = useReducer(reducer, initialState);

    return (
        <AppStateContext.Provider value={{ state, dispatch }}>
            {children}
        </AppStateContext.Provider>
    );
}

// Custom hook for using context
function useAppState() {
    const context = useContext(AppStateContext);
    if (!context) {
        throw new Error('useAppState must be used within AppStateProvider');
    }
    return context;
}

// Selector pattern with context
function useAppSelector<Selected>(
    selector: (state: State) => Selected,
    equalityFn: (a: Selected, b: Selected) => boolean = Object.is
): Selected {
    const { state } = useAppState();
    const [selected, setSelected] = useState(() => selector(state));

    useEffect(() => {
        const newSelected = selector(state);
        if (!equalityFn(selected, newSelected)) {
            setSelected(newSelected);
        }
    }, [state, selector, equalityFn]);

    return selected;
}
```

### 2. Custom Store Implementation

```typescript
// Simple store implementation
class Store<T> {
    private subscribers: Set<(state: T) => void> = new Set();
    private state: T;

    constructor(initialState: T) {
        this.state = initialState;
    }

    getState(): T {
        return this.state;
    }

    setState(nextState: T | ((prev: T) => T)): void {
        const newState = typeof nextState === 'function'
            ? (nextState as (prev: T) => T)(this.state)
            : nextState;

        this.state = newState;
        this.notify();
    }

    subscribe(callback: (state: T) => void): () => void {
        this.subscribers.add(callback);
        return () => this.subscribers.delete(callback);
    }

    private notify(): void {
        this.subscribers.forEach(callback => callback(this.state));
    }
}

// React hook for store
function useStore<T, Selected>(
    store: Store<T>,
    selector: (state: T) => Selected
): Selected {
    const [selected, setSelected] = useState(() =>
        selector(store.getState())
    );

    useEffect(() => {
        return store.subscribe((state) => {
            setSelected(selector(state));
        });
    }, [store, selector]);

    return selected;
}

// Usage
const appStore = new Store({
    count: 0,
    todos: [] as Todo[]
});

function Counter() {
    const count = useStore(appStore, state => state.count);

    return (
        <button onClick={() => appStore.setState(state => ({
            ...state,
            count: state.count + 1
        }))}>
            Count: {count}
        </button>
    );
}
```

### 3. Server State Management

```typescript
// Custom server state hook
function useServerState<T>(
    key: string,
    fetcher: () => Promise<T>,
    options?: {
        initialData?: T;
        revalidateOnFocus?: boolean;
        revalidateOnReconnect?: boolean;
    }
) {
    const [data, setData] = useState<T | undefined>(options?.initialData);
    const [error, setError] = useState<Error>();
    const [isLoading, setIsLoading] = useState(!options?.initialData);

    const fetch = useCallback(async () => {
        setIsLoading(true);
        try {
            const result = await fetcher();
            setData(result);
            setError(undefined);
        } catch (e) {
            setError(e as Error);
        } finally {
            setIsLoading(false);
        }
    }, [fetcher]);

    useEffect(() => {
        fetch();

        if (options?.revalidateOnFocus) {
            window.addEventListener('focus', fetch);
        }

        if (options?.revalidateOnReconnect) {
            window.addEventListener('online', fetch);
        }

        return () => {
            if (options?.revalidateOnFocus) {
                window.removeEventListener('focus', fetch);
            }
            if (options?.revalidateOnReconnect) {
                window.removeEventListener('online', fetch);
            }
        };
    }, [fetch, options?.revalidateOnFocus, options?.revalidateOnReconnect]);

    return { data, error, isLoading, refetch: fetch };
}

// Usage with cache
const cache = new Map<string, any>();

function UserProfile({ userId }: { userId: string }) {
    const { data, isLoading } = useServerState(
        `user-${userId}`,
        async () => {
            if (cache.has(userId)) {
                return cache.get(userId);
            }
            const response = await fetch(`/api/users/${userId}`);
            const data = await response.json();
            cache.set(userId, data);
            return data;
        },
        {
            revalidateOnFocus: true,
            revalidateOnReconnect: true
        }
    );

    if (isLoading) return <Loading />;
    return <div>{data?.name}</div>;
}
```

### 4. Form State Management

```typescript
// Form state manager
interface FormState<T> {
    values: T;
    errors: Partial<Record<keyof T, string>>;
    touched: Partial<Record<keyof T, boolean>>;
    isSubmitting: boolean;
}

function useForm<T extends Record<string, any>>(
    initialValues: T,
    validate?: (values: T) => Partial<Record<keyof T, string>>,
    onSubmit?: (values: T) => Promise<void>
) {
    const [state, setState] = useState<FormState<T>>({
        values: initialValues,
        errors: {},
        touched: {},
        isSubmitting: false
    });

    const setFieldValue = useCallback((
        field: keyof T,
        value: T[keyof T]
    ) => {
        setState(prev => ({
            ...prev,
            values: {
                ...prev.values,
                [field]: value
            },
            touched: {
                ...prev.touched,
                [field]: true
            }
        }));
    }, []);

    const handleSubmit = useCallback(async (
        e: React.FormEvent
    ) => {
        e.preventDefault();
        setState(prev => ({ ...prev, isSubmitting: true }));

        if (validate) {
            const errors = validate(state.values);
            setState(prev => ({ ...prev, errors }));

            if (Object.keys(errors).length > 0) {
                setState(prev => ({ ...prev, isSubmitting: false }));
                return;
            }
        }

        try {
            await onSubmit?.(state.values);
        } finally {
            setState(prev => ({ ...prev, isSubmitting: false }));
        }
    }, [state.values, validate, onSubmit]);

    return {
        ...state,
        setFieldValue,
        handleSubmit
    };
}

// Usage
function RegistrationForm() {
    const form = useForm(
        {
            email: '',
            password: ''
        },
        values => {
            const errors: Record<string, string> = {};
            if (!values.email.includes('@')) {
                errors.email = 'Invalid email';
            }
            if (values.password.length < 6) {
                errors.password = 'Password too short';
            }
            return errors;
        },
        async values => {
            await api.register(values);
        }
    );

    return (
        <form onSubmit={form.handleSubmit}>
            <input
                value={form.values.email}
                onChange={e => form.setFieldValue('email', e.target.value)}
            />
            {form.errors.email && (
                <span>{form.errors.email}</span>
            )}
            {/* Similar for password */}
            <button disabled={form.isSubmitting}>
                Register
            </button>
        </form>
    );
}
```

## Interview Tips and Tricks

1. **State Architecture:**

   - Choosing the right state management solution
   - State organization patterns
   - Performance considerations

2. **Best Practices:**

   - State immutability
   - State normalization
   - Error handling

3. **Common Pitfalls:**
   - Over-centralization
   - Prop drilling
   - State duplication

## Common Interview Questions

1. How do you decide between local and global state?
2. What are the trade-offs of different state management solutions?
3. How do you handle complex form state?
4. What patterns do you use for server state management?
5. How do you optimize state updates for performance?
6. How do you handle state synchronization?
7. What are best practices for managing side effects in state updates?

Understanding state management patterns is crucial for building scalable React applications. It involves choosing the right tools and patterns for different types of state while maintaining performance and maintainability.
