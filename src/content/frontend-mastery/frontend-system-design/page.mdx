# Advanced React: Frontend System Design

## Concept and Use Cases

**Definition:**
Frontend system design involves architecting scalable, maintainable, and performant web applications while considering various technical and business requirements.

**Common Use Cases:**

- Large-scale applications
- Real-time systems
- Collaborative platforms
- E-commerce sites
- Social networks
- Content management systems
- Data visualization dashboards
- Enterprise applications

### Visual Representation:

```
Frontend Architecture Layers:

UI Layer → Business Logic → Data Layer → API Layer
   ↓            ↓              ↓            ↓
Components   Services      State/Cache    Clients
```

## Key Concepts

1. **Architecture Patterns:**

   - Component architecture
   - State management
   - Data flow
   - Code organization

2. **System Requirements:**

   - Scalability
   - Performance
   - Maintainability
   - Security

3. **Technical Decisions:**
   - Framework selection
   - Build tooling
   - Testing strategy
   - Deployment approach

## System Design Examples

### 1. Real-Time Chat Application

```typescript
// WebSocket service
class WebSocketService {
    private socket: WebSocket;
    private messageHandlers: Map<string, (data: any) => void>;

    constructor(url: string) {
        this.socket = new WebSocket(url);
        this.messageHandlers = new Map();

        this.socket.onmessage = (event) => {
            const { type, payload } = JSON.parse(event.data);
            this.messageHandlers.get(type)?.(payload);
        };
    }

    subscribe(type: string, handler: (data: any) => void) {
        this.messageHandlers.set(type, handler);
        return () => this.messageHandlers.delete(type);
    }

    send(type: string, payload: any) {
        this.socket.send(JSON.stringify({ type, payload }));
    }
}

// Message store
class MessageStore {
    private messages: Map<string, Message[]>;
    private listeners: Set<() => void>;

    constructor() {
        this.messages = new Map();
        this.listeners = new Set();
    }

    addMessage(channelId: string, message: Message) {
        if (!this.messages.has(channelId)) {
            this.messages.set(channelId, []);
        }
        this.messages.get(channelId)!.push(message);
        this.notify();
    }

    getMessages(channelId: string): Message[] {
        return this.messages.get(channelId) || [];
    }

    subscribe(listener: () => void) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }

    private notify() {
        this.listeners.forEach(listener => listener());
    }
}

// Chat component
function ChatApp() {
    const [currentChannel, setCurrentChannel] = useState<string>('general');
    const messageStore = useMemo(() => new MessageStore(), []);
    const socketService = useMemo(
        () => new WebSocketService('wss://chat.example.com'),
        []
    );

    useEffect(() => {
        const unsubscribe = socketService.subscribe('message', (message) => {
            messageStore.addMessage(message.channelId, message);
        });

        return unsubscribe;
    }, [messageStore, socketService]);

    const sendMessage = useCallback((content: string) => {
        socketService.send('message', {
            channelId: currentChannel,
            content,
            timestamp: Date.now()
        });
    }, [currentChannel, socketService]);

    return (
        <div className="chat-app">
            <ChannelList
                onSelect={setCurrentChannel}
                current={currentChannel}
            />
            <MessageList
                messages={messageStore.getMessages(currentChannel)}
            />
            <MessageInput onSend={sendMessage} />
        </div>
    );
}
```

### 2. E-commerce Shopping Cart

```typescript
// Cart state management
interface CartItem {
    id: string;
    quantity: number;
    price: number;
}

class CartService {
    private storage: Storage;
    private items: Map<string, CartItem>;
    private listeners: Set<() => void>;

    constructor(storage: Storage = localStorage) {
        this.storage = storage;
        this.items = new Map();
        this.listeners = new Set();
        this.loadFromStorage();
    }

    private loadFromStorage() {
        const stored = this.storage.getItem('cart');
        if (stored) {
            const items = JSON.parse(stored);
            Object.entries(items).forEach(([id, item]) => {
                this.items.set(id, item as CartItem);
            });
        }
    }

    private saveToStorage() {
        const items = Object.fromEntries(this.items.entries());
        this.storage.setItem('cart', JSON.stringify(items));
    }

    addItem(id: string, item: Omit<CartItem, 'id'>) {
        const existing = this.items.get(id);
        if (existing) {
            this.items.set(id, {
                ...existing,
                quantity: existing.quantity + item.quantity
            });
        } else {
            this.items.set(id, { id, ...item });
        }
        this.saveToStorage();
        this.notify();
    }

    removeItem(id: string) {
        this.items.delete(id);
        this.saveToStorage();
        this.notify();
    }

    updateQuantity(id: string, quantity: number) {
        const item = this.items.get(id);
        if (item) {
            this.items.set(id, { ...item, quantity });
            this.saveToStorage();
            this.notify();
        }
    }

    getItems(): CartItem[] {
        return Array.from(this.items.values());
    }

    getTotalPrice(): number {
        return Array.from(this.items.values()).reduce(
            (total, item) => total + item.price * item.quantity,
            0
        );
    }

    subscribe(listener: () => void) {
        this.listeners.add(listener);
        return () => this.listeners.delete(listener);
    }

    private notify() {
        this.listeners.forEach(listener => listener());
    }
}

// Shopping cart component
function ShoppingCart() {
    const cartService = useMemo(() => new CartService(), []);
    const [items, setItems] = useState<CartItem[]>([]);

    useEffect(() => {
        setItems(cartService.getItems());
        return cartService.subscribe(() => {
            setItems(cartService.getItems());
        });
    }, [cartService]);

    return (
        <div className="shopping-cart">
            <CartItems
                items={items}
                onUpdateQuantity={(id, quantity) =>
                    cartService.updateQuantity(id, quantity)
                }
                onRemove={id => cartService.removeItem(id)}
            />
            <CartSummary total={cartService.getTotalPrice()} />
            <CheckoutButton
                disabled={items.length === 0}
                onClick={() => {/* Checkout logic */}}
            />
        </div>
    );
}
```

### 3. Data Visualization Dashboard

```typescript
// Data fetching and caching
class DataService {
    private cache: Map<string, {
        data: any;
        timestamp: number;
    }>;
    private fetchPromises: Map<string, Promise<any>>;
    private maxAge: number;

    constructor(maxAge: number = 5 * 60 * 1000) {
        this.cache = new Map();
        this.fetchPromises = new Map();
        this.maxAge = maxAge;
    }

    async fetch<T>(
        key: string,
        fetcher: () => Promise<T>
    ): Promise<T> {
        const cached = this.cache.get(key);
        if (cached && Date.now() - cached.timestamp < this.maxAge) {
            return cached.data;
        }

        if (this.fetchPromises.has(key)) {
            return this.fetchPromises.get(key)!;
        }

        const promise = fetcher().then(data => {
            this.cache.set(key, {
                data,
                timestamp: Date.now()
            });
            this.fetchPromises.delete(key);
            return data;
        });

        this.fetchPromises.set(key, promise);
        return promise;
    }

    invalidate(key: string) {
        this.cache.delete(key);
    }
}

// Dashboard component
function Dashboard() {
    const dataService = useMemo(() => new DataService(), []);
    const [metrics, setMetrics] = useState<Metrics[]>([]);
    const [timeRange, setTimeRange] = useState('1d');

    useEffect(() => {
        const fetchData = async () => {
            const data = await dataService.fetch(
                `metrics-${timeRange}`,
                () => api.fetchMetrics(timeRange)
            );
            setMetrics(data);
        };

        fetchData();
        const interval = setInterval(fetchData, 60000);

        return () => clearInterval(interval);
    }, [dataService, timeRange]);

    return (
        <div className="dashboard">
            <TimeRangeSelector
                value={timeRange}
                onChange={setTimeRange}
            />
            <MetricsGrid metrics={metrics} />
            <ChartArea
                data={metrics}
                timeRange={timeRange}
            />
        </div>
    );
}
```

## System Design Considerations

### 1. Performance Optimization

```typescript
// Code splitting
const DashboardPage = lazy(() => import('./pages/Dashboard'));
const SettingsPage = lazy(() => import('./pages/Settings'));

// Route-based chunking
function App() {
    return (
        <Suspense fallback={<Loading />}>
            <Routes>
                <Route path="/" element={<DashboardPage />} />
                <Route path="/settings" element={<SettingsPage />} />
            </Routes>
        </Suspense>
    );
}

// Performance monitoring
class PerformanceMonitor {
    private metrics: Map<string, number[]>;

    logMetric(name: string, value: number) {
        if (!this.metrics.has(name)) {
            this.metrics.set(name, []);
        }
        this.metrics.get(name)!.push(value);
    }

    getAverageMetric(name: string): number {
        const values = this.metrics.get(name) || [];
        return values.reduce((a, b) => a + b, 0) / values.length;
    }
}
```

### 2. Error Handling

```typescript
// Global error boundary
class ErrorBoundary extends React.Component<
  { fallback: React.ReactNode },
  { hasError: boolean }
> {
  state = { hasError: false }

  static getDerivedStateFromError() {
    return { hasError: true }
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    // Log error to monitoring service
    logError(error, info)
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback
    }

    return this.props.children
  }
}
```

### 3. Security Considerations

```typescript
// CSRF protection
const api = axios.create({
  baseURL: '/api',
  headers: {
    'X-CSRF-Token': getCsrfToken(),
  },
})

// XSS prevention
function sanitizeHtml(html: string): string {
  const element = document.createElement('div')
  element.textContent = html
  return element.innerHTML
}

// Content security policy
const CSP = {
  'default-src': ["'self'"],
  'script-src': ["'self'"],
  'style-src': ["'self'", "'unsafe-inline'"],
  'img-src': ["'self'", 'data:', 'https:'],
  'connect-src': ["'self'", 'https://api.example.com'],
}
```

## Interview Tips and Tricks

1. **System Design Process:**

   - Requirements gathering
   - Architecture planning
   - Technical decisions
   - Implementation strategy

2. **Performance Considerations:**

   - Loading strategies
   - Caching approaches
   - Bundle optimization

3. **Scalability Concerns:**
   - Code organization
   - State management
   - Data flow

## Common Interview Questions

1. How would you design a real-time collaborative editor?
2. What considerations go into designing a large-scale React application?
3. How do you handle performance optimization in a complex application?
4. What are the key security concerns in frontend development?
5. How do you manage state in a large application?
6. What strategies do you use for error handling?
7. How do you ensure code maintainability in a large team?

Understanding frontend system design is crucial for building large-scale applications. It involves considering various aspects including architecture, performance, security, and maintainability.
