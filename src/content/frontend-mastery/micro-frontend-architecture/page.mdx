# Advanced Frontend: Micro-Frontend Architecture

## Concept and Use Cases

**Definition:**
Micro-frontend architecture extends microservices principles to frontend applications, allowing multiple teams to work independently on different parts of an application using different technologies.

**Common Use Cases:**

- Large-scale applications
- Team autonomy
- Legacy system migration
- Gradual modernization
- Independent deployments
- Technology flexibility
- Feature isolation
- Multi-team development

### Visual Representation:

```
Micro-Frontend Architecture:

Container App (Shell)
       ↓
  Runtime Integration
       ↓
MFE1   MFE2   MFE3   MFE4
 ↓      ↓      ↓      ↓
Team1  Team2  Team3  Team4
```

## Key Concepts

1. **Integration Patterns:**

   - Runtime integration
   - Build-time integration
   - Server-side composition

2. **Communication:**

   - Cross-application messaging
   - State sharing
   - Event handling

3. **Deployment:**
   - Independent deployment
   - Versioning
   - Configuration management

## Implementation Examples

### 1. Module Federation Setup

```typescript
// webpack.config.ts
import { container } from 'webpack'
const ModuleFederationPlugin = container.ModuleFederationPlugin

interface MicroFrontendConfig {
  name: string
  filename: string
  exposes: Record<string, string>
  remotes?: Record<string, string>
  shared?: string[]
}

function createMicroFrontendConfig(config: MicroFrontendConfig) {
  return {
    plugins: [
      new ModuleFederationPlugin({
        name: config.name,
        filename: config.filename,
        exposes: config.exposes,
        remotes: config.remotes,
        shared: {
          react: { singleton: true },
          'react-dom': { singleton: true },
          ...config.shared?.reduce(
            (acc, pkg) => ({
              ...acc,
              [pkg]: { singleton: true },
            }),
            {},
          ),
        },
      }),
    ],
  }
}

// Host application config
export default createMicroFrontendConfig({
  name: 'host',
  filename: 'remoteEntry.js',
  exposes: {},
  remotes: {
    mfe1: 'mfe1@http://localhost:3001/remoteEntry.js',
    mfe2: 'mfe2@http://localhost:3002/remoteEntry.js',
  },
  shared: ['react', 'react-dom', '@material-ui/core'],
})

// Micro-frontend config
export default createMicroFrontendConfig({
  name: 'mfe1',
  filename: 'remoteEntry.js',
  exposes: {
    './App': './src/App',
    './Button': './src/components/Button',
  },
  shared: ['react', 'react-dom', '@material-ui/core'],
})
```

### 2. Application Shell Implementation

```typescript
// Application shell with micro-frontend loading
interface MicroFrontendProps {
    name: string;
    url: string;
    scope: string;
    module: string;
}

const MicroFrontend: React.FC<MicroFrontendProps> = ({
    name,
    url,
    scope,
    module
}) => {
    const [error, setError] = useState<Error>();
    const divRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (!divRef.current) return;

        const loadComponent = async () => {
            try {
                // Load the remote entry
                await loadRemoteEntry(url);

                // Initialize the container
                const container = window[scope];
                await container.init(__webpack_share_scopes__.default);

                // Get the component
                const factory = await container.get(module);
                const Component = factory();

                // Mount the component
                ReactDOM.render(
                    <ErrorBoundary onError={setError}>
                        <Component />
                    </ErrorBoundary>,
                    divRef.current
                );
            } catch (err) {
                setError(err as Error);
            }
        };

        loadComponent();

        return () => {
            if (divRef.current) {
                ReactDOM.unmountComponentAtNode(divRef.current);
            }
        };
    }, [url, scope, module]);

    if (error) {
        return (
            <div className="error-container">
                Failed to load micro-frontend: {error.message}
            </div>
        );
    }

    return <div ref={divRef} id={`mfe-${name}`} />;
};

// Shell application
function App() {
    return (
        <div className="shell-container">
            <Header />
            <Router>
                <Switch>
                    <Route path="/mfe1">
                        <MicroFrontend
                            name="mfe1"
                            url="http://localhost:3001/remoteEntry.js"
                            scope="mfe1"
                            module="./App"
                        />
                    </Route>
                    <Route path="/mfe2">
                        <MicroFrontend
                            name="mfe2"
                            url="http://localhost:3002/remoteEntry.js"
                            scope="mfe2"
                            module="./App"
                        />
                    </Route>
                </Switch>
            </Router>
        </div>
    );
}
```

### 3. Communication Layer

```typescript
// Event bus for micro-frontend communication
type EventCallback = (...args: any[]) => void;

class EventBus {
    private events: Map<string, Set<EventCallback>>;

    constructor() {
        this.events = new Map();
    }

    subscribe(event: string, callback: EventCallback): () => void {
        if (!this.events.has(event)) {
            this.events.set(event, new Set());
        }

        this.events.get(event)!.add(callback);

        return () => {
            const callbacks = this.events.get(event);
            if (callbacks) {
                callbacks.delete(callback);
                if (callbacks.size === 0) {
                    this.events.delete(event);
                }
            }
        };
    }

    publish(event: string, ...args: any[]): void {
        const callbacks = this.events.get(event);
        if (callbacks) {
            callbacks.forEach(callback => callback(...args));
        }
    }
}

// Global event bus instance
declare global {
    interface Window {
        eventBus: EventBus;
    }
}

window.eventBus = new EventBus();

// Usage in micro-frontends
function MicroFrontendComponent() {
    useEffect(() => {
        const unsubscribe = window.eventBus.subscribe(
            'shared-event',
            (data) => {
                console.log('Received shared event:', data);
            }
        );

        return unsubscribe;
    }, []);

    const handleAction = () => {
        window.eventBus.publish('shared-event', {
            action: 'user-action',
            timestamp: Date.now()
        });
    };

    return (
        <button onClick={handleAction}>
            Trigger Shared Event
        </button>
    );
}
```

### 4. Shared State Management

```typescript
// Shared state container
interface SharedState {
  user?: User
  theme: 'light' | 'dark'
  language: string
}

class SharedStateContainer {
  private state: SharedState
  private subscribers: Set<(state: SharedState) => void>

  constructor(initialState: SharedState) {
    this.state = initialState
    this.subscribers = new Set()
  }

  getState(): SharedState {
    return this.state
  }

  setState(
    updater:
      | Partial<SharedState>
      | ((state: SharedState) => Partial<SharedState>),
  ): void {
    const update = typeof updater === 'function' ? updater(this.state) : updater

    this.state = { ...this.state, ...update }
    this.notify()
  }

  subscribe(callback: (state: SharedState) => void): () => void {
    this.subscribers.add(callback)
    return () => this.subscribers.delete(callback)
  }

  private notify(): void {
    this.subscribers.forEach((callback) => callback(this.state))
  }
}

// Hook for accessing shared state
function useSharedState<T>(
  selector: (state: SharedState) => T,
): [T, (update: Partial<SharedState>) => void] {
  const [selectedState, setSelectedState] = useState<T>(() =>
    selector(window.sharedState.getState()),
  )

  useEffect(() => {
    return window.sharedState.subscribe((state) => {
      setSelectedState(selector(state))
    })
  }, [selector])

  const setState = useCallback((update: Partial<SharedState>) => {
    window.sharedState.setState(update)
  }, [])

  return [selectedState, setState]
}
```

## Best Practices

1. **Application Design:**

   - Clear boundaries
   - Independent deployment
   - Shared dependencies management

2. **Performance:**

   - Module federation optimization
   - Resource loading strategies
   - Caching approaches

3. **Development Experience:**
   - Local development setup
   - Testing strategy
   - CI/CD pipelines

## Common Challenges

1. **Routing:**

   - Nested routing
   - History management
   - Deep linking

2. **Shared State:**

   - State synchronization
   - Consistency
   - Performance

3. **Styling:**
   - Style isolation
   - Theme consistency
   - CSS conflicts

## Interview Tips and Tricks

1. **Architecture Decisions:**

   - Integration patterns
   - State management
   - Deployment strategy

2. **Best Practices:**

   - Team organization
   - Code sharing
   - Testing approaches

3. **Common Pitfalls:**
   - Over-fragmentation
   - Dependency conflicts
   - Performance issues

## Common Interview Questions

1. How do you handle shared dependencies in micro-frontends?
2. What strategies do you use for cross-micro-frontend communication?
3. How do you manage routing in a micro-frontend architecture?
4. What are the trade-offs of different integration patterns?
5. How do you handle state management across micro-frontends?
6. What deployment strategies do you use for micro-frontends?
7. How do you ensure consistent user experience across micro-frontends?

Understanding micro-frontend architecture is crucial for building scalable frontend applications. It involves making informed decisions about integration patterns, state management, and team organization while maintaining good performance and user experience.
