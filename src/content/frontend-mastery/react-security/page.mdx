# Advanced React: Security

## Concept and Use Cases

**Definition:**
React security involves protecting applications from various vulnerabilities and implementing best practices to ensure data safety and user privacy.

**Common Use Cases:**

- XSS prevention
- CSRF protection
- Authentication
- Authorization
- Data validation
- API security
- Sensitive data handling
- State management security

### Visual Representation:

```
Security Layers:

Frontend Security → API Security → Data Security
       ↓               ↓              ↓
Input Validation   Auth Tokens     Encryption
       ↓               ↓              ↓
  XSS Prevention    CSRF        Data Sanitization
```

## Key Concepts

1. **Attack Vectors:**

   - Cross-site scripting (XSS)
   - Cross-site request forgery (CSRF)
   - Man-in-the-middle attacks
   - Data exposure

2. **Protection Mechanisms:**

   - Input sanitization
   - Output encoding
   - Authentication
   - Authorization

3. **Security Patterns:**
   - Token management
   - Secure data handling
   - Access control

## Implementation Examples

### 1. XSS Prevention

```typescript
// Safe HTML rendering
function SafeHTML({ html }: { html: string }) {
    // DOMPurify sanitization
    const sanitizedHtml = useMemo(() => {
        return DOMPurify.sanitize(html, {
            USE_PROFILES: { html: true },
            ALLOWED_TAGS: ['p', 'b', 'i', 'em', 'strong', 'a'],
            ALLOWED_ATTR: ['href']
        });
    }, [html]);

    return (
        <div dangerouslySetInnerHTML={{ __html: sanitizedHtml }} />
    );
}

// URL sanitization
function SafeURL({ url }: { url: string }) {
    const isSafeURL = useMemo(() => {
        try {
            const parsed = new URL(url);
            return ['http:', 'https:'].includes(parsed.protocol);
        } catch {
            return false;
        }
    }, [url]);

    if (!isSafeURL) return null;

    return <a href={url}>Safe Link</a>;
}

// Input validation
function SafeInput({ onChange }: { onChange: (value: string) => void }) {
    const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        const sanitizedValue = e.target.value.replace(/<[^>]*>?/gm, '');
        onChange(sanitizedValue);
    }, [onChange]);

    return <input onChange={handleChange} />;
}
```

### 2. Authentication and Authorization

```typescript
// Authentication context
interface AuthState {
    user: User | null;
    token: string | null;
    isAuthenticated: boolean;
}

const AuthContext = createContext<{
    state: AuthState;
    login: (credentials: Credentials) => Promise<void>;
    logout: () => void;
} | null>(null);

// Authentication provider
function AuthProvider({ children }: { children: React.ReactNode }) {
    const [state, setState] = useState<AuthState>({
        user: null,
        token: localStorage.getItem('auth_token'),
        isAuthenticated: false
    });

    const login = useCallback(async (credentials: Credentials) => {
        try {
            const response = await api.login(credentials);
            const { user, token } = response.data;

            // Securely store token
            localStorage.setItem('auth_token', token);

            // Update auth state
            setState({
                user,
                token,
                isAuthenticated: true
            });

            // Configure API client
            api.setAuthHeader(token);
        } catch (error) {
            throw new Error('Authentication failed');
        }
    }, []);

    const logout = useCallback(() => {
        localStorage.removeItem('auth_token');
        setState({
            user: null,
            token: null,
            isAuthenticated: false
        });
        api.removeAuthHeader();
    }, []);

    return (
        <AuthContext.Provider value={{ state, login, logout }}>
            {children}
        </AuthContext.Provider>
    );
}

// Protected route component
function ProtectedRoute({
    children,
    requiredRoles = []
}: {
    children: React.ReactNode;
    requiredRoles?: string[];
}) {
    const auth = useAuth();
    const location = useLocation();

    if (!auth.state.isAuthenticated) {
        return <Navigate to="/login" state={{ from: location }} replace />;
    }

    if (requiredRoles.length > 0 &&
        !requiredRoles.some(role => auth.state.user?.roles.includes(role))) {
        return <Navigate to="/unauthorized" replace />;
    }

    return <>{children}</>;
}
```

### 3. CSRF Protection

```typescript
// CSRF token management
class CSRFManager {
    private token: string | null = null;

    setToken(token: string) {
        this.token = token;
    }

    getToken(): string | null {
        return this.token;
    }

    async refreshToken(): Promise<void> {
        try {
            const response = await fetch('/api/csrf-token', {
                credentials: 'include'
            });
            const { token } = await response.json();
            this.setToken(token);
        } catch (error) {
            console.error('Failed to refresh CSRF token:', error);
        }
    }
}

// API client with CSRF protection
const api = axios.create({
    baseURL: '/api',
    withCredentials: true
});

api.interceptors.request.use(config => {
    const token = csrfManager.getToken();
    if (token) {
        config.headers['X-CSRF-Token'] = token;
    }
    return config;
});

// Form with CSRF protection
function SecureForm() {
    const [csrfToken, setCsrfToken] = useState<string | null>(null);

    useEffect(() => {
        csrfManager.refreshToken().then(() => {
            setCsrfToken(csrfManager.getToken());
        });
    }, []);

    return (
        <form>
            <input type="hidden" name="_csrf" value={csrfToken || ''} />
            {/* Form fields */}
        </form>
    );
}
```

### 4. Secure Data Handling

```typescript
// Sensitive data masking
function SensitiveData({ data }: { data: string }) {
    const mask = useCallback((value: string) => {
        return value.replace(/\d(?=\d{4})/g, '*');
    }, []);

    return <div>{mask(data)}</div>;
}

// Secure storage wrapper
class SecureStorage {
    private storage: Storage;
    private prefix: string;

    constructor(storage: Storage = localStorage, prefix: string = 'secure_') {
        this.storage = storage;
        this.prefix = prefix;
    }

    setItem(key: string, value: any): void {
        const secureValue = encrypt(JSON.stringify(value));
        this.storage.setItem(this.prefix + key, secureValue);
    }

    getItem<T>(key: string): T | null {
        const value = this.storage.getItem(this.prefix + key);
        if (!value) return null;

        try {
            const decrypted = decrypt(value);
            return JSON.parse(decrypted);
        } catch {
            return null;
        }
    }

    removeItem(key: string): void {
        this.storage.removeItem(this.prefix + key);
    }
}

// Secure data component
function SecureDataDisplay({
    data,
    isAuthorized
}: {
    data: SensitiveData;
    isAuthorized: boolean;
}) {
    if (!isAuthorized) {
        return <div>Unauthorized access</div>;
    }

    return (
        <div className="secure-container">
            {Object.entries(data).map(([key, value]) => (
                <div key={key}>
                    <strong>{key}:</strong>
                    {shouldMask(key) ? (
                        <SensitiveData data={value} />
                    ) : (
                        <span>{value}</span>
                    )}
                </div>
            ))}
        </div>
    );
}
```

### 5. Content Security Policy

```typescript
// CSP configuration
function setupCSP() {
    const cspConfig = {
        'default-src': ["'self'"],
        'script-src': ["'self'", "'unsafe-inline'"],
        'style-src': ["'self'", "'unsafe-inline'"],
        'img-src': ["'self'", 'data:', 'https:'],
        'connect-src': ["'self'", 'https://api.example.com'],
        'frame-ancestors': ["'none'"],
        'form-action': ["'self'"]
    };

    const cspString = Object.entries(cspConfig)
        .map(([key, values]) => `${key} ${values.join(' ')}`)
        .join('; ');

    return cspString;
}

// Meta tags for security
function SecurityMetaTags() {
    return (
        <head>
            <meta
                httpEquiv="Content-Security-Policy"
                content={setupCSP()}
            />
            <meta
                httpEquiv="X-Frame-Options"
                content="DENY"
            />
            <meta
                httpEquiv="X-XSS-Protection"
                content="1; mode=block"
            />
            <meta
                httpEquiv="X-Content-Type-Options"
                content="nosniff"
            />
        </head>
    );
}
```

## Security Best Practices

1. **Input Validation:**

   - Always validate and sanitize user input
   - Use type checking and validation libraries
   - Implement proper error handling

2. **Authentication:**

   - Implement secure token management
   - Use proper password hashing
   - Implement session management

3. **Data Protection:**
   - Encrypt sensitive data
   - Implement proper access control
   - Use secure communication channels

## Interview Tips and Tricks

1. **Security Assessment:**

   - Understanding security vulnerabilities
   - Identifying security risks
   - Implementing security measures

2. **Best Practices:**

   - Authentication patterns
   - Authorization strategies
   - Data protection methods

3. **Common Pitfalls:**
   - Insecure data storage
   - Improper authentication
   - XSS vulnerabilities

## Common Interview Questions

1. How do you prevent XSS attacks in React?
2. What are best practices for handling authentication?
3. How do you implement CSRF protection?
4. What security measures do you take for storing sensitive data?
5. How do you handle secure communication with APIs?
6. What are common security vulnerabilities in React applications?
7. How do you implement role-based access control?

Understanding security in React is crucial for building secure applications. It involves implementing proper security measures at various levels and following security best practices throughout the development process.
