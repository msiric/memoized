# Advanced TypeScript: Type System Deep Dive

## Concept and Use Cases

**Definition:**
Advanced TypeScript types provide powerful tools for creating precise, reusable, and maintainable type definitions that can model complex data structures and behaviors.

**Common Use Cases:**

- Complex object type validation
- API response typing
- State management typing
- Form handling
- Generic library development
- Type-safe utilities

### Visual Representation:

```
Type Hierarchy:
any
 ↑
unknown
 ↑
union types (A | B)
 ↑
intersection types (A & B)
 ↑
concrete types (string, number, etc.)
 ↑
never
```

## Key Concepts

1. **Conditional Types:**

   - Type inference based on conditions
   - Distributive properties
   - Inference with infer keyword

2. **Mapped Types:**

   - Transforming type properties
   - Key remapping
   - Property modifiers

3. **Template Literal Types:**
   - String manipulation at type level
   - Pattern matching
   - Type inference from strings

## Advanced Type Operations

### 1. Conditional Types

**Example:**

```typescript
// Basic conditional type
type IsString<T> = T extends string ? true : false

// Type inference with infer
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T

// Distributive conditional types
type ToArray<T> = T extends any ? T[] : never
type StringOrNumberArray = ToArray<string | number> // string[] | number[]

// Real-world example: Extract function return type
type GetReturnType<T extends (...args: any[]) => any> = T extends (
  ...args: any[]
) => infer R
  ? R
  : never

// Usage examples
type StringCheck = IsString<'hello'> // true
type StringCheck2 = IsString<42> // false

type Unwrapped = UnwrapPromise<Promise<string>> // string
type NotPromise = UnwrapPromise<number> // number

// Function return type example
function getData() {
  return { id: 1, name: 'Test' }
}
type DataType = GetReturnType<typeof getData> // { id: number, name: string }
```

### 2. Mapped Types

**Example:**

```typescript
// Basic mapped type
type Readonly<T> = {
  readonly [P in keyof T]: T[P]
}

// Optional mapped type
type Partial<T> = {
  [P in keyof T]?: T[P]
}

// Complex mapped type with key remapping
type SnakeToCamelCase<T> = {
  [K in keyof T as SnakeToText<K & string>]: T[K]
}

// Practical example: Form field wrapper
type FormField<T> = {
  [K in keyof T]: {
    value: T[K]
    error?: string
    touched: boolean
    validate: (value: T[K]) => boolean
  }
}

// Usage examples
interface User {
  id: number
  name: string
}

type ReadonlyUser = Readonly<User>
type PartialUser = Partial<User>

interface UserForm {
  username: string
  password: string
}

type UserFormFields = FormField<UserForm>
```

### 3. Template Literal Types

**Example:**

```typescript
// Basic template literal type
type Greeting<T extends string> = `Hello, ${T}!`

// Complex template literal with union types
type Direction = 'top' | 'right' | 'bottom' | 'left'
type Margin = `margin-${Direction}`

// Pattern matching with template literals
type ExtractNamespace<T extends string> =
  T extends `${infer Namespace}:${string}` ? Namespace : never

// CSS property type example
type CSSValue = number | string
type CSSProperties = {
  [K in Margin]?: CSSValue
}

// Event handler type example
type EventType = 'click' | 'focus' | 'blur'
type HandlerName<T extends EventType> = `on${Capitalize<T>}`

// Usage examples
type GreetJohn = Greeting<'John'> // "Hello, John!"
type MarginProps = Margin // "margin-top" | "margin-right" | ...
type Namespace = ExtractNamespace<'app:feature'> // "app"

// Practical component props example
interface ButtonProps {
  [K in HandlerName<EventType>]?: (event: any) => void
}
```

### 4. Utility Type Implementations

**Example:**

```typescript
// Pick implementation
type MyPick<T, K extends keyof T> = {
  [P in K]: T[P]
}

// Record implementation
type MyRecord<K extends keyof any, T> = {
  [P in K]: T
}

// Exclude implementation
type MyExclude<T, U> = T extends U ? never : T

// Extract implementation
type MyExtract<T, U> = T extends U ? T : never

// NonNullable implementation
type MyNonNullable<T> = T extends null | undefined ? never : T

// ReturnType implementation
type MyReturnType<T extends (...args: any) => any> = T extends (
  ...args: any
) => infer R
  ? R
  : any

// Usage examples
interface Todo {
  title: string
  description: string
  completed: boolean
}

type TodoPreview = MyPick<Todo, 'title' | 'completed'>
type PageConfig = MyRecord<'home' | 'about' | 'contact', string>
type StringOnly = MyExtract<string | number | boolean, string>
```

## Advanced Type Patterns

### 1. Type-Safe Event Emitter

**Example:**

```typescript
type EventMap = {
  'user:login': { userId: string; timestamp: number }
  'user:logout': { userId: string }
  error: { code: number; message: string }
}

class TypedEventEmitter {
  private listeners: Partial<{
    [E in keyof EventMap]: ((data: EventMap[E]) => void)[]
  }> = {}

  on<E extends keyof EventMap>(
    event: E,
    listener: (data: EventMap[E]) => void,
  ): void {
    if (!this.listeners[event]) {
      this.listeners[event] = []
    }
    this.listeners[event]?.push(listener)
  }

  emit<E extends keyof EventMap>(event: E, data: EventMap[E]): void {
    this.listeners[event]?.forEach((listener) => listener(data))
  }
}

// Usage
const emitter = new TypedEventEmitter()
emitter.on('user:login', (data) => {
  console.log(`User ${data.userId} logged in at ${data.timestamp}`)
})
```

### 2. Type-Safe API Client

**Example:**

```typescript
type APIEndpoints = {
  '/users': {
    get: {
      response: User[]
      query: { limit: number }
    }
    post: {
      body: { name: string; email: string }
      response: User
    }
  }
  '/users/:id': {
    get: {
      response: User
      params: { id: string }
    }
    put: {
      body: Partial<User>
      params: { id: string }
      response: User
    }
  }
}

class APIClient {
  async get<
    Path extends keyof APIEndpoints,
    Endpoint extends APIEndpoints[Path]['get'],
  >(
    path: Path,
    config: {
      params?: Endpoint['params']
      query?: Endpoint['query']
    },
  ): Promise<Endpoint['response']> {
    // Implementation
    return {} as any
  }

  async post<
    Path extends keyof APIEndpoints,
    Endpoint extends APIEndpoints[Path]['post'],
  >(path: Path, body: Endpoint['body']): Promise<Endpoint['response']> {
    // Implementation
    return {} as any
  }
}
```

## Interview Tips and Tricks

1. **Understanding Type Inference:**

   - Explain how TypeScript infers types
   - Know when to use explicit type annotations

2. **Type System Limitations:**

   - Understand what TypeScript can and cannot type check
   - Know workarounds for common limitations

3. **Performance Considerations:**
   - Type-level computation impact
   - Type instantiation limits

## Common Interview Questions

1. What are conditional types and when would you use them?
2. Explain the difference between keyof and typeof operators.
3. How do mapped types work and what are they useful for?
4. What are template literal types and their use cases?
5. How would you implement a type-safe event system?
6. Explain how to use infer in conditional types.
7. What are the differences between type and interface?

By mastering these advanced TypeScript types, you'll be able to create more robust and maintainable code with better type safety and developer experience.
