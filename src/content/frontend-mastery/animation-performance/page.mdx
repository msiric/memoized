# Advanced Frontend: Animation Performance

## Concept and Use Cases

**Definition:**
Animation performance optimization involves techniques for creating smooth, efficient animations while maintaining 60fps and minimizing impact on browser performance.

**Common Use Cases:**

- UI transitions
- Micro-interactions
- Data visualizations
- Scroll animations
- Page transitions
- Loading states
- Interactive elements
- Gesture responses

### Visual Representation:

```
Animation Performance Pipeline:

Style → Layout → Paint → Composite
  ↓        ↓        ↓         ↓
CSS    Reflow    Repaint   GPU Layer
```

## Key Concepts

1. **Browser Rendering:**

   - Render pipeline
   - Compositing layers
   - Frame budget

2. **Performance Properties:**

   - Transform
   - Opacity
   - GPU acceleration
   - Compositing

3. **Animation Techniques:**
   - CSS transitions
   - CSS animations
   - requestAnimationFrame
   - Web Animations API

## Implementation Examples

### 1. High-Performance Animation System

```typescript
// Animation orchestrator
interface AnimationConfig {
  duration: number
  easing: string
  properties: AnimationProperty[]
}

interface AnimationProperty {
  property: string
  from: number | string
  to: number | string
  unit?: string
}

class AnimationController {
  private animations: Map<string, Animation> = new Map()
  private rafId: number | null = null

  animate(element: HTMLElement, config: AnimationConfig): Promise<void> {
    // Ensure element is GPU accelerated
    element.style.willChange = config.properties
      .map((p) => p.property)
      .join(', ')

    // Create keyframes for each property
    const keyframes = this.createKeyframes(config.properties)

    // Create and store animation
    const animation = element.animate(keyframes, {
      duration: config.duration,
      easing: config.easing,
      fill: 'forwards',
    })

    this.animations.set(element.id, animation)

    // Return promise that resolves when animation completes
    return new Promise((resolve) => {
      animation.onfinish = () => {
        element.style.willChange = 'auto'
        this.animations.delete(element.id)
        resolve()
      }
    })
  }

  private createKeyframes(properties: AnimationProperty[]): Keyframe[] {
    return [
      properties.reduce(
        (frame, prop) => ({
          ...frame,
          [prop.property]: this.formatValue(prop.from, prop.unit),
        }),
        {},
      ),
      properties.reduce(
        (frame, prop) => ({
          ...frame,
          [prop.property]: this.formatValue(prop.to, prop.unit),
        }),
        {},
      ),
    ]
  }

  private formatValue(value: number | string, unit?: string): string {
    return typeof value === 'number' && unit
      ? `${value}${unit}`
      : value.toString()
  }
}

// React hook implementation
function useAnimation(ref: RefObject<HTMLElement>) {
  const controller = useRef(new AnimationController())

  const animate = useCallback(
    (config: AnimationConfig) => {
      if (!ref.current) return Promise.resolve()
      return controller.current.animate(ref.current, config)
    },
    [ref],
  )

  return animate
}
```

### 2. Frame-Rate Optimization

```typescript
// Frame rate monitoring and optimization
class FrameMonitor {
  private frameHistory: number[] = []
  private frameCallback: ((fps: number) => void) | null = null
  private isMonitoring: boolean = false
  private lastFrameTime: number = 0
  private rafId: number | null = null

  startMonitoring(callback?: (fps: number) => void): void {
    this.frameCallback = callback || null
    this.isMonitoring = true
    this.rafId = requestAnimationFrame(this.measureFrame.bind(this))
  }

  stopMonitoring(): void {
    this.isMonitoring = false
    if (this.rafId) {
      cancelAnimationFrame(this.rafId)
      this.rafId = null
    }
  }

  private measureFrame(timestamp: number): void {
    if (!this.isMonitoring) return

    if (this.lastFrameTime) {
      const frameDuration = timestamp - this.lastFrameTime
      const fps = Math.round(1000 / frameDuration)

      this.frameHistory.push(fps)
      if (this.frameHistory.length > 60) {
        this.frameHistory.shift()
      }

      if (this.frameCallback) {
        const averageFps = this.getAverageFps()
        this.frameCallback(averageFps)
      }
    }

    this.lastFrameTime = timestamp
    this.rafId = requestAnimationFrame(this.measureFrame.bind(this))
  }

  getAverageFps(): number {
    if (this.frameHistory.length === 0) return 0

    const sum = this.frameHistory.reduce((a, b) => a + b, 0)
    return Math.round(sum / this.frameHistory.length)
  }

  isPerformant(): boolean {
    return this.getAverageFps() >= 58 // Target 60fps with small buffer
  }
}

// Animation throttling based on performance
class AdaptiveAnimation {
  private monitor: FrameMonitor
  private quality: 'high' | 'medium' | 'low' = 'high'

  constructor() {
    this.monitor = new FrameMonitor()
    this.monitor.startMonitoring(this.adjustQuality.bind(this))
  }

  private adjustQuality(fps: number): void {
    if (fps < 30) {
      this.quality = 'low'
    } else if (fps < 45) {
      this.quality = 'medium'
    } else {
      this.quality = 'high'
    }
  }

  animate(
    element: HTMLElement,
    properties: Record<string, any>,
    duration: number,
  ): void {
    // Adjust animation based on quality
    switch (this.quality) {
      case 'low':
        // Use simple transitions
        Object.assign(element.style, properties)
        break

      case 'medium':
        // Use basic animations with reduced complexity
        this.animateBasic(element, properties, duration)
        break

      case 'high':
        // Use full animations with all effects
        this.animateFull(element, properties, duration)
        break
    }
  }

  private animateBasic(
    element: HTMLElement,
    properties: Record<string, any>,
    duration: number,
  ): void {
    element.style.transition = `all ${duration}ms linear`
    requestAnimationFrame(() => {
      Object.assign(element.style, properties)
    })
  }

  private animateFull(
    element: HTMLElement,
    properties: Record<string, any>,
    duration: number,
  ): void {
    const keyframes = Object.entries(properties).map(([prop, value]) => ({
      [prop]: value,
    }))

    element.animate(keyframes, {
      duration,
      easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
      fill: 'forwards',
    })
  }
}
```

### 3. CSS Performance Optimization

```typescript
// CSS animation performance utilities
class CSSOptimizer {
  private transformProperties = new Set([
    'transform',
    'scale',
    'rotate',
    'translate',
    'skew',
  ])

  optimizeProperties(properties: Record<string, any>): Record<string, any> {
    const optimized: Record<string, any> = {}
    const transforms: string[] = []

    for (const [key, value] of Object.entries(properties)) {
      if (this.transformProperties.has(key)) {
        transforms.push(this.createTransform(key, value))
      } else if (key === 'top' || key === 'left') {
        transforms.push(`translate${key === 'top' ? 'Y' : 'X'}(${value}px)`)
      } else {
        optimized[key] = value
      }
    }

    if (transforms.length > 0) {
      optimized.transform = transforms.join(' ')
    }

    return optimized
  }

  private createTransform(property: string, value: any): string {
    switch (property) {
      case 'scale':
        return `scale(${value})`
      case 'rotate':
        return `rotate(${value}deg)`
      case 'translate':
        return Array.isArray(value)
          ? `translate(${value[0]}px, ${value[1]}px)`
          : `translate(${value}px)`
      case 'skew':
        return `skew(${value}deg)`
      default:
        return value
    }
  }

  createGPULayer(element: HTMLElement): void {
    element.style.transform = 'translateZ(0)'
    element.style.backfaceVisibility = 'hidden'
    element.style.perspective = '1000'
  }
}

// React implementation
function useOptimizedAnimation(ref: RefObject<HTMLElement>) {
  const optimizer = useRef(new CSSOptimizer())
  const [isAnimating, setIsAnimating] = useState(false)

  const animate = useCallback(
    (
      properties: Record<string, any>,
      options: {
        duration: number
        easing?: string
        useGPU?: boolean
      },
    ) => {
      if (!ref.current) return Promise.resolve()

      const element = ref.current
      const optimizedProps = optimizer.current.optimizeProperties(properties)

      if (options.useGPU) {
        optimizer.current.createGPULayer(element)
      }

      element.style.transition = `all ${options.duration}ms ${
        options.easing || 'cubic-bezier(0.4, 0, 0.2, 1)'
      }`

      setIsAnimating(true)

      return new Promise<void>((resolve) => {
        requestAnimationFrame(() => {
          Object.assign(element.style, optimizedProps)

          const onTransitionEnd = () => {
            element.removeEventListener('transitionend', onTransitionEnd)
            setIsAnimating(false)
            resolve()
          }

          element.addEventListener('transitionend', onTransitionEnd)
        })
      })
    },
    [ref],
  )

  return { animate, isAnimating }
}
```

## Best Practices

1. **Performance Properties:**

   - Use transform and opacity
   - Avoid layout triggers
   - Promote to GPU layers

2. **Animation Timing:**

   - Use RequestAnimationFrame
   - Respect 60fps budget
   - Batch DOM updates

3. **Resource Management:**
   - Clean up animations
   - Manage GPU layers
   - Monitor performance

## Common Challenges

1. **Performance Issues:**

   - Layout thrashing
   - Jank
   - Memory leaks

2. **Browser Differences:**

   - Rendering engines
   - GPU acceleration
   - API support

3. **Mobile Performance:**
   - Battery impact
   - Memory constraints
   - Touch events

## Interview Tips and Tricks

1. **Performance Analysis:**

   - Browser dev tools
   - Frame rate monitoring
   - Performance profiling

2. **Best Practices:**

   - CSS vs JavaScript
   - GPU acceleration
   - Browser rendering

3. **Problem Solving:**
   - Performance debugging
   - Optimization techniques
   - Trade-off analysis

## Common Interview Questions

1. How do you optimize animation performance?
2. What properties trigger layout/reflow?
3. How do you implement smooth 60fps animations?
4. What's the difference between transform and position properties?
5. How do you handle high-performance mobile animations?
6. What tools do you use for animation debugging?
7. How do you measure animation performance?

Understanding animation performance is crucial for creating smooth, efficient animations. It involves knowledge of browser rendering, optimization techniques, and performance monitoring.
