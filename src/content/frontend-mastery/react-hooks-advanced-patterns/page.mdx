# Advanced React: Hook Patterns

## Concept and Use Cases

**Definition:**
Advanced hook patterns are sophisticated techniques for managing state, side effects, and component logic in React applications using hooks.

**Common Use Cases:**

- Complex state management
- Shared component logic
- Performance optimization
- Side effect management
- Component composition
- API integrations
- Form handling
- Animation control

### Visual Representation:

```
Hook Pattern Hierarchy:

Basic Hooks → Custom Hooks → Higher-Order Hooks → Hook Composition
   ↓              ↓                ↓                    ↓
useState     useLocalStorage    withLogger        useComposedState
useEffect    useAPI            withAuth          useComposedEffect
useContext   useForm          withTracking       useComposedRef
```

## Key Concepts

1. **Custom Hook Design:**

   - Composition
   - Reusability
   - Separation of concerns

2. **Hook Lifecycles:**

   - Initialization
   - Cleanup
   - Dependency management

3. **Performance Patterns:**
   - Memoization
   - Lazy initialization
   - Batching updates

## Advanced Hook Patterns

### 1. State Management Patterns

```typescript
// Complex state management with reducer pattern
interface State {
  data: any[]
  loading: boolean
  error: Error | null
  page: number
}

type Action =
  | { type: 'FETCH_START' }
  | { type: 'FETCH_SUCCESS'; payload: any[] }
  | { type: 'FETCH_ERROR'; payload: Error }
  | { type: 'SET_PAGE'; payload: number }

function useDataFetching(initialUrl: string) {
  const reducer = (state: State, action: Action): State => {
    switch (action.type) {
      case 'FETCH_START':
        return { ...state, loading: true, error: null }
      case 'FETCH_SUCCESS':
        return {
          ...state,
          loading: false,
          data: [...state.data, ...action.payload],
        }
      case 'FETCH_ERROR':
        return { ...state, loading: false, error: action.payload }
      case 'SET_PAGE':
        return { ...state, page: action.payload }
      default:
        return state
    }
  }

  const [state, dispatch] = useReducer(reducer, {
    data: [],
    loading: false,
    error: null,
    page: 1,
  })

  useEffect(() => {
    const fetchData = async () => {
      dispatch({ type: 'FETCH_START' })
      try {
        const response = await fetch(`${initialUrl}?page=${state.page}`)
        const data = await response.json()
        dispatch({ type: 'FETCH_SUCCESS', payload: data })
      } catch (error) {
        dispatch({ type: 'FETCH_ERROR', payload: error as Error })
      }
    }

    fetchData()
  }, [initialUrl, state.page])

  return state
}
```

### 2. Performance Optimization Patterns

```typescript
// Memoization pattern with deps array
function useMemoizedCallback<T extends (...args: any[]) => any>(
    callback: T,
    deps: DependencyList
): T {
    const ref = useRef<T>();

    useEffect(() => {
        ref.current = callback;
    }, [callback]);

    return useCallback((...args: any[]) => {
        const fn = ref.current;
        return fn?.(...args);
    }, deps) as T;
}

// Debounced value hook
function useDebouncedValue<T>(value: T, delay: number): T {
    const [debouncedValue, setDebouncedValue] = useState<T>(value);

    useEffect(() => {
        const handler = setTimeout(() => {
            setDebouncedValue(value);
        }, delay);

        return () => {
            clearTimeout(handler);
        };
    }, [value, delay]);

    return debouncedValue;
}

// Usage example
function SearchComponent() {
    const [search, setSearch] = useState('');
    const debouncedSearch = useDebouncedValue(search, 300);

    const handleSearch = useMemoizedCallback(async (query: string) => {
        // API call
    }, []);

    useEffect(() => {
        handleSearch(debouncedSearch);
    }, [debouncedSearch, handleSearch]);

    return (
        <input
            type="text"
            value={search}
            onChange={(e) => setSearch(e.target.value)}
        />
    );
}
```

### 3. Side Effect Management

```typescript
// Async effect hook
function useAsyncEffect(
  effect: () => Promise<void | (() => void)>,
  deps: DependencyList,
) {
  useEffect(() => {
    let cancelled = false
    let cleanup: void | (() => void)

    const execute = async () => {
      try {
        cleanup = await effect()
      } catch (error) {
        if (!cancelled) {
          throw error
        }
      }
    }

    execute()

    return () => {
      cancelled = true
      if (cleanup) {
        cleanup()
      }
    }
  }, deps)
}

// Intersection observer hook
function useIntersectionObserver(
  ref: RefObject<Element>,
  options: IntersectionObserverInit = {},
) {
  const [entry, setEntry] = useState<IntersectionObserverEntry>()

  useEffect(() => {
    const element = ref.current
    if (!element) return

    const observer = new IntersectionObserver(
      ([entry]) => setEntry(entry),
      options,
    )

    observer.observe(element)

    return () => observer.disconnect()
  }, [ref, options])

  return entry
}
```

### 4. Custom Hook Composition

```typescript
// Hook composition pattern
function useFormField<T>(initialValue: T) {
    const [value, setValue] = useState<T>(initialValue);
    const [touched, setTouched] = useState(false);
    const [error, setError] = useState<string | null>(null);

    return {
        value,
        setValue,
        touched,
        setTouched,
        error,
        setError,
        reset: () => {
            setValue(initialValue);
            setTouched(false);
            setError(null);
        }
    };
}

function useForm<T extends object>(initialValues: T) {
    const fields = Object.keys(initialValues).reduce((acc, key) => {
        acc[key] = useFormField(initialValues[key]);
        return acc;
    }, {} as Record<keyof T, ReturnType<typeof useFormField<any>>>);

    const touched = Object.values(fields).some(field => field.touched);
    const hasErrors = Object.values(fields).some(field => field.error);

    const values = Object.keys(fields).reduce((acc, key) => {
        acc[key] = fields[key].value;
        return acc;
    }, {} as T);

    return {
        fields,
        touched,
        hasErrors,
        values,
        reset: () => {
            Object.values(fields).forEach(field => field.reset());
        }
    };
}

// Usage
function LoginForm() {
    const form = useForm({
        email: '',
        password: ''
    });

    const handleSubmit = async (e: FormEvent) => {
        e.preventDefault();
        if (!form.hasErrors) {
            // Submit form
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <input
                type="email"
                value={form.fields.email.value}
                onChange={e => form.fields.email.setValue(e.target.value)}
                onBlur={() => form.fields.email.setTouched(true)}
            />
            {form.fields.email.error && (
                <span>{form.fields.email.error}</span>
            )}
            {/* Similar for password */}
        </form>
    );
}
```

### 5. Higher-Order Hooks

```typescript
// Higher-order hook pattern
function withLogging<T extends Record<string, any>>(
  useHook: () => T,
  name: string,
) {
  return function useLoggingHook(): T {
    const result = useHook()

    useEffect(() => {
      console.log(`${name} hook rendered with:`, result)
    }, [result])

    return result
  }
}

// Hook factory pattern
function createResourceHook<T>(resourceUrl: string) {
  return function useResource(id: string) {
    const [data, setData] = useState<T | null>(null)
    const [loading, setLoading] = useState(true)
    const [error, setError] = useState<Error | null>(null)

    useEffect(() => {
      const fetchData = async () => {
        try {
          const response = await fetch(`${resourceUrl}/${id}`)
          const result = await response.json()
          setData(result)
        } catch (e) {
          setError(e as Error)
        } finally {
          setLoading(false)
        }
      }

      fetchData()
    }, [id])

    return { data, loading, error }
  }
}
```

## Interview Tips and Tricks

1. **Understanding Hook Rules:**

   - Explain the rules of hooks
   - Common pitfalls and solutions
   - Best practices

2. **Performance Considerations:**

   - When to use memoization
   - Dependency array optimization
   - Render optimization

3. **Custom Hook Design:**
   - Reusability principles
   - Error handling
   - Testing strategies

## Common Interview Questions

1. What are the rules of hooks and why do they exist?
2. How do you handle side effects in custom hooks?
3. When should you use useCallback vs useMemo?
4. How do you test custom hooks?
5. What are the best practices for hook composition?
6. How do you handle async operations in hooks?
7. What are the common performance pitfalls with hooks?

Understanding advanced hook patterns is crucial for building maintainable and performant React applications. These patterns enable you to create reusable, composable logic while maintaining good separation of concerns.
