# Advanced React: Error Handling and Recovery

## Concept and Use Cases

**Definition:**
Error handling in React involves strategies for catching, displaying, logging, and recovering from various types of errors while maintaining a good user experience.

**Common Use Cases:**

- Runtime errors
- API failures
- Network issues
- Component crashes
- Data validation
- Authentication errors
- Resource loading failures
- State recovery

### Visual Representation:

```
Error Handling Hierarchy:

Global Errors → Component Errors → Async Errors → State Errors
      ↓               ↓                ↓              ↓
Error Boundary   Try/Catch      Promise Handling   Recovery
```

## Key Concepts

1. **Error Types:**

   - Runtime errors
   - Network errors
   - State errors
   - Validation errors

2. **Recovery Strategies:**

   - Graceful degradation
   - Automatic retry
   - State reset
   - Fallback UI

3. **Error Boundaries:**
   - Component isolation
   - Error capture
   - Recovery handling

## Implementation Examples

### 1. Advanced Error Boundary

```typescript
// Enhanced error boundary with recovery
interface ErrorBoundaryProps {
    fallback?: React.ReactNode;
    onError?: (error: Error, info: React.ErrorInfo) => void;
    onReset?: () => void;
    children: React.ReactNode;
}

interface ErrorBoundaryState {
    error: Error | null;
    errorInfo: React.ErrorInfo | null;
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
    state: ErrorBoundaryState = {
        error: null,
        errorInfo: null
    };

    static getDerivedStateFromError(error: Error): ErrorBoundaryState {
        return { error, errorInfo: null };
    }

    componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
        this.setState({ errorInfo });
        this.props.onError?.(error, errorInfo);

        // Log to error tracking service
        logError(error, errorInfo);
    }

    reset = () => {
        this.setState({ error: null, errorInfo: null });
        this.props.onReset?.();
    };

    render() {
        const { error, errorInfo } = this.state;
        const { fallback, children } = this.props;

        if (error) {
            if (fallback) {
                return fallback;
            }

            return (
                <div className="error-boundary">
                    <h2>Something went wrong</h2>
                    <button onClick={this.reset}>Try Again</button>
                    {process.env.NODE_ENV === 'development' && (
                        <details>
                            <summary>Error Details</summary>
                            <pre>{error.toString()}</pre>
                            <pre>{errorInfo?.componentStack}</pre>
                        </details>
                    )}
                </div>
            );
        }

        return children;
    }
}
```

### 2. Async Error Handling

```typescript
// Advanced async error handling hook
interface AsyncState<T> {
    data: T | null;
    loading: boolean;
    error: Error | null;
    retryCount: number;
}

interface AsyncOptions {
    retries?: number;
    retryDelay?: number;
    onError?: (error: Error) => void;
    resetOnUnmount?: boolean;
}

function useAsync<T>(
    asyncFn: () => Promise<T>,
    dependencies: any[] = [],
    options: AsyncOptions = {}
) {
    const {
        retries = 3,
        retryDelay = 1000,
        onError,
        resetOnUnmount = true
    } = options;

    const [state, setState] = useState<AsyncState<T>>({
        data: null,
        loading: true,
        error: null,
        retryCount: 0
    });

    const execute = useCallback(async () => {
        setState(prev => ({
            ...prev,
            loading: true,
            error: null
        }));

        try {
            const data = await asyncFn();
            setState({
                data,
                loading: false,
                error: null,
                retryCount: 0
            });
        } catch (error) {
            const shouldRetry = state.retryCount < retries;

            if (shouldRetry) {
                setTimeout(() => {
                    setState(prev => ({
                        ...prev,
                        retryCount: prev.retryCount + 1
                    }));
                    execute();
                }, retryDelay * Math.pow(2, state.retryCount));
            } else {
                setState(prev => ({
                    ...prev,
                    loading: false,
                    error: error as Error
                }));
                onError?.(error as Error);
            }
        }
    }, [asyncFn, retries, retryDelay, onError, state.retryCount]);

    useEffect(() => {
        execute();

        return () => {
            if (resetOnUnmount) {
                setState({
                    data: null,
                    loading: true,
                    error: null,
                    retryCount: 0
                });
            }
        };
    }, [...dependencies, execute]);

    return {
        ...state,
        execute
    };
}

// Usage
function UserProfile({ userId }: { userId: string }) {
    const {
        data: user,
        loading,
        error,
        execute
    } = useAsync(
        () => api.getUser(userId),
        [userId],
        {
            retries: 3,
            onError: (error) => {
                // Log error to service
                logError(error);
            }
        }
    );

    if (loading) return <Loading />;
    if (error) {
        return (
            <ErrorView
                error={error}
                onRetry={execute}
            />
        );
    }

    return <UserDetails user={user} />;
}
```

### 3. Form Error Handling

```typescript
// Advanced form error handling
interface ValidationError {
    field: string;
    message: string;
}

class FormError extends Error {
    constructor(
        public errors: ValidationError[],
        message: string = 'Form validation failed'
    ) {
        super(message);
        this.name = 'FormError';
    }
}

function useFormWithValidation<T extends Record<string, any>>(
    initialValues: T,
    validationSchema: Yup.ObjectSchema<any>
) {
    const [values, setValues] = useState<T>(initialValues);
    const [errors, setErrors] = useState<Record<keyof T, string>>({} as Record<keyof T, string>);
    const [touched, setTouched] = useState<Record<keyof T, boolean>>({} as Record<keyof T, boolean>);

    const validate = useCallback(async (fieldName?: keyof T) => {
        try {
            if (fieldName) {
                const value = values[fieldName];
                await validationSchema.validateAt(fieldName as string, values);
                setErrors(prev => ({ ...prev, [fieldName]: '' }));
            } else {
                await validationSchema.validate(values, { abortEarly: false });
                setErrors({} as Record<keyof T, string>);
            }
            return true;
        } catch (error) {
            if (error instanceof Yup.ValidationError) {
                const newErrors: Record<string, string> = {};
                error.inner.forEach(err => {
                    if (err.path) {
                        newErrors[err.path] = err.message;
                    }
                });
                setErrors(prev => ({
                    ...prev,
                    ...(fieldName ? { [fieldName]: newErrors[fieldName as string] } : newErrors)
                }));
            }
            return false;
        }
    }, [values, validationSchema]);

    const handleChange = useCallback((
        fieldName: keyof T,
        value: T[keyof T]
    ) => {
        setValues(prev => ({
            ...prev,
            [fieldName]: value
        }));
        if (touched[fieldName]) {
            validate(fieldName);
        }
    }, [touched, validate]);

    const handleBlur = useCallback((fieldName: keyof T) => {
        setTouched(prev => ({
            ...prev,
            [fieldName]: true
        }));
        validate(fieldName);
    }, [validate]);

    const handleSubmit = useCallback(async (
        onSubmit: (values: T) => Promise<void>
    ) => {
        const isValid = await validate();
        if (!isValid) {
            throw new FormError(
                Object.entries(errors)
                    .filter(([, message]) => message)
                    .map(([field, message]) => ({
                        field,
                        message
                    }))
            );
        }

        await onSubmit(values);
    }, [values, errors, validate]);

    return {
        values,
        errors,
        touched,
        handleChange,
        handleBlur,
        handleSubmit
    };
}

// Usage
function RegistrationForm() {
    const form = useFormWithValidation(
        {
            email: '',
            password: ''
        },
        Yup.object({
            email: Yup.string()
                .email('Invalid email')
                .required('Required'),
            password: Yup.string()
                .min(8, 'Too short')
                .required('Required')
        })
    );

    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        try {
            await form.handleSubmit(async (values) => {
                await api.register(values);
            });
        } catch (error) {
            if (error instanceof FormError) {
                // Handle validation errors
                console.log(error.errors);
            } else {
                // Handle other errors
                console.error(error);
            }
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            {/* Form fields */}
        </form>
    );
}
```

### 4. Network Error Recovery

```typescript
// Network error recovery
interface RetryConfig {
  maxRetries: number
  baseDelay: number
  maxDelay: number
}

class NetworkError extends Error {
  constructor(
    public response: Response,
    message: string = 'Network request failed',
  ) {
    super(message)
    this.name = 'NetworkError'
  }
}

async function fetchWithRetry(
  url: string,
  options: RequestInit = {},
  config: RetryConfig = {
    maxRetries: 3,
    baseDelay: 1000,
    maxDelay: 10000,
  },
): Promise<Response> {
  let lastError: Error

  for (let attempt = 0; attempt <= config.maxRetries; attempt++) {
    try {
      const response = await fetch(url, options)

      if (!response.ok) {
        throw new NetworkError(response)
      }

      return response
    } catch (error) {
      lastError = error as Error

      if (attempt === config.maxRetries) {
        break
      }

      const delay = Math.min(
        config.baseDelay * Math.pow(2, attempt),
        config.maxDelay,
      )

      await new Promise((resolve) => setTimeout(resolve, delay))
    }
  }

  throw lastError
}

// Usage with React Query
function useDataWithRecovery<T>(queryKey: string, fetcher: () => Promise<T>) {
  return useQuery<T, Error>(
    queryKey,
    () =>
      fetchWithRetry('/api/data', {
        headers: {
          'Content-Type': 'application/json',
        },
      }).then((res) => res.json()),
    {
      retry: (failureCount, error) => {
        if (error instanceof NetworkError) {
          // Only retry on specific status codes
          return [408, 500, 502, 503, 504].includes(error.response.status)
        }
        return failureCount < 3
      },
      retryDelay: (attemptIndex) =>
        Math.min(1000 * Math.pow(2, attemptIndex), 10000),
    },
  )
}
```

## Interview Tips and Tricks

1. **Error Strategy:**

   - Different error types
   - Recovery patterns
   - User experience

2. **Best Practices:**

   - Error tracking
   - Logging strategies
   - Fallback UIs

3. **Common Pitfalls:**
   - Silent failures
   - Cascade failures
   - Poor error messages

## Common Interview Questions

1. How do you implement error boundaries effectively?
2. What strategies do you use for API error handling?
3. How do you handle form validation errors?
4. What is your approach to retry logic?
5. How do you manage error states in complex applications?
6. What tools do you use for error tracking?
7. How do you ensure good UX during errors?

Understanding error handling and recovery is crucial for building robust React applications. It involves implementing proper error boundaries, handling async errors, and providing good user feedback.
