# Advanced JavaScript: Asynchronous Programming

## Concept and Use Cases

**Definition:**
Asynchronous programming in JavaScript allows code to run in parallel, handling operations like API calls, file I/O, and timers without blocking the main thread.

**Common Use Cases:**

- API requests and data fetching
- File operations
- Database queries
- User interactions
- Long-running computations
- Streaming data

### Visual Representation:

```
Synchronous:
Task A → Task B → Task C → Task D

Asynchronous:
Task A ─→ Task B ─→ Task D
     └─→ Task C ─┘
```

## Key Concepts

1. **Event Loop:**

   - Call stack
   - Task queue (macrotasks)
   - Microtask queue
   - Event loop process

2. **Promises:**

   - Promise states
   - Chaining
   - Error handling
   - Promise composition

3. **Async/Await:**
   - Syntax sugar for promises
   - Sequential vs parallel execution
   - Error handling with try/catch
   - Performance considerations

## Time and Space Complexity

**Time Complexity:**

- Promise creation: O(1)
- Promise chaining: O(n) where n is the number of chains
- Async/await overhead: Negligible

**Space Complexity:**

- Promise object: O(1)
- Promise chain: O(n) for n promises in memory
- Async stack traces: O(n) for n nested calls

## Asynchronous Programming: Advanced Patterns

### Custom Promise Implementation

**Problem:**
Create a custom Promise implementation with basic functionality.

**Step-by-Step Solution:**

1. Implement Promise constructor with executor
2. Add then, catch, and finally methods
3. Handle state transitions and callbacks

**Example:**

<CodeGroup>

```javascript
class MyPromise {
  constructor(executor) {
    this.state = 'pending'
    this.value = undefined
    this.callbacks = []

    const resolve = (value) => {
      if (this.state === 'pending') {
        this.state = 'fulfilled'
        this.value = value
        this.callbacks.forEach((cb) => cb())
      }
    }

    const reject = (reason) => {
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.value = reason
        this.callbacks.forEach((cb) => cb())
      }
    }

    try {
      executor(resolve, reject)
    } catch (error) {
      reject(error)
    }
  }

  then(onFulfilled, onRejected) {
    return new MyPromise((resolve, reject) => {
      const handle = () => {
        try {
          const callback = this.state === 'fulfilled' ? onFulfilled : onRejected
          const result = callback(this.value)
          resolve(result)
        } catch (error) {
          reject(error)
        }
      }

      if (this.state === 'pending') {
        this.callbacks.push(handle)
      } else {
        setTimeout(handle, 0)
      }
    })
  }

  catch(onRejected) {
    return this.then(null, onRejected)
  }
}

// Usage
const promise = new MyPromise((resolve, reject) => {
  setTimeout(() => resolve('Success!'), 1000)
})

promise
  .then((result) => console.log(result))
  .catch((error) => console.error(error))
```

```typescript
type Executor<T> = (
  resolve: (value: T) => void,
  reject: (reason: any) => void,
) => void

type State = 'pending' | 'fulfilled' | 'rejected'

class MyPromise<T> {
  private state: State = 'pending'
  private value: T | any
  private callbacks: (() => void)[] = []

  constructor(executor: Executor<T>) {
    const resolve = (value: T): void => {
      if (this.state === 'pending') {
        this.state = 'fulfilled'
        this.value = value
        this.callbacks.forEach((cb) => cb())
      }
    }

    const reject = (reason: any): void => {
      if (this.state === 'pending') {
        this.state = 'rejected'
        this.value = reason
        this.callbacks.forEach((cb) => cb())
      }
    }

    try {
      executor(resolve, reject)
    } catch (error) {
      reject(error)
    }
  }

  then<U>(
    onFulfilled?: (value: T) => U,
    onRejected?: (reason: any) => U,
  ): MyPromise<U> {
    return new MyPromise<U>((resolve, reject) => {
      const handle = () => {
        try {
          const callback = this.state === 'fulfilled' ? onFulfilled : onRejected
          const result = callback?.(this.value)
          resolve(result as U)
        } catch (error) {
          reject(error)
        }
      }

      if (this.state === 'pending') {
        this.callbacks.push(handle)
      } else {
        setTimeout(handle, 0)
      }
    })
  }

  catch<U>(onRejected: (reason: any) => U): MyPromise<U> {
    return this.then(null, onRejected)
  }
}

// Usage
const promise = new MyPromise<string>((resolve, reject) => {
  setTimeout(() => resolve('Success!'), 1000)
})

promise
  .then((result) => console.log(result))
  .catch((error) => console.error(error))
```

</CodeGroup>

### Advanced Promise Patterns

**Problem:**
Implement advanced Promise patterns for complex async operations.

**Example:**

<CodeGroup>

```javascript
// Promise.race with timeout
const withTimeout = (promise, timeout) => {
  const timeoutPromise = new Promise((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), timeout)
  })
  return Promise.race([promise, timeoutPromise])
}

// Retry mechanism with exponential backoff
const retry = async (fn, retries = 3, delay = 1000, multiplier = 2) => {
  try {
    return await fn()
  } catch (error) {
    if (retries === 0) throw error
    await new Promise((resolve) => setTimeout(resolve, delay))
    return retry(fn, retries - 1, delay * multiplier)
  }
}

// Concurrent request limiter
class RequestLimiter {
  constructor(limit) {
    this.limit = limit
    this.queue = []
    this.running = 0
  }

  async add(fn) {
    if (this.running >= this.limit) {
      await new Promise((resolve) => this.queue.push(resolve))
    }
    return this.run(fn)
  }

  async run(fn) {
    this.running++
    try {
      return await fn()
    } finally {
      this.running--
      if (this.queue.length > 0) {
        const next = this.queue.shift()
        next()
      }
    }
  }
}

// Usage examples
const api = {
  fetch: () =>
    new Promise((resolve) => setTimeout(() => resolve('data'), 1000)),
}

// With timeout
withTimeout(api.fetch(), 2000).then(console.log).catch(console.error)

// With retry
retry(() => api.fetch())
  .then(console.log)
  .catch(console.error)

// With request limiting
const limiter = new RequestLimiter(2)
Promise.all([
  limiter.add(() => api.fetch()),
  limiter.add(() => api.fetch()),
  limiter.add(() => api.fetch()),
]).then(console.log)
```

```typescript
// Promise.race with timeout
const withTimeout = <T>(promise: Promise<T>, timeout: number): Promise<T> => {
  const timeoutPromise = new Promise<never>((_, reject) => {
    setTimeout(() => reject(new Error('Timeout')), timeout)
  })
  return Promise.race([promise, timeoutPromise])
}

// Retry mechanism with exponential backoff
const retry = async <T>(
  fn: () => Promise<T>,
  retries: number = 3,
  delay: number = 1000,
  multiplier: number = 2,
): Promise<T> => {
  try {
    return await fn()
  } catch (error) {
    if (retries === 0) throw error
    await new Promise((resolve) => setTimeout(resolve, delay))
    return retry(fn, retries - 1, delay * multiplier)
  }
}

// Concurrent request limiter
class RequestLimiter {
  private limit: number
  private queue: (() => void)[]
  private running: number

  constructor(limit: number) {
    this.limit = limit
    this.queue = []
    this.running = 0
  }

  async add<T>(fn: () => Promise<T>): Promise<T> {
    if (this.running >= this.limit) {
      await new Promise<void>((resolve) => this.queue.push(resolve))
    }
    return this.run(fn)
  }

  private async run<T>(fn: () => Promise<T>): Promise<T> {
    this.running++
    try {
      return await fn()
    } finally {
      this.running--
      if (this.queue.length > 0) {
        const next = this.queue.shift()
        next?.()
      }
    }
  }
}

// Usage examples
const api = {
  fetch: (): Promise<string> =>
    new Promise((resolve) => setTimeout(() => resolve('data'), 1000)),
}

// With timeout
withTimeout(api.fetch(), 2000).then(console.log).catch(console.error)

// With retry
retry(() => api.fetch())
  .then(console.log)
  .catch(console.error)

// With request limiting
const limiter = new RequestLimiter(2)
Promise.all([
  limiter.add(() => api.fetch()),
  limiter.add(() => api.fetch()),
  limiter.add(() => api.fetch()),
]).then(console.log)
```

</CodeGroup>

### Async Iterators and Generators

**Problem:**
Implement an async data streaming solution using generators.

**Example:**

<CodeGroup>

```javascript
async function* createDataStream() {
  let id = 1
  while (true) {
    const data = await fetchDataChunk(id)
    if (!data) break
    yield data
    id++
  }
}

async function fetchDataChunk(id) {
  // Simulated API call
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(id <= 3 ? { id, data: `Chunk ${id}` } : null)
    }, 1000)
  })
}

async function processStream() {
  const stream = createDataStream()
  for await (const chunk of stream) {
    console.log('Processing:', chunk)
  }
  console.log('Stream complete')
}

processStream()
```

```typescript
interface DataChunk {
  id: number
  data: string
}

async function* createDataStream(): AsyncGenerator<DataChunk, void, unknown> {
  let id = 1
  while (true) {
    const data = await fetchDataChunk(id)
    if (!data) break
    yield data
    id++
  }
}

async function fetchDataChunk(id: number): Promise<DataChunk | null> {
  // Simulated API call
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(id <= 3 ? { id, data: `Chunk ${id}` } : null)
    }, 1000)
  })
}

async function processStream(): Promise<void> {
  const stream = createDataStream()
  for await (const chunk of stream) {
    console.log('Processing:', chunk)
  }
  console.log('Stream complete')
}

processStream()
```

</CodeGroup>

## Practical Tips and Tricks

- **Error Handling:**
  Always implement proper error handling for async operations

- **Memory Management:**
  Be careful with closures in async code to prevent memory leaks

- **Cancellation:**
  Implement cancellation mechanisms for long-running operations

## Common Gotchas

- **Promise Chain Breaking:**
  Always return promises in .then() handlers

- **Async Context Loss:**
  Be careful with 'this' binding in async functions

- **Unhandled Rejections:**
  Always add error handlers to promise chains

## Advanced Topics

### Custom Async Utilities

**Problem:**
Create utilities for common async patterns.

**Example:**

<CodeGroup>

```javascript
// Parallel execution with concurrency limit
async function parallelLimit(tasks, limit) {
  const results = []
  const executing = new Set()

  async function executeTask(task, index) {
    executing.add(index)
    try {
      results[index] = await task()
    } finally {
      executing.delete(index)
    }
  }

  let index = 0
  while (index < tasks.length || executing.size > 0) {
    if (executing.size < limit && index < tasks.length) {
      executeTask(tasks[index], index)
      index++
    } else {
      await Promise.race(
        Array.from(executing).map((i) =>
          results[i] instanceof Promise ? results[i] : Promise.resolve(),
        ),
      )
    }
  }

  return results
}

// Debounced async function
function debounceAsync(fn, delay) {
  let timeoutId
  let pendingPromise

  return function (...args) {
    if (timeoutId) clearTimeout(timeoutId)

    if (!pendingPromise) {
      pendingPromise = new Promise((resolve, reject) => {
        timeoutId = setTimeout(async () => {
          try {
            const result = await fn.apply(this, args)
            resolve(result)
          } catch (error) {
            reject(error)
          } finally {
            pendingPromise = null
          }
        }, delay)
      })
    }

    return pendingPromise
  }
}
```

```typescript
// Parallel execution with concurrency limit
async function parallelLimit<T>(
  tasks: (() => Promise<T>)[],
  limit: number,
): Promise<T[]> {
  const results: T[] = []
  const executing = new Set<number>()

  async function executeTask(
    task: () => Promise<T>,
    index: number,
  ): Promise<void> {
    executing.add(index)
    try {
      results[index] = await task()
    } finally {
      executing.delete(index)
    }
  }

  let index = 0
  while (index < tasks.length || executing.size > 0) {
    if (executing.size < limit && index < tasks.length) {
      executeTask(tasks[index], index)
      index++
    } else {
      await Promise.race(
        Array.from(executing).map((i) =>
          results[i] instanceof Promise ? results[i] : Promise.resolve(),
        ),
      )
    }
  }

  return results
}

// Debounced async function (continued)
function debounceAsync<T, A extends any[]>(
  fn: (...args: A) => Promise<T>,
  delay: number,
): (...args: A) => Promise<T> {
  let timeoutId: NodeJS.Timeout
  let pendingPromise: Promise<T> | null = null

  return function (this: any, ...args: A): Promise<T> {
    if (timeoutId) clearTimeout(timeoutId)

    if (!pendingPromise) {
      pendingPromise = new Promise<T>((resolve, reject) => {
        timeoutId = setTimeout(async () => {
          try {
            const result = await fn.apply(this, args)
            resolve(result)
          } catch (error) {
            reject(error)
          } finally {
            pendingPromise = null
          }
        }, delay)
      })
    }

    return pendingPromise
  }
}

// Usage examples
async function main() {
  // Example with parallelLimit
  const tasks = [
    () => new Promise((resolve) => setTimeout(() => resolve(1), 1000)),
    () => new Promise((resolve) => setTimeout(() => resolve(2), 500)),
    () => new Promise((resolve) => setTimeout(() => resolve(3), 1500)),
  ]

  const results = await parallelLimit(tasks, 2)
  console.log('Parallel results:', results)

  // Example with debounceAsync
  const debouncedFetch = debounceAsync(async (query: string) => {
    const response = await fetch(`https://api.example.com/search?q=${query}`)
    return response.json()
  }, 300)

  // Multiple rapid calls will only execute once
  await Promise.all([
    debouncedFetch('test1'),
    debouncedFetch('test2'),
    debouncedFetch('test3'),
  ])
}
```

</CodeGroup>

## Interview Tips and Tricks

1. **Explain the Event Loop:**

   - Be ready to explain how the event loop works in detail
   - Understand the difference between macrotasks and microtasks
   - Know how async/await affects the event loop

2. **Common Async Patterns:**

   - Describe patterns like debouncing, throttling, and parallel execution
   - Explain when to use each pattern
   - Discuss error handling strategies

3. **Performance Considerations:**
   - Understand the impact of async operations on performance
   - Know how to optimize async code
   - Be aware of memory implications

## Common Interview Questions

1. Explain the difference between Promises and async/await.
2. How does the event loop handle different types of tasks?
3. What are common async patterns and when would you use them?
4. How do you handle errors in async code?
5. Explain the difference between parallel and concurrent execution.
6. How would you implement a timeout for an async operation?
7. What are the benefits and drawbacks of using generators for async operations?

## Advanced Use Cases

1. **Real-time Data Handling:**

   - WebSocket connections
   - Server-Sent Events
   - Streaming APIs

2. **Complex UI Updates:**

   - Handling multiple async operations
   - Managing loading states
   - Error boundaries

3. **Resource Management:**
   - Connection pooling
   - Rate limiting
   - Cache invalidation

## Common Mistakes to Avoid

1. **Callback Hell:**

   ```javascript
   // Bad
   asyncOp1((result1) => {
     asyncOp2(result1, (result2) => {
       asyncOp3(result2, (result3) => {
         // Deeply nested callbacks
       })
     })
   })

   // Good
   const result1 = await asyncOp1()
   const result2 = await asyncOp2(result1)
   const result3 = await asyncOp3(result2)
   ```

2. **Unhandled Promise Rejections:**

   ```javascript
   // Bad
   someAsyncOperation().then((result) => {
     // Handle success
   })

   // Good
   someAsyncOperation()
     .then((result) => {
       // Handle success
     })
     .catch((error) => {
       // Handle error
     })
   ```

3. **Unnecessary Async/Await:**

   ```javascript
   // Bad
   const getData = async () => {
     return await Promise.resolve('data')
   }

   // Good
   const getData = () => Promise.resolve('data')
   ```

By mastering these asynchronous programming concepts and patterns, you'll be well-equipped to handle complex async scenarios in modern JavaScript applications. Remember to always consider error handling, performance implications, and proper resource management in your async code.
