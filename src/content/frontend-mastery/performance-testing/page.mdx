# Advanced Frontend: Performance Testing

## Concept and Use Cases

**Definition:**
Performance testing involves measuring and analyzing application performance metrics to ensure optimal user experience and identify performance regressions.

**Common Use Cases:**

- Load time optimization
- Runtime performance
- Animation smoothness
- Memory usage
- Network efficiency
- Asset loading
- Resource utilization
- Core Web Vitals

### Visual Representation:

```
Performance Testing Layers:

Metrics → Analysis → Benchmarks → CI/CD
   ↓          ↓          ↓          ↓
Collect    Process    Compare    Automate
```

## Key Concepts

1. **Performance Metrics:**

   - Core Web Vitals
   - Custom metrics
   - User timings
   - Resource timing

2. **Testing Types:**

   - Lighthouse audits
   - Custom benchmarks
   - Load testing
   - Runtime analysis

3. **Integration:**
   - CI/CD pipeline
   - Automated testing
   - Performance budgets
   - Regression detection

## Implementation Examples

### 1. Lighthouse CI Integration

```typescript
// lighthouse-config.ts
interface LighthouseConfig {
  ci: {
    collect: {
      numberOfRuns: number
      url: string[]
      settings: {
        preset: string
        chromeFlags: string[]
      }
    }
    assert: {
      assertions: Record<string, any>
    }
    upload: {
      target: string
      token: string
    }
  }
}

const config: LighthouseConfig = {
  ci: {
    collect: {
      numberOfRuns: 3,
      url: [
        'http://localhost:3000/',
        'http://localhost:3000/products',
        'http://localhost:3000/checkout',
      ],
      settings: {
        preset: 'desktop',
        chromeFlags: ['--no-sandbox'],
      },
    },
    assert: {
      assertions: {
        'first-contentful-paint': ['warn', { maxNumericValue: 2000 }],
        interactive: ['error', { maxNumericValue: 3000 }],
        'largest-contentful-paint': ['error', { maxNumericValue: 2500 }],
        'cumulative-layout-shift': ['error', { maxNumericValue: 0.1 }],
      },
    },
    upload: {
      target: 'lhci',
      token: process.env.LHCI_TOKEN,
    },
  },
}

export default config

// Custom Lighthouse reporter
class CustomLighthouseReporter {
  private results: any[] = []

  addResult(result: any): void {
    this.results.push(result)
  }

  generateReport(): string {
    const summary = this.results.reduce((acc, result) => {
      return {
        ...acc,
        [result.url]: {
          fcp: result.audits['first-contentful-paint'].numericValue,
          lcp: result.audits['largest-contentful-paint'].numericValue,
          tbt: result.audits['total-blocking-time'].numericValue,
          cls: result.audits['cumulative-layout-shift'].numericValue,
        },
      }
    }, {})

    return JSON.stringify(summary, null, 2)
  }

  checkBudgets(budgets: Record<string, number>): boolean {
    return this.results.every((result) => {
      return Object.entries(budgets).every(([metric, budget]) => {
        return result.audits[metric].numericValue <= budget
      })
    })
  }
}
```

### 2. Custom Performance Benchmarks

```typescript
// Performance benchmark framework
class PerformanceBenchmark {
    private metrics: Map<string, number[]> = new Map();
    private marks: Map<string, number> = new Map();

    startMeasurement(name: string): void {
        this.marks.set(name, performance.now());
    }

    endMeasurement(name: string): void {
        const startTime = this.marks.get(name);
        if (!startTime) return;

        const duration = performance.now() - startTime;
        const measurements = this.metrics.get(name) || [];
        measurements.push(duration);
        this.metrics.set(name, measurements);
    }

    async measureFunction<T>(
        name: string,
        fn: () => T | Promise<T>
    ): Promise<T> {
        this.startMeasurement(name);
        const result = await fn();
        this.endMeasurement(name);
        return result;
    }

    getStatistics(name: string): {
        min: number;
        max: number;
        avg: number;
        p95: number;
    } {
        const measurements = this.metrics.get(name) || [];
        if (measurements.length === 0) {
            return { min: 0, max: 0, avg: 0, p95: 0 };
        }

        const sorted = [...measurements].sort((a, b) => a - b);
        const p95Index = Math.floor(sorted.length * 0.95);

        return {
            min: sorted[0],
            max: sorted[sorted.length - 1],
            avg: sorted.reduce((a, b) => a + b) / sorted.length,
            p95: sorted[p95Index]
        };
    }
}

// Usage in tests
describe('Performance Benchmarks', () => {
    let benchmark: PerformanceBenchmark;

    beforeEach(() => {
        benchmark = new PerformanceBenchmark();
    });

    it('measures component render performance', async () => {
        const iterations = 100;

        for (let i = 0; i < iterations; i++) {
            await benchmark.measureFunction('render', () => {
                const { container } = render(<ComplexComponent />);
                return container;
            });
        }

        const stats = benchmark.getStatistics('render');
        expect(stats.avg).toBeLessThan(16); // 60fps threshold
        expect(stats.p95).toBeLessThan(32); // 30fps threshold
    });
});
```

### 3. Runtime Performance Testing

```typescript
// Runtime performance monitoring
class RuntimePerformanceMonitor {
    private frameHistory: number[] = [];
    private memorySnapshots: MemorySnapshot[] = [];
    private isMonitoring: boolean = false;

    startMonitoring(): void {
        this.isMonitoring = true;
        this.monitorFrameRate();
        this.monitorMemory();
    }

    stopMonitoring(): {
        frameStats: FrameStatistics;
        memoryStats: MemoryStatistics;
    } {
        this.isMonitoring = false;
        return {
            frameStats: this.calculateFrameStatistics(),
            memoryStats: this.calculateMemoryStatistics()
        };
    }

    private monitorFrameRate(): void {
        let lastFrameTime = performance.now();

        const measureFrame = (timestamp: number) => {
            if (!this.isMonitoring) return;

            const frameDuration = timestamp - lastFrameTime;
            this.frameHistory.push(frameDuration);
            lastFrameTime = timestamp;

            if (this.frameHistory.length > 60) {
                this.frameHistory.shift();
            }

            requestAnimationFrame(measureFrame);
        };

        requestAnimationFrame(measureFrame);
    }

    private monitorMemory(): void {
        const measureMemory = async () => {
            if (!this.isMonitoring) return;

            if ('memory' in performance) {
                const snapshot = await (performance as any).measureUserAgentSpecificMemory();
                this.memorySnapshots.push(snapshot);
            }

            setTimeout(measureMemory, 1000);
        };

        measureMemory();
    }

    private calculateFrameStatistics(): FrameStatistics {
        const frames = this.frameHistory;
        return {
            avgFPS: 1000 / (frames.reduce((a, b) => a + b) / frames.length),
            dropped: frames.filter(f => f > 16.67).length,
            p95: this.calculatePercentile(frames, 0.95)
        };
    }

    private calculateMemoryStatistics(): MemoryStatistics {
        const snapshots = this.memorySnapshots;
        return {
            avgHeapSize: snapshots.reduce((a, b) => a + b.bytes, 0) / snapshots.length,
            maxHeapSize: Math.max(...snapshots.map(s => s.bytes)),
            leakSuspected: this.detectMemoryLeak(snapshots)
        };
    }

    private detectMemoryLeak(snapshots: MemorySnapshot[]): boolean {
        if (snapshots.length < 10) return false;

        const trend = this.calculateTrend(
            snapshots.map(s => s.bytes)
        );
        return trend > 0.1; // Positive trend indicates potential leak
    }

    private calculateTrend(values: number[]): number {
        // Linear regression implementation
        return 0; // Simplified
    }
}

// Integration with test framework
describe('Runtime Performance Tests', () => {
    let monitor: RuntimePerformanceMonitor;

    beforeEach(() => {
        monitor = new RuntimePerformanceMonitor();
    });

    it('maintains performance under load', async () => {
        monitor.startMonitoring();

        // Perform intensive operations
        for (let i = 0; i < 1000; i++) {
            render(<ComplexComponent data={generateLargeDataset()} />);
        }

        const stats = monitor.stopMonitoring();

        expect(stats.frameStats.avgFPS).toBeGreaterThan(55);
        expect(stats.frameStats.dropped).toBeLessThan(10);
        expect(stats.memoryStats.leakSuspected).toBe(false);
    });
});
```

## Best Practices

1. **Test Design:**

   - Realistic scenarios
   - Consistent environment
   - Clear metrics

2. **Automation:**

   - CI/CD integration
   - Regular testing
   - Trend analysis

3. **Analysis:**
   - Data visualization
   - Trend detection
   - Root cause analysis

## Common Challenges

1. **Environment Issues:**

   - Test consistency
   - Resource limitations
   - Tool compatibility

2. **Data Analysis:**

   - Metric correlation
   - Noise filtering
   - Trend identification

3. **Maintenance:**
   - Test stability
   - Tool updates
   - Environment changes

## Interview Tips and Tricks

1. **Testing Strategy:**

   - Metric selection
   - Tool choice
   - Automation approach

2. **Best Practices:**

   - Test reliability
   - Data analysis
   - Reporting

3. **Problem Solving:**
   - Performance debugging
   - Root cause analysis
   - Optimization strategies

## Common Interview Questions

1. How do you set up performance testing in CI/CD?
2. What key metrics do you track in performance tests?
3. How do you handle performance regressions?
4. What tools do you use for performance testing?
5. How do you analyze performance test results?
6. What strategies do you use for performance optimization?
7. How do you ensure consistent performance test results?

Understanding performance testing is crucial for maintaining application quality. It involves setting up proper testing infrastructure, analyzing results, and maintaining performance standards through automated testing.
