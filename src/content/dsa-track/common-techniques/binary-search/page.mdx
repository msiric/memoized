export const metadata = {
  title: 'Comprehensive Guide to Binary Search in JavaScript',
  description: 'Efficiently search sorted arrays. Understand binary search, performance considerations, and practical examples.',
}

# **Binary Search**

Binary search is an efficient algorithm for finding an item from a sorted list of items by repeatedly dividing the search interval in half. Before diving into modified versions, it's essential to understand the conventional binary search algorithm.

## **Concept and Use Cases**

**Definition:**
Binary search is an algorithm that finds the position of a target value within a sorted array by repeatedly dividing the search interval in half.

### **Visual Representation:**
Consider the array `nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` and target `7`. The binary search algorithm starts with the middle element and repeatedly halves the search interval until it finds the target element at index `6`.

### **Common Use Cases:**
- Searching for a specific value in a sorted array.
- Finding the lower or upper bound of a value in a sorted array.
- Searching in databases and libraries where data is sorted.

## **When to Use**
- When you need to search for an element in a sorted array efficiently.
- When solving problems that involve finding specific positions or conditions in sorted data.
- When the data set is large, and a linear search would be too slow.

## **Time and Space Complexity**

**Time Complexity:**
- O(log n), where n is the number of elements in the array. This is because the search interval is halved in each step.

**Space Complexity:**
- O(1) for the iterative approach, as it uses a constant amount of extra space.
- O(log n) for the recursive approach, due to the call stack.

## **Common Problems**

1. **Conventional Binary Search:**
   - **Problem:** Given a sorted array of integers, find the index of a target value. If the target is not found, return -1.
   - **Approach:** Use the binary search algorithm to find the target.

2. **Finding the First and Last Occurrence of an Element:**
   - **Problem:** Given a sorted array, find the first and last position of a target element. If the target is not found, return [-1, -1].
   - **Approach:** Use modified binary searches to find the first and last occurrences separately.

3. **Searching in a Rotated Sorted Array:**
   - **Problem:** Given a rotated sorted array, find the index of a target element. If the target is not found, return -1.
   - **Approach:** Use a modified binary search to handle the rotation and find the target.

4. **Finding the Peak Element in an Array:**
   - **Problem:** Given an array, find a peak element. A peak element is an element that is greater than its neighbors. Return the index of the peak element.
   - **Approach:** Use a modified binary search to find the peak element.

## **Conventional Binary Search**

**Problem:** Given a sorted array of integers, find the index of a target value. If the target is not found, return -1.

### **Step-by-Step Solution:**
1. Initialize two pointers, `left` and `right`, to the beginning and end of the array, respectively.
2. Calculate the middle index `mid`.
3. Compare the target value with the element at the middle index:
   - If the target is equal to the middle element, return the middle index.
   - If the target is less than the middle element, adjust the `right` pointer to `mid - 1`.
   - If the target is greater than the middle element, adjust the `left` pointer to `mid + 1`.
4. Repeat steps 2-3 until the target is found or the search interval is empty.

### **Example:**

<CodeGroup>

```javascript
function binarySearch(nums, target) {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;  // Target not found
}

// Example usage:
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const target = 7;
console.log(binarySearch(nums, target));  // Output: 6
```

```typescript
function binarySearch(nums: number[], target: number): number {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;  // Target not found
}

// Example usage:
const nums: number[] = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const target: number = 7;
console.log(binarySearch(nums, target));  // Output: 6
```

</CodeGroup>

### **Tips and Tricks:**
- Ensure the array is sorted before performing binary search.
- Use integer division to calculate the middle index to avoid decimal values.
- Adjust the `left` and `right` pointers based on the comparison results.

### **Frequent Gotchas:**
- Forgetting to adjust the pointers correctly, leading to infinite loops.
- Misinterpreting the middle index calculation, resulting in incorrect comparisons.
- Not handling edge cases where the target is at the beginning or end of the array.

## **Finding the First and Last Occurrence of an Element**

**Problem:** Given a sorted array, find the first and last position of a target element. If the target is not found, return [-1, -1].

### **Step-by-Step Solution:**
1. Perform a modified binary search to find the first occurrence of the target.
2. Perform a modified binary search to find the last occurrence of the target.
3. Return the positions of the first and last occurrences.

### **Example:**

<CodeGroup>

```javascript
function searchRange(nums, target) {
    const result = [-1, -1];

    result[0] = findBound(nums, target, true);
    if (result[0] !== -1) {
        result[1] = findBound(nums, target, false);
    }

    return result;
}

function findBound(nums, target, isFirst) {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            if (isFirst) {
                if (mid === left || nums[mid - 1] !== target) {
                    return mid;
                }
                right = mid - 1;
            } else {
                if (mid === right || nums[mid + 1] !== target) {
                    return mid;
                }
                left = mid + 1;
            }
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

// Example usage:
const nums = [5, 7, 7, 8, 8, 10];
const target = 8;
console.log(searchRange(nums, target));  // Output: [3, 4]
```

```typescript
function searchRange(nums: number[], target: number): number[] {
    const result: number[] = [-1, -1];

    result[0] = findBound(nums, target, true);
    if (result[0] !== -1) {
        result[1] = findBound(nums, target, false);
    }

    return result;
}

function findBound(nums: number[], target: number, isFirst: boolean): number {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            if (isFirst) {
                if (mid === left || nums[mid - 1] !== target) {
                    return mid;
                }
                right = mid - 1;
            } else {
                if (mid === right || nums[mid + 1] !== target) {
                    return mid;
                }
                left = mid + 1;
            }
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

// Example usage:
const nums: number[] = [5, 7, 7, 8, 8, 10];
const target: number = 8;
console.log(searchRange(nums, target));  // Output: [3, 4]
```

</CodeGroup>

### **Tips and Tricks:**
- Use two separate searches to find the first and last occurrences of the target.
- Adjust the search range based on whether you're looking for the first or last occurrence.
- Check boundary conditions to ensure correct identification of the target's position.

### **Frequent Gotchas:**
- Forgetting to check if the target is found before performing the second search.
- Incorrectly updating the search range, leading to infinite loops or incorrect results.
- Handling edge cases where the target is at the beginning or end of the array.

## **Searching in a Rotated Sorted Array**

**Problem:** Given a rotated sorted array, find the index of a target element. If the target is not found, return -1.

### **Step-by-Step Solution:**
1. Perform a modified binary search to identify the pivot point where the rotation occurs.
2. Use the pivot to determine which part of the array to search for the target.
3. Perform a standard binary search in the identified part of the array.

### **Example:**

<CodeGroup>

```javascript
function search(nums, target) {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        }

        if (nums[left] <= nums[mid]) {  // Left half is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {  // Right half is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}

// Example usage:
const nums = [4, 5, 6, 7, 0, 1, 2];
const target = 0;
console.log(search(nums, target));  // Output: 4
```

```typescript
function search(nums: number[], target: number): number {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        }

        if (nums[left] <= nums[mid]) {  // Left half is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {  // Right half is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}

// Example usage:
const nums: number[] = [4, 5, 6, 7, 0, 1, 2];
const target: number = 0;
console.log(search(nums, target));  // Output: 4
```

</CodeGroup>

### **Tips and Tricks:**
- Identify which part of the array is sorted and adjust the search range accordingly.
- Use boundary conditions to determine which half of the array to search.
- Perform a standard binary search once the correct part of the array is identified.

### **Frequent Gotchas:**
- Misidentifying the sorted half of the array, leading to incorrect search ranges.
- Not handling edge cases where the target is at the pivot point.
- Incorrectly updating the search range, leading to infinite loops or incorrect results.

## **Finding the Peak Element in an Array**

**Problem:** Given an array, find a peak element. A peak element is an element that is greater than its neighbors. Return the index of the peak element. The array may contain multiple peaks, in which case return the index of any one of the peaks.

### **Step-by-Step Solution:**
1. Perform a modified binary search to identify the peak element.
2. Compare the middle element with its neighbors to determine the search direction.
3. Continue the search until a peak element is found.

### **Example:**

<CodeGroup>

```javascript
function findPeakElement(nums) {
    let left = 0, right = nums.length - 1;

    while (left < right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

// Example usage:
const nums = [1, 2, 3, 1];
console.log(findPeakElement(nums));  // Output: 2
```

```typescript
function findPeakElement(nums: number[]): number {
    let left = 0, right = nums.length - 1;

    while (left < right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

// Example usage:
const nums: number[] = [1, 2, 3, 1];
console.log(findPeakElement(nums));  // Output: 2
```

</CodeGroup>

### **Tips and Tricks:**
- Use binary search to divide the array and compare the middle element with its neighbors.
- Adjust the search range based on the comparison results to find a peak element.
- Ensure the search continues until a peak element is identified.

### **Frequent Gotchas:**
- Forgetting to compare the middle element with its neighbors correctly.
- Misidentifying the search range, leading to incorrect results.
- Handling edge cases where the peak is at the beginning or end of the array.

By mastering both the conventional and modified binary search techniques, you can efficiently solve a variety of problems involving searching in sorted arrays, finding specific positions or conditions, and handling complex search scenarios. This technique is essential for optimizing time complexity and handling binary search-related problems effectively in both technical interviews and real-world applications.