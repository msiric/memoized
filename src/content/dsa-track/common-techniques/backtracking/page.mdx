export const metadata = {
  title: 'Comprehensive Guide to Backtracking in JavaScript',
  description: 'Find solutions by exploring all possible options and backtracking. Understand backtracking algorithms, performance considerations, and practical examples.',
}

# **Backtracking**

Backtracking is a technique for solving computational problems incrementally, one piece at a time, and removing solutions that fail to satisfy the constraints of the problem at any point in time. It is often used to solve combinatorial problems.

## **Concept and Use Cases**

**Definition:**
Backtracking is a method for finding all (or some) solutions to a problem by incrementally building candidates and abandoning them (backtracking) if they are not suitable.

**Common Use Cases:**
- Constraint satisfaction problems (e.g., Sudoku, N-Queens).
- Combinatorial problems (e.g., permutations, subsets).
- Pathfinding problems (e.g., maze solving).

### **Visual Representation:**
Imagine solving a maze. You start at the entrance and explore paths until you find a dead end, then backtrack to the last decision point and try a different path.

## **Key Concepts**

1. **Incremental Construction:**
   - Build the solution step by step, one piece at a time.
   
2. **Constraint Checking:**
   - Check if the current partial solution is valid or should be abandoned.

3. **Backtracking:**
   - Abandon the current partial solution if it fails to satisfy constraints and backtrack to try another option.

## **Time and Space Complexity**

**Time Complexity:**
- Depends on the problem and the number of solutions. In the worst case, it can be exponential, O(b^d), where b is the branching factor and d is the depth of the tree.

**Space Complexity:**
- Depends on the depth of the recursion tree. Typically O(d), where d is the depth of the recursion tree.

## **Backtracking Operations and Methods**

### **N-Queens Problem**

**Problem:**
Place N queens on an N×N chessboard such that no two queens threaten each other.

**Step-by-Step Solution:**
1. Use a helper function to check if a queen can be placed at a given position without being attacked.
2. Recursively attempt to place queens in each row.
3. Backtrack if placing a queen leads to a conflict.

**Example:**

<CodeGroup>

```javascript
function solveNQueens(n) {
    let result = [];
    let board = Array.from({ length: n }, () => Array(n).fill('.'));

    function isSafe(board, row, col) {
        for (let i = 0; i < col; i++) {
            if (board[row][i] === 'Q') return false;
        }
        for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] === 'Q') return false;
        }
        for (let i = row, j = col; i < n && j >= 0; i++, j--) {
            if (board[i][j] === 'Q') return false;
        }
        return true;
    }

    function solve(board, col) {
        if (col === n) {
            result.push(board.map(row => row.join('')));
            return;
        }
        for (let i = 0; i < n; i++) {
            if (isSafe(board, i, col)) {
                board[i][col] = 'Q';
                solve(board, col + 1);
                board[i][col] = '.';
            }
        }
    }

    solve(board, 0);
    return result;
}

console.log(solveNQueens(4));
// Output: [
//   [".Q..", "...Q", "Q...", "..Q."],
//   ["..Q.", "Q...", "...Q", ".Q.."]
// ]
```

```typescript
function solveNQueens(n: number): string[][] {
    let result: string[][] = [];
    let board: string[][] = Array.from({ length: n }, () => Array(n).fill('.'));

    function isSafe(board: string[][], row: number, col: number): boolean {
        for (let i = 0; i < col; i++) {
            if (board[row][i] === 'Q') return false;
        }
        for (let i = row, j = col; i >= 0 && j >= 0; i--, j--) {
            if (board[i][j] === 'Q') return false;
        }
        for (let i = row, j = col; i < n && j >= 0; i++, j--) {
            if (board[i][j] === 'Q') return false;
        }
        return true;
    }

    function solve(board: string[][], col: number) {
        if (col === n) {
            result.push(board.map(row => row.join('')));
            return;
        }
        for (let i = 0; i < n; i++) {
            if (isSafe(board, i, col)) {
                board[i][col] = 'Q';
                solve(board, col + 1);
                board[i][col] = '.';
            }
        }
    }

    solve(board, 0);
    return result;
}

console.log(solveNQueens(4));
// Output: [
//   [".Q..", "...Q", "Q...", "..Q."],
//   ["..Q.", "Q...", "...Q", ".Q.."]
// ]
```

</CodeGroup>

### **Sudoku Solver**

**Problem:**
Fill a 9×9 grid so that each row, each column, and each of the nine 3×3 grids contain all of the digits from 1 to 9.

**Step-by-Step Solution:**
1. Use a helper function to check if a number can be placed at a given position without violating Sudoku rules.
2. Recursively attempt to place numbers in empty cells.
3. Backtrack if placing a number leads to a conflict.

**Example:**

<CodeGroup>

```javascript
function solveSudoku(board) {
    function isValid(board, row, col, num) {
        for (let x = 0; x < 9; x++) {
            if (board[row][x] === num || board[x][col] === num ||
                board[Math.floor(row / 3) * 3 + Math.floor(x / 3)][Math.floor(col / 3) * 3 + x % 3] === num) {
                return false;
            }
        }
        return true;
    }

    function solve() {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === '.') {
                    for (let num = '1'; num <= '9'; num++) {
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (solve()) {
                                return true;
                            }
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    solve();
}

let board = [
    ["5", "3", ".", ".", "7", ".", ".", ".", "."],
    ["6", ".", ".", "1", "9", "5", ".", ".", "."],
    [".", "9", "8", ".", ".", ".", ".", "6", "."],
    ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
    ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
    ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
    [".", "6", ".", ".", ".", ".", "2", "8", "."],
    [".", ".", ".", "4", "1", "9", ".", ".", "5"],
    [".", ".", ".", ".", "8", ".", ".", "7", "9"]
];

solveSudoku(board);
console.log(board);
```

```typescript
function solveSudoku(board: string[][]): void {
    function isValid(board: string[][], row: number, col: number, num: string): boolean {
        for (let x = 0; x < 9; x++) {
            if (board[row][x] === num || board[x][col] === num ||
                board[Math.floor(row / 3) * 3 + Math.floor(x / 3)][Math.floor(col / 3) * 3 + x % 3] === num) {
                return false;
            }
        }
        return true;
    }

    function solve(): boolean {
        for (let row = 0; row < 9; row++) {
            for (let col = 0; col < 9; col++) {
                if (board[row][col] === '.') {
                    for (let num = '1'; num <= '9'; num++) {
                        if (isValid(board, row, col, num)) {
                            board[row][col] = num;
                            if (solve()) {
                                return true;
                            }
                            board[row][col] = '.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;
    }

    solve();
}

let board: string[][] = [
    ["5", "3", ".", ".", "7", ".", ".", ".", "."],
    ["6", ".", ".", "1", "9", "5", ".", ".", "."],
    [".", "9", "8", ".", ".", ".", ".", "6", "."],
    ["8", ".", ".", ".", "6", ".", ".", ".", "3"],
    ["4", ".", ".", "8", ".", "3", ".", ".", "1"],
    ["7", ".", ".", ".", "2", ".", ".", ".", "6"],
    [".", "6", ".", ".", ".", ".", "2", "8", "."],
    [".", ".", ".", "4", "1", "9", ".", ".", "5"],
    [".", ".", ".", ".", "8", ".", ".", "7", "9"]
];

solveSudoku(board);
console.log(board);
```

</CodeGroup>

### **Permutations**

**Problem:**
Generate all permutations of a given array of unique numbers.

**Step-by-Step Solution:**
1. Swap each element with the first element.
2. Recursively generate permutations for the remaining elements.
3. Backtrack by swapping elements back to their original positions.

**Example:**

<CodeGroup>

```javascript
function permute(nums) {
    let result = [];

    function backtrack(start) {
        if (start === nums.length) {
            result.push([...nums]);
            return;
        }
        for (let i = start; i < nums.length; i++) {
            [nums[start], nums[i]] = [nums[i], nums[start]];
            backtrack(start + 1);
            [nums[start], nums[i]] = [nums[i], nums[start]];
        }
    }

    backtrack(0);
    return result;
}

console.log(permute([1, 2, 3]));
// Output: [
//   [1, 2, 3],
//   [1, 3, 2],
//   [2, 1, 3],
//   [2, 3, 1],
//   [3, 2, 1],
//   [3, 1, 2]
// ]
```

```typescript
function permute(nums: number[]): number[][] {
    let result: number[][] = [];

    function backtrack(start: number) {
        if (start === nums.length) {
            result.push([...nums]);
            return;
        }
        for (let i = start; i < nums.length; i++) {
            [nums[start], nums[i]] = [nums[i], nums[start]];
            backtrack(start + 1);
            [nums[start], nums[i]] = [nums[i], nums[start]];
        }
    }

    backtrack(0);
    return result;
}

console.log(permute([1, 2, 3]));
// Output: [
//   [1, 2, 3],
//   [1, 3, 2],
//   [2, 1, 3],
//   [2, 3, 1],
//   [3, 2, 1],
//   [3, 1, 2]
// ]
```

</CodeGroup>


### **Subset Sum**

**Problem:**
Find all subsets of a given set that sum up to a target value.

**Step-by-Step Solution:**
1. Use a helper function to explore all subsets.
2. Add elements to the current subset and check if the target sum is reached.
3. Backtrack by removing the last element from the current subset.

**Example:**

<CodeGroup>

```javascript
function subsetSum(nums, target) {
    let result = [];

    function backtrack(start, path, sum) {
        if (sum === target) {
            result.push([...path]);
            return;
        }
        for (let i = start; i < nums.length; i++) {
            if (sum + nums[i] <= target) {
                path.push(nums[i]);
                backtrack(i + 1, path, sum + nums[i]);
                path.pop();
            }
        }
    }

    backtrack(0, [], 0);
    return result;
}

console.log(subsetSum([2, 3, 6, 7], 7));
// Output: [[7]]
```

```typescript
function subsetSum(nums: number[], target: number): number[][] {
    let result: number[][] = [];

    function backtrack(start: number, path: number[], sum: number) {
        if (sum === target) {
            result.push([...path]);
            return;
        }
        for (let i = start; i < nums.length; i++) {
            if (sum + nums[i] <= target) {
                path.push(nums[i]);
                backtrack(i + 1, path, sum + nums[i]);
                path.pop();
            }
        }
    }

    backtrack(0, [], 0);
    return result;
}

console.log(subsetSum([2, 3, 6, 7], 7));
// Output: [[7]]
```

</CodeGroup>

## **Practical Tips and Tricks**

- **Prune Early:**
  Stop exploring a path as soon as it is determined to be invalid to save time.
  
- **Use Constraints:**
  Apply constraints as early as possible to reduce the search space.

- **Track State Efficiently:**
  Use appropriate data structures to track the state (e.g., arrays, sets).

## **Common Gotchas**

- **Inefficient State Representation:**
  Ensure the state is represented efficiently to avoid unnecessary computations.

- **Deep Recursion:**
  Be cautious of stack overflow with deep recursion. Consider using iterative solutions if needed.

- **Incorrect Base Cases:**
  Ensure that base cases are correctly defined to avoid infinite loops or incorrect results.

## **Advanced Topics**

### **Hamiltonian Path**

**Problem:**
Find a path in a graph that visits each vertex exactly once.

**Step-by-Step Solution:**
1. Use a helper function to check if adding a vertex to the path is safe.
2. Recursively build the path, adding one vertex at a time.
3. Backtrack if adding a vertex leads to a conflict.

**Example:**

<CodeGroup>

```javascript
function hamiltonianPath(graph, V) {
    let path = Array(V).fill(-1);
    path[0] = 0;

    function isSafe(v, pos) {
        if (!graph[path[pos - 1]][v]) return false;
        for (let i = 0; i < pos; i++) {
            if (path[i] === v) return false;
        }
        return true;
    }

    function solve(pos) {
        if (pos === V) return true;
        for (let v = 1; v < V; v++) {
            if (isSafe(v, pos)) {
                path[pos] = v;
                if (solve(pos + 1)) return true;
                path[pos] = -1;
            }
        }
        return false;
    }

    if (!solve(1)) {
        console.log('No Hamiltonian Path found');
        return false;
    }

    console.log('Hamiltonian Path:', path);
    return true;
}

let graph = [
    [0, 1, 1, 1, 0, 0, 0, 0],
    [1, 0, 1, 0, 1, 0, 0, 0],
    [1, 1, 0, 1, 1, 1, 0, 0],
    [1, 0, 1, 0, 0, 1, 0, 0],
    [0, 1, 1, 0, 0, 1, 1, 0],
    [0, 0, 1, 1, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 1, 0, 1],
    [0, 0, 0, 0, 0, 1, 1, 0]
];
hamiltonianPath(graph, 8);
```

```typescript
function hamiltonianPath(graph: number[][], V: number): boolean {
    let path: number[] = Array(V).fill(-1);
    path[0] = 0;

    function isSafe(v: number, pos: number): boolean {
        if (!graph[path[pos - 1]][v]) return false;
        for (let i = 0; i < pos; i++) {
            if (path[i] === v) return false;
        }
        return true;
    }

    function solve(pos: number): boolean {
        if (pos === V) return true;
        for (let v = 1; v < V; v++) {
            if (isSafe(v, pos)) {
                path[pos] = v;
                if (solve(pos + 1)) return true;
                path[pos] = -1;
            }
        }
        return false;
    }

    if (!solve(1)) {
        console.log('No Hamiltonian Path found');
        return false;
    }

    console.log('Hamiltonian Path:', path);
    return true;
}

let graph: number[][] = [
    [0, 1, 1, 1, 0, 0, 0, 0],
    [1, 0, 1, 0, 1, 0, 0, 0],
    [1, 1, 0, 1, 1, 1, 0, 0],
    [1, 0, 1, 0, 0, 1, 0, 0],
    [0, 1, 1, 0, 0, 1, 1, 0],
    [0, 0, 1, 1, 1, 0, 1, 1],
    [0, 0, 0, 0, 1, 1, 0, 1],
    [0, 0, 0, 0, 0, 1, 1, 0]
];
hamiltonianPath(graph, 8);
```

</CodeGroup>

### **Word Search in a Grid**

**Problem:**
Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where "adjacent" cells are horizontally or vertically neighboring.

**Step-by-Step Solution:**
1. Use a helper function to check if the word can be formed starting from a given cell.
2. Recursively check all neighboring cells to form the word.
3. Backtrack by unmarking the cell.

**Example:**

<CodeGroup>

```javascript
function exist(board, word) {
    let rows = board.length;
    let cols = board[0].length;

    function dfs(row, col, index) {
        if (index === word.length) return true;
        if (row < 0 || row >= rows || col < 0 || col >= cols || board[row][col] !== word[index]) return false;

        let temp = board[row][col];
        board[row][col] = '#';

        let found = dfs(row + 1, col, index + 1) ||
                    dfs(row - 1, col, index + 1) ||
                    dfs(row, col + 1, index + 1) ||
                    dfs(row, col - 1, index + 1);

        board[row][col] = temp;
        return found;
    }

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (board[row][col] === word[0] && dfs(row, col, 0)) {
                return true;
            }
        }
    }

    return false;
}

let board = [
    ['A', 'B', 'C', 'E'],
    ['S', 'F', 'C', 'S'],
    ['A', 'D', 'E', 'E']
];
console.log(exist(board, 'ABCCED'));  // Output: true
console.log(exist(board, 'SEE'));     // Output: true
console.log(exist(board, 'ABCB'));    // Output: false
```

```typescript
function exist(board: string[][], word: string): boolean {
    let rows: number = board.length;
    let cols: number = board[0].length;

    function dfs(row: number, col: number, index: number): boolean {
        if (index === word.length) return true;
        if (row < 0 || row >= rows || col < 0 || col >= cols || board[row][col] !== word[index]) return false;

        let temp: string = board[row][col];
        board[row][col] = '#';

        let found: boolean = dfs(row + 1, col, index + 1) ||
                    dfs(row - 1, col, index + 1) ||
                    dfs(row, col + 1, index + 1) ||
                    dfs(row, col - 1, index + 1);

        board[row][col] = temp;
        return found;
    }

    for (let row: number = 0; row < rows; row++) {
        for (let col: number = 0; col < cols; col++) {
            if (board[row][col] === word[0] && dfs(row, col, 0)) {
                return true;
            }
        }
    }

    return false;
}

let board: string[][] = [
    ['A', 'B', 'C', 'E'],
    ['S', 'F', 'C', 'S'],
    ['A', 'D', 'E', 'E']
];
console.log(exist(board, 'ABCCED'));  // Output: true
console.log(exist(board, 'SEE'));     // Output: true
console.log(exist(board, 'ABCB'));    // Output: false
```

</CodeGroup>

## **Interview Tips and Tricks**

- **Start Simple:**
  Begin with simple cases and gradually build up to more complex ones.

- **Explain Your Approach:**
  Clearly explain your approach and reasoning during interviews.

- **Use Examples:**
  Use examples to illustrate your approach and verify your solution.

- **Optimize:**
  Look for ways to prune the search space and optimize your solution.

## **Common Mistakes**

- **Incorrect Base Cases:**
  Ensure that base cases are defined correctly to avoid infinite loops or incorrect results.

- **Overlooking Constraints:**
  Apply constraints as early as possible to reduce the search space.

- **State Tracking:**
  Properly manage the state (e.g., marking/unmarking cells in grid problems).

By mastering backtracking and understanding its intricacies, you will be well-equipped to handle a variety of combinatorial and constraint satisfaction problems. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.