export const metadata = {
  title: 'Comprehensive Guide to JavaScript Objects',
  description: 'Discover object properties and how to work with objects in JavaScript. Understand object creation, manipulation, performance considerations, and practical examples.',
}

# **JavaScript Objects**

Objects in JavaScript are a fundamental data type used to store collections of key-value pairs. They are a powerful and flexible data structure that allows for complex data management and manipulation.

## **Concept and Use Cases**

**Definition:**
A JavaScript object is a mutable collection of key-value pairs, where each key (property name) is a string (or Symbol), and each value can be any data type, including another object or function.

**Common Use Cases:**
- Storing and organizing related data.
- Representing entities in applications (e.g., user profiles, product information).
- Implementing data structures like hash maps.
- Configuration objects for settings and options.

## **When to Use**
- When you need to store and manage collections of related data.
- When you require dynamic properties that can be added or removed.
- When you need to represent real-world entities with attributes and behaviors.

## **Time and Space Complexity**

**Time Complexity:**
- Access by key: O(1)
- Insertion/Deletion by key: O(1)
- Iteration: O(n)

**Space Complexity:**
- O(n), where n is the number of properties in the object.

## **Object Operations and Methods**

### **Creating Objects**

**Example:**

<CodeGroup>

```javascript
let emptyObject = {};
let person = {
    name: 'John',
    age: 30,
    isEmployed: true,
    hobbies: ['reading', 'travelling'],
    address: {
        street: '123 Main St',
        city: 'Anytown',
        zip: '12345'
    }
};
```

```typescript
interface Address {
    street: string;
    city: string;
    zip: string;
}

interface Person {
    name: string;
    age: number;
    isEmployed: boolean;
    hobbies: string[];
    address: Address;
}

let person: Person = {
    name: 'John',
    age: 30,
    isEmployed: true,
    hobbies: ['reading', 'travelling'],
    address: {
        street: '123 Main St',
        city: 'Anytown',
        zip: '12345'
    }
};
```

</CodeGroup>

### **Accessing Properties**

**Example:**

<CodeGroup>

```javascript
let person = {
    name: 'John',
    age: 30,
    isEmployed: true
};

console.log(person.name);  // Output: 'John'
console.log(person['age']);  // Output: 30
```

```typescript
interface Person {
    name: string;
    age: number;
    isEmployed: boolean;
}

let person: Person = {
    name: 'John',
    age: 30,
    isEmployed: true
};

console.log(person.name);  // Output: 'John'
console.log(person['age']);  // Output: 30
```

</CodeGroup>

### **Modifying Properties**

**Example:**

<CodeGroup>

```javascript
let person = {
    name: 'John',
    age: 30
};

person.age = 31;
person['isEmployed'] = true;
console.log(person);  // Output: {name: 'John', age: 31, isEmployed: true}
```

```typescript
interface Person {
    name: string;
    age: number;
    isEmployed?: boolean;
}

let person: Person = {
    name: 'John',
    age: 30
};

person.age = 31;
person['isEmployed'] = true;
console.log(person);  // Output: {name: 'John', age: 31, isEmployed: true}
```

</CodeGroup>

### **Adding and Removing Properties**

**Example:**

<CodeGroup>

```javascript
let person = {
    name: 'John'
};

person.age = 30;  // Adding a property
console.log(person);  // Output: {name: 'John', age: 30}

delete person.age;  // Removing a property
console.log(person);  // Output: {name: 'John'}
```

```typescript
interface Person {
    name: string;
    age?: number;
}

let person: Person = {
    name: 'John'
};

person.age = 30;  // Adding a property
console.log(person);  // Output: {name: 'John', age: 30}

delete person.age;  // Removing a property
console.log(person);  // Output: {name: 'John'}
```

</CodeGroup>

### **Checking Property Existence**

**Example:**

<CodeGroup>

```javascript
let person = {
    name: 'John'
};

console.log('name' in person);  // Output: true
console.log('age' in person);  // Output: false
```

```typescript
interface Person {
    name: string;
    age?: number;
}

let person: Person = {
    name: 'John'
};

console.log('name' in person);  // Output: true
console.log('age' in person);  // Output: false
```

</CodeGroup>

### **Iterating Over Properties**

**Example:**

<CodeGroup>

```javascript
let person = {
    name: 'John',
    age: 30,
    isEmployed: true
};

for (let key in person) {
    if (person.hasOwnProperty(key)) {
        console.log(`${key}: ${person[key]}`);
    }
}

// Output:
// name: John
// age: 30
// isEmployed: true
```

```typescript
interface Person {
    name: string;
    age: number;
    isEmployed: boolean;
}

let person: Person = {
    name: 'John',
    age: 30,
    isEmployed: true
};

for (let key in person) {
    if (person.hasOwnProperty(key)) {
        console.log(`${key}: ${person[key]}`);
    }
}

// Output:
// name: John
// age: 30
// isEmployed: true
```

</CodeGroup>

### **Object Methods**

**Example:**

<CodeGroup>

```javascript
let person = {
    name: 'John',
    age: 30,
    greet: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

person.greet();  // Output: 'Hello, my name is John'
```

```typescript
interface Person {
    name: string;
    age: number;
    greet: () => void;
}

let person: Person = {
    name: 'John',
    age: 30,
    greet: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

person.greet();  // Output: 'Hello, my name is John'
```

</CodeGroup>

### **Object Utility Methods**

**Example:**

<CodeGroup>

```javascript
let person = {
    name: 'John',
    age: 30,
    isEmployed: true
};

console.log(Object.keys(person));  // Output: ['name', 'age', 'isEmployed']
console.log(Object.values(person));  // Output: ['John', 30, true]
console.log(Object.entries(person));  // Output: [['name', 'John'], ['age', 30], ['isEmployed', true]]

let newPerson = Object.assign({}, person, {age: 31});
console.log(newPerson);  // Output: {name: 'John', age: 31, isEmployed: true}

let personCopy = {...person};
console.log(personCopy);  // Output: {name: 'John', age: 30, isEmployed: true}
```

```typescript
interface Person {
    name: string;
    age: number;
    isEmployed: boolean;
}

let person: Person = {
    name: 'John',
    age: 30,
    isEmployed: true
};

console.log(Object.keys(person));  // Output: ['name', 'age', 'isEmployed']
console.log(Object.values(person));  // Output: ['John', 30, true]
console.log(Object.entries(person));  // Output: [['name', 'John'], ['age', 30], ['isEmployed', true]]

let newPerson = Object.assign({}, person, {age: 31});
console.log(newPerson);  // Output: {name: 'John', age: 31, isEmployed: true}

let personCopy: Person = {...person};
console.log(personCopy);  // Output: {name: 'John', age: 30, isEmployed: true}
```

</CodeGroup>

## **Practical Tips and Tricks**

- **Using `Object.freeze` to Make Objects Immutable:**
  Prevent modifications to an object.

  **Example:**

  <CodeGroup>

  ```javascript
  let person = {name: 'John'};
  Object.freeze(person);
  person.age = 30;  // This will not work
  console.log(person);  // Output: {name: 'John'}
  ```

  ```typescript
  interface Person {
      name: string;
      age?: number;
  }

  let person: Person = {name: 'John'};
  Object.freeze(person);
  person.age = 30;  // This will not work
  console.log(person);  // Output: {name: 'John'}
  ```
  
  </CodeGroup>

- **Cloning Objects:**
  Use `Object.assign` or the spread operator to create shallow copies.

  **Example:**

  <CodeGroup>

  ```javascript
  let original = {a: 1, b: 2};
  let copy = Object.assign({}, original);
  let spreadCopy = {...original};
  console.log(copy);  // Output: {a: 1, b: 2}
  console.log(spreadCopy);  // Output: {a: 1, b: 2}
  ```

  ```typescript
  interface Original {
      a: number;
      b: number;
  }

  let original: Original = {a: 1, b: 2};
  let copy = Object.assign({}, original);
  let spreadCopy: Original = {...original};
  console.log(copy);  // Output: {a: 1, b: 2}
  console.log(spreadCopy);  // Output: {a: 1, b: 2}
  ```
  
  </CodeGroup>

- **Merging Objects:**
  Combine properties from multiple objects.

  **Example:**

  <CodeGroup>

  ```javascript
  let obj1 = {a: 1};
  let obj2 = {b: 2};
  let merged = {...obj1, ...obj2};
  console.log(merged);  // Output: {a: 1, b: 2}
  ```

  ```typescript
  interface Obj1 {
      a: number;
  }

  interface Obj2 {
      b: number;
  }

  let obj1: Obj1 = {a: 1};
  let obj2: Obj2 = {b: 2};
  let merged = {...obj1, ...obj2};
  console.log(merged);  // Output: {a: 1, b: 2}
  ```
  
  </CodeGroup>

- **Nested Object Updates:**
  Use the spread operator for nested object updates.

  **Example:**

  <CodeGroup>

  ```javascript
  let person = {
      name: 'John',
      address: {
          city: 'Anytown',
          zip: '12345'
      }
  };
  let updatedPerson = {
      ...person,
      address: {
          ...person.address,
          city: 'Newtown'
      }
  };
  console.log(updatedPerson);
  // Output: {name: 'John', address: {city: 'Newtown', zip: '12345'}}
  ```

  ```typescript
  interface Address {
      city: string;
      zip: string;
  }

  interface Person {
      name: string;
      address: Address;
  }

  let person: Person = {
      name: 'John',
      address: {
          city: 'Anytown',
          zip: '12345'
      }
  };

  let updatedPerson: Person = {
      ...person,
      address: {
          ...person.address,
          city: 'Newtown'
      }
  };
  console.log(updatedPerson);
  // Output: {name: 'John', address: {city: 'Newtown', zip: '12345'}}
  ```
  
  </CodeGroup>

## **Common Gotchas**

- **Shallow Copy vs. Deep Copy:**
  `Object.assign` and the spread operator create shallow copies, not deep copies.

  **Example:**

  <CodeGroup>

  ```javascript
  let original = {a: 1, b: {c: 2}};
  let copy = {...original};
  copy.b.c = 3;
  console.log(original.b.c);  // Output: 3 (original object is affected)
  ```

  ```typescript
  interface Original {
      a: number;
      b: {
          c: number;
      }
  }

  let original: Original = {a: 1, b: {c: 2}};
  let copy: Original = {...original};
  copy.b.c = 3;
  console.log(original.b.c);  // Output: 3 (original object is affected)
  ```
  
  </CodeGroup>

- **Property Enumeration Order:**
  The order of property enumeration is not guaranteed in older JavaScript engines.

  **Example:**

  <CodeGroup>

  ```javascript
  let obj = {b: 1, a: 2};
  console.log(Object.keys(obj));  // Output: ['b', 'a'] (order may vary)
  ```

  ```typescript
  interface Obj {
      b: number;
      a: number;
  }

  let obj: Obj = {b: 1, a: 2};
  console.log(Object.keys(obj));  // Output: ['b', 'a'] (order may vary)
  ```
  
  </CodeGroup>

- **Prototype Pollution:**
  Be cautious when merging or extending objects to avoid unintended prototype changes.

  **Example:**

  <CodeGroup>

  ```javascript
  let obj = {};
  Object.prototype.newProp = 'polluted';
  console.log(obj.newProp);  // Output: 'polluted' (unintended prototype property)
  ```
  
  ```typescript
  let obj = {} as { newProp?: string} ;
  (Object.prototype as { newProp?: string }).newProp = 'polluted'
  console.log(obj.newProp) // Output: 'polluted' (unintended prototype property)
  ```
  
  </CodeGroup>

## **Advanced Topics**

### **Prototype and Inheritance**

Objects in JavaScript have a prototype, which is another object from which they inherit properties and methods.

**Example:**

<CodeGroup>

```javascript
let person = {
    greet: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

let john = Object.create(person);
john.name = 'John';
john.greet();  // Output: 'Hello, my name is John'
```

```typescript
interface Person {
    greet: () => void;
}

let person: Person = {
    greet: function() {
        console.log(`Hello, my name is ${this.name}`);
    }
};

let john = Object.create(person);
john.name = 'John';
john.greet();  // Output: 'Hello, my name is John'
```

</CodeGroup>

### **Object-Oriented Programming (OOP)**

JavaScript supports OOP through constructor functions and ES6 classes.

**Example:**

<CodeGroup>

```javascript

// Constructor Function
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name}`);
};

let john = new Person('John', 30);
john.greet();  // Output: 'Hello, my name is John'

// ES6 Class
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

let jane = new Person('Jane', 25);
jane.greet();  // Output: 'Hello, my name is Jane'
```

```typescript

// Constructor Function
class Person {
    name: string;
    age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

let john = new Person('John', 30);
john.greet();  // Output: 'Hello, my name is John'

// ES6 Class
class Person {
    name: string;
    age: number;

    constructor(name: string, age: number) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

let jane = new Person('Jane', 25);
jane.greet();  // Output: 'Hello, my name is Jane'
```

</CodeGroup>

### **Symbols**

Symbols are a unique and immutable data type used as property keys.

**Example:**

<CodeGroup>

```javascript
let sym = Symbol('description');
let obj = {
    [sym]: 'value'
};
console.log(obj[sym]);  // Output: 'value'
```

```typescript
let sym = Symbol('description');
let obj = {
    [sym]: 'value'
};
console.log(obj[sym]);  // Output: 'value'
```

</CodeGroup>

### **Private Properties**

Using closures or `#` syntax (private class fields) to create private properties.

**Example:**

<CodeGroup>

```javascript
class Person {
    #name;

    constructor(name) {
        this.#name = name;
    }

    greet() {
        console.log(`Hello, my name is ${this.#name}`);
    }
}

let john = new Person('John');
john.greet();  // Output: 'Hello, my name is John'
// console.log(john.#name);  // SyntaxError: Private field '#name' must be declared in an enclosing class
```

```typescript
class Person {
    #name: string;

    constructor(name: string) {
        this.#name = name;
    }

    greet() {
        console.log(`Hello, my name is ${this.#name}`);
    }
}

let john = new Person('John');
john.greet();  // Output: 'Hello, my name is John'
// console.log(john.#name);  // SyntaxError: Private field '#name' must be declared in an enclosing class
```

</CodeGroup>

## **Object Algorithms**
Below are some common object algorithms you should be familiar with:

### **Deep Cloning**
Deep cloning creates a complete copy of an object, including all nested objects and arrays.

**Example:**

<CodeGroup>

```javascript
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item));
    }
    let clone = {};
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            clone[key] = deepClone(obj[key]);
        }
    }
    return clone;
}

let original = {a: 1, b: {c: 2}};
let copy = deepClone(original);
copy.b.c = 3;
console.log(original.b.c);  // Output: 2 (original object is not affected)
```

```typescript
function deepClone<T>(obj: T): T {
    if (obj === null || typeof obj !== 'object') return obj;
    if (Array.isArray(obj)) {
        return obj.map(item => deepClone(item)) as unknown as T;
    }
    let clone = {} as T;
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            (clone)[key] = deepClone((obj)[key]);
        }
    }
    return clone;
}

let original = {a: 1, b: {c: 2}};
let copy = deepClone(original);
copy.b.c = 3;
console.log(original.b.c);  // Output: 2 (original object is not affected)
```

</CodeGroup>

### **Merging Objects Recursively**
Merging objects recursively combines properties of multiple objects into one, including nested objects.

**Example:**

<CodeGroup>

```javascript
function mergeDeep(target, source) {
    if (typeof target !== 'object' || typeof source !== 'object') return source;

    for (let key in source) {
        if (source.hasOwnProperty(key)) {
            if (typeof source[key] === 'object' && source[key] !== null) {
                target[key] = mergeDeep(target[key] || {}, source[key]);
            } else {
                target[key] = source[key];
            }
        }
    }
    return target;
}

let obj1 = { a: 1, b: { c: 2 } };
let obj2 = { b: { d: 3 } };
let merged = mergeDeep(obj1, obj2);
console.log(merged);  // Output: { a: 1, b: { c: 2, d: 3 } }
```

```typescript
type AnyObject = Record<string, unknown>;

function isObject(item: unknown): item is AnyObject {
    return item !== null && typeof item === 'object' && !Array.isArray(item);
}

function mergeDeep<T extends AnyObject, U extends AnyObject>(target: T, source: U): T & U {
    if (!isObject(target) || !isObject(source)) return source as T & U;

    const output = { ...target } as T & U;

    for (const key in source) {
        if (source.hasOwnProperty(key)) {
            if (isObject(source[key])) {
                if (key in target) {
                    (output as AnyObject)[key] = mergeDeep(
                        (target as AnyObject)[key] as AnyObject,
                        source[key] as AnyObject
                    );
                } else {
                    (output as AnyObject)[key] = source[key];
                }
            } else {
                (output as AnyObject)[key] = source[key];
            }
        }
    }
    return output;
}

let obj1 = { a: 1, b: { c: 2 } };
let obj2 = { b: { d: 3 } };

let merged = mergeDeep(obj1, obj2);
console.log(merged); // Output: { a: 1, b: { c: 2, d: 3 } }
```

</CodeGroup>

## **Interview Tips and Tricks**

- **Understand Prototypes:**
  Have a solid understanding of prototype inheritance and how it works in JavaScript.

- **Practice Object Methods:**
  Be comfortable with methods like `Object.keys`, `Object.values`, `Object.entries`, and `Object.assign`.

- **Handle Edge Cases:**
  Consider scenarios with nested objects, circular references, and merging objects with conflicting properties.

- **Use Symbols for Unique Keys:**
  Utilize Symbols when you need unique keys that won't collide with other property keys.

## **Common Mistakes**

- **Overwriting Prototype Methods:**
  Be cautious when modifying prototypes, as it affects all instances of the object.

- **Using `for...in` Without `hasOwnProperty`:**
  Always check `hasOwnProperty` to avoid iterating over inherited properties.

- **Shallow vs. Deep Copy Confusion:**
  Understand the difference between shallow and deep copies, especially when dealing with nested objects.

- **Accidental Global Variables:**
  Avoid creating global variables by using `var`, `let`, or `const` to declare properties.

By mastering JavaScript objects and understanding their intricacies, you will be well-equipped to handle a variety of interview questions and real-world problems involving structured data. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.