export const metadata = {
  title: 'Comprehensive Guide to Bit Manipulation in JavaScript',
  description: 'Perform operations directly on binary representations of numbers. Understand bit manipulation techniques, performance considerations, and practical examples.',
}

# **Bit Manipulation**

Bit manipulation involves directly working with the binary representations of numbers. This technique is crucial for optimizing performance, solving certain types of problems efficiently, and understanding how data is processed at the lowest level.

## **Concept and Use Cases**

### **Definition:**
Bit manipulation refers to the act of algorithmically manipulating bits or binary digits, which are the most basic form of data in computing and digital communications.

### **Common Use Cases:**
- Efficiently performing arithmetic operations
- Optimizing space and time complexity
- Cryptography and encoding
- Network programming
- Competitive programming

### **Visual Representation:**
Consider a number `5` in binary form:
```
Decimal: 5
Binary: 0101
```
Common bit manipulation operations can be visualized as changes to the individual bits of this binary representation.

## **Key Bitwise Operators**

JavaScript provides several bitwise operators that allow direct manipulation of bits:

1. **AND (`&`)**: Sets each bit to 1 if both bits are 1.
   
  <CodeGroup>

  ```javascript
  console.log(5 & 3); // Output: 1 (0101 & 0011 = 0001)
  ```

  ```typescript
  console.log(5 & 3); // Output: 1 (0101 & 0011 = 0001)
  ```

  </CodeGroup>

2. **OR (`|`)**: Sets each bit to 1 if one of two bits is 1.

  <CodeGroup>

  ```javascript
  console.log(5 | 3); // Output: 7 (0101 | 0011 = 0111)
  ```

  ```typescript
  console.log(5 | 3); // Output: 7 (0101 | 0011 = 0111)
  ```

  </CodeGroup>

3. **XOR (`^`)**: Sets each bit to 1 if only one of two bits is 1.

  <CodeGroup>

  ```javascript
  console.log(5 ^ 3); // Output: 6 (0101 ^ 0011 = 0110)
  ```

  ```typescript
  console.log(5 ^ 3); // Output: 6 (0101 ^ 0011 = 0110)
  ```

  </CodeGroup>

4. **NOT (`~`)**: Inverts all the bits.

  <CodeGroup>

  ```javascript
  console.log(~5); // Output: -6 (~0105 = 1010 in 2's complement form)
  ```

  ```typescript
  console.log(~5); // Output: -6 (~0101 = 1010 in 2's complement form)
  ```

  </CodeGroup>

5. **Left Shift (`<<`)**: Shifts bits to the left, filling with zeros.

  <CodeGroup>

  ```javascript
  console.log(5 << 1); // Output: 10 (0101 << 1 = 1010)
  ```

  ```typescript
  console.log(5 << 1); // Output: 10 (0101 << 1 = 1010)
  ```

  </CodeGroup>

6. **Right Shift (`>>`)**: Shifts bits to the right, filling with the sign bit.

  <CodeGroup>

  ```javascript
  console.log(5 >> 1); // Output: 2 (0101 >> 1 = 0010)
  ```

  ```typescript
  console.log(5 >> 1); // Output: 2 (0101 >> 1 = 0010)
  ```

  </CodeGroup>

7. **Unsigned Right Shift (`>>>`)**: Shifts bits to the right, filling with zeros.

  <CodeGroup>

  ```javascript
  console.log(5 >>> 1); // Output: 2 (0101 >>> 1 = 0010)
  ```

  ```typescript
  console.log(5 >>> 1); // Output: 2 (0101 >>> 1 = 0010)
  ```

  </CodeGroup>

## **Practical Examples**

### **Checking if a Number is Even or Odd**
Using the AND operator, you can quickly check if a number is even or odd.

<CodeGroup>

```javascript
function isEven(num) {
  return (num & 1) === 0;
}

console.log(isEven(4)); // Output: true
console.log(isEven(7)); // Output: false
```

```typescript
function isEven(num: number): boolean {
  return (num & 1) === 0;
}

console.log(isEven(4)); // Output: true
console.log(isEven(7)); // Output: false
```

</CodeGroup>

### **Swapping Two Numbers Without a Temporary Variable**
Using XOR, you can swap two numbers in place.

<CodeGroup>

```javascript
function swap(a, b) {
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;
  return [a, b];
}

let [a, b] = swap(5, 7);
console.log(a, b); // Output: 7, 5
```

```typescript
function swap(a: number, b: number): [number, number] {
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;
  return [a, b];
}

let [a, b] = swap(5, 7);
console.log(a, b); // Output: 7, 5
```

</CodeGroup>

### **Counting the Number of 1s in a Binary Representation (Hamming Weight)**
Using bitwise AND and right shift.

<CodeGroup>

```javascript
function hammingWeight(num) {
  let count = 0;
  while (num !== 0) {
    count += num & 1;
    num >>= 1;
  }
  return count;
}

console.log(hammingWeight(5)); // Output: 2 (0101 has two 1s)
```

```typescript
function hammingWeight(num: number): number {
  let count = 0;
  while (num !== 0) {
    count += num & 1;
    num >>= 1;
  }
  return count;
}

console.log(hammingWeight(5)); // Output: 2 (0101 has two 1s)
```

</CodeGroup>

### **Finding the Only Non-Repeating Element**
In an array where every element repeats twice except for one, XOR can find the unique element.

<CodeGroup>

```javascript
function findUnique(arr) {
  return arr.reduce((acc, num) => acc ^ num, 0);
}

console.log(findUnique([2, 3, 5, 4, 5, 3, 4])); // Output: 2
```

```typescript
function findUnique(arr: number[]): number {
  return arr.reduce((acc, num) => acc ^ num, 0);
}

console.log(findUnique([2, 3, 5, 4, 5, 3, 4])); // Output: 2
```

</CodeGroup>

### **Detecting Power of Two**
To check if a number is a power of two, you can use the following bit manipulation trick.

<CodeGroup>

```javascript
function isPowerOfTwo(num) {
  return num > 0 && (num & (num - 1)) === 0;
}

console.log(isPowerOfTwo(4)); // Output: true
console.log(isPowerOfTwo(7)); // Output: false
```

```typescript
function isPowerOfTwo(num: number): boolean {
  return num > 0 && (num & (num - 1)) === 0;
}

console.log(isPowerOfTwo(4)); // Output: true
console.log(isPowerOfTwo(7)); // Output: false
```

</CodeGroup>

### **Counting Bits to Convert One Number to Another**
Calculate the number of bits needed to convert integer `a` to integer `b`.

<CodeGroup>

```javascript
function bitSwapRequired(a, b) {
  let count = 0;
  for (let c = a ^ b; c !== 0; c = c >> 1) {
    count += c & 1;
  }
  return count;
}

console.log(bitSwapRequired(29, 15)); // Output: 2
```

```typescript
function bitSwapRequired(a: number, b: number): number {
  let count = 0;
  for (let c = a ^ b; c !== 0; c = c >> 1) {
    count += c & 1;
  }
  return count;
}

console.log(bitSwapRequired(29, 15)); // Output: 2
```

</CodeGroup>

### **Reverse Bits of a Number**
Reverse the bits of an integer.

<CodeGroup>

```javascript
function reverseBits(num) {
  let result = 0;
  for (let i = 0; i < 32; i++) {
    result = (result << 1) | (num & 1);
    num >>= 1;
  }
  return result >>> 0; // Ensure unsigned result
}

console.log(reverseBits(43261596)); // Output: 964176192
```

```typescript
function reverseBits(num: number): number {
  let result = 0;
  for (let i = 0; i < 32; i++) {
    result = (result << 1) | (num & 1);
    num >>= 1;
  }
  return result >>> 0; // Ensure unsigned result
}

console.log(reverseBits(43261596)); // Output: 964176192
```

</CodeGroup>

### **Extracting the Lowest Set Bit**
To isolate the lowest set bit of a number.

<CodeGroup>

```javascript
function lowestSetBit(num) {
  return num & -num;
}

console.log(lowestSetBit(18)); // Output: 2 (0010)
```

```typescript
function lowestSetBit(num: number): number {
  return num & -num;
}

console.log(lowestSetBit(18)); // Output: 2 (0010)
```

</CodeGroup>

### **Clearing the Lowest Set Bit**
To clear the lowest set bit.

<CodeGroup>

```javascript
function clearLowestSetBit(num) {
  return num & (num - 1);
}

console.log(clearLowestSetBit(18)); // Output: 16 (10010 -> 10000)
```

```typescript
function clearLowestSetBit(num: number): number {
  return num & (num - 1);
}

console.log(clearLowestSetBit(18)); // Output: 16 (10010 -> 10000)
```

</CodeGroup>

### **Toggle All Bits After the Rightmost 1-bit**
To toggle all bits after the rightmost 1-bit (inclusive).

<CodeGroup>

```javascript
function toggleBitsAfterRightmostOne(num) {
  return num ^ (num & -num);
}

console.log(toggleBitsAfterRightmostOne(18)); // Output: 16 (10010 -> 10000)
```

```typescript
function toggleBitsAfterRightmostOne(num: number): number {
  return num ^ (num & -num);
}

console.log(toggleBitsAfterRightmostOne(18)); // Output: 16 (10010 -> 10000)
```

</CodeGroup>


## **Tips and Tricks**

1. **Use Masks for Specific Bits**: Masks can isolate or modify specific bits in a number.
   
  <CodeGroup>

  ```javascript
  let mask = 1 << 3; // Mask to check the 4th bit (counting from 0)
  console.log((5 & mask) !== 0); // Check if the 4th bit is set
  ```

  ```typescript
  let mask: number = 1 << 3; // Mask to check the 4th bit (counting from 0)
  console.log((5 & mask) !== 0); // Check if the 4th bit is set
  ```

  </CodeGroup>

2. **Toggle Bits**: XOR with a mask to toggle specific bits.

  <CodeGroup>

  ```javascript
  let num = 5; // 0101
  let mask = 1 << 1; // Toggle the 2nd bit
  num ^= mask;
  console.log(num); // Output: 7 (0111)
  ```

  ```typescript
  let num: number = 5; // 0101
  let mask: number = 1 << 1; // Toggle the 2nd bit
  num ^= mask;
  console.log(num); // Output: 7 (0111)
  ```

  </CodeGroup>

3. **Clearing Bits**: Use AND with the complement of a mask to clear specific bits.

  <CodeGroup>

  ```javascript
  let num = 7; // 0111
  let mask = ~(1 << 1); // Clear the 2nd bit
  num &= mask;
  console.log(num); // Output: 5 (0101)
  ```

  ```typescript
  let num: number = 7; // 0111
  let mask: number = ~(1 << 1); // Clear the 2nd bit
  num &= mask;
  console.log(num); // Output: 5 (0101)
  ```

  </CodeGroup>

  4. **Setting Bits**: Use OR with a mask to set specific bits.

  <CodeGroup>

  ```javascript
  let num = 5; // 0101
  let mask = 1 << 2; // Set the 3rd bit
  num |= mask;
  console.log(num); // Output: 13 (1101)
  ```

  ```typescript
  let num: number = 5; // 0101
  let mask: number = 1 << 2; // Set the 3rd bit
  num |= mask;
  console.log(num); // Output: 13 (1101)
  ```

  </CodeGroup>

5. **Conditional Bit Manipulation**: Combine shifts and masks for conditional manipulations.

  <CodeGroup>

  ```javascript
  function conditionalSetBit(num, bitIndex, condition) {
    let mask = 1 << bitIndex;
    return condition ? (num | mask) : (num & ~mask);
  }

  console.log(conditionalSetBit(5, 1, true)); // Output: 7 (0101 -> 0111)
  console.log(conditionalSetBit(5, 1, false)); // Output: 5 (0101 -> 0101)
  ```

  ```typescript
  function conditionalSetBit(num: number, bitIndex: number, condition: boolean): number {
    let mask: number = 1 << bitIndex;
    return condition ? (num | mask) : (num & ~mask);
  }

  console.log(conditionalSetBit(5, 1, true)); // Output: 7 (0101 -> 0111)
  console.log(conditionalSetBit(5, 1, false)); // Output: 5 (0101 -> 0101)
  ```

  </CodeGroup>

6. **Counting Set Bits Efficiently**: Brian Kernighanâ€™s Algorithm.

  <CodeGroup>

  ```javascript
  function countSetBits(num) {
    let count = 0;
    while (num) {
      num &= (num - 1);
      count++;
    }
    return count;
  }

  console.log(countSetBits(7)); // Output: 3 (0111 has three 1s)
  ```

  ```typescript
  function countSetBits(num: number): number {
    let count: number = 0;
    while (num) {
      num &= (num - 1);
      count++;
    }
    return count;
  }

  console.log(countSetBits(7)); // Output: 3 (0111 has three 1s)
  ```

  </CodeGroup>

7. **Circular Shifts**: Implement circular left and right shifts.

  <CodeGroup>

  ```javascript
  function circularLeftShift(num, shift) {
    return (num << shift) | (num >>> (32 - shift));
  }

  function circularRightShift(num, shift) {
    return (num >>> shift) | (num << (32 - shift));
  }

  console.log(circularLeftShift(5, 2)); // Output: 20 (0101 -> 10100)
  console.log(circularRightShift(5, 2)); // Output: 1073741821 (0101 -> 1100...01)
  ```

  ```typescript
  function circularLeftShift(num: number, shift: number): number {
    return (num << shift) | (num >>> (32 - shift));
  }

  function circularRightShift(num: number, shift: number): number {
    return (num >>> shift) | (num << (32 - shift));
  }

  console.log(circularLeftShift(5, 2)); // Output: 20 (0101 -> 10100)
  console.log(circularRightShift(5, 2)); // Output: 1073741821 (0101 -> 1100...01)
  ```

  </CodeGroup>

## **Common Gotchas**

1. **Sign Bit**: Be aware of the sign bit when performing right shifts on negative numbers. Right shifts (`>>`) on negative numbers preserve the sign bit, while unsigned right shifts (`>>>`) do not.
 
  <CodeGroup>

  ```javascript
  console.log(-5 >> 1); // Output: -3 (Preserves the sign bit)
  console.log(-5 >>> 1); // Output: 2147483645 (Does not preserve the sign bit)
  ```

  ```typescript
  console.log(-5 >> 1); // Output: -3 (Preserves the sign bit)
  console.log(-5 >>> 1); // Output: 2147483645 (Does not preserve the sign bit)
  ```

  </CodeGroup>

2. **Overflow**: JavaScript numbers are 64-bit floating-point but bitwise operations work on 32-bit signed integers, which can cause unexpected results due to overflow. Always ensure that your operations do not inadvertently overflow.
  
  <CodeGroup>

  ```javascript
  console.log(Math.pow(2, 31) | 0); // Output: -2147483648 (Overflow)
  ```

  ```typescript
  console.log(Math.pow(2, 31) | 0); // Output: -2147483648 (Overflow)
  ```

  </CodeGroup>

3. **Operator Precedence**: Use parentheses to ensure the correct order of operations, especially in complex expressions involving multiple bitwise operations.
   
  <CodeGroup>

  ```javascript
  console.log((5 & 1) === 0); // Output: false (Correct precedence)
  console.log(5 & 1 === 0); // Output: false (Incorrect precedence)
  ```

  ```typescript
  console.log((5 & 1) === 0); // Output: false (Correct precedence)
  console.log(5 & 1 === 0); // Output: false (Incorrect precedence)
  ```

  </CodeGroup>

4. **Performance Considerations**: While bitwise operations are generally fast, excessive use can make code less readable and maintainable. Ensure that the use of bitwise operations is justified by a significant performance gain.

## **Time and Space Complexity**

- **Bitwise Operations**: O(1) time complexity. Bitwise operations are generally very fast and execute in constant time.
- **Space Complexity**: O(1). Bitwise operations do not require additional space.

## **Advanced Bit Manipulation Techniques**

### **Population Count (Hamming Weight) Using Lookup Table**
For a more efficient population count, you can use a precomputed lookup table for nibbles (4 bits).

<CodeGroup>

```javascript
const lookupTable = new Uint8Array(256);
for (let i = 0; i < 256; i++) {
  lookupTable[i] = (i & 1) + lookupTable[i >> 1];
}

function popCount(num) {
  return lookupTable[num & 0xff] +
         lookupTable[(num >> 8) & 0xff] +
         lookupTable[(num >> 16) & 0xff] +
         lookupTable[(num >> 24) & 0xff];
}

console.log(popCount(5)); // Output: 2 (0101 has two 1s)
```

```typescript
const lookupTable: Uint8Array = new Uint8Array(256);
for (let i = 0; i < 256; i++) {
  lookupTable[i] = (i & 1) + lookupTable[i >> 1];
}

function popCount(num: number): number {
  return lookupTable[num & 0xff] +
         lookupTable[(num >> 8) & 0xff] +
         lookupTable[(num >> 16) & 0xff] +
         lookupTable[(num >> 24) & 0xff];
}

console.log(popCount(5)); // Output: 2 (0101 has two 1s)
```

</CodeGroup>

### **Finding the Most Significant Bit (MSB)**
To find the position of the most significant bit set to 1.

<CodeGroup>

```javascript
function msb(num) {
  let msbPos = -1;
  while (num > 0) {
    num >>= 1;
    msbPos++;
  }
  return msbPos;
}

console.log(msb(18)); // Output: 4 (10010, MSB is at position 4)
```

```typescript
function msb(num: number): number {
  let msbPos = -1;
  while (num > 0) {
    num >>= 1;
    msbPos++;
  }
  return msbPos;
}

console.log(msb(18)); // Output: 4 (10010, MSB is at position 4)
```

</CodeGroup>

### **Extracting Bits**
Extract specific bits from a number using masks and shifts.

<CodeGroup>

```javascript
function extractBits(num, start, end) {
  let mask = ((1 << (end - start + 1)) - 1) << start;
  return (num & mask) >> start;
}

console.log(extractBits(29, 1, 3)); // Output: 5 (11101 -> bits 1 to 3 are 101)
```

```typescript
function extractBits(num: number, start: number, end: number): number {
  let mask = ((1 << (end - start + 1)) - 1) << start;
  return (num & mask) >> start;
}

console.log(extractBits(29, 1, 3)); // Output: 5 (11101 -> bits 1 to 3 are 101)
```

</CodeGroup>

## **Real-World Applications**

### **Network Address Translation (NAT)**
Bit manipulation is extensively used in network programming, especially for tasks like Network Address Translation (NAT). For instance, calculating network addresses from IP addresses and subnets involves bitwise AND operations.

### **Graphics Programming**
In graphics programming, bitwise operations are used for tasks such as color blending, where individual color channels (red, green, blue, alpha) need to be manipulated.

### **Cryptography**
Many cryptographic algorithms, such as those used in hashing functions (e.g., SHA-256), heavily rely on bitwise operations to shuffle and mix bits to achieve diffusion.

Mastering bit manipulation can significantly improve your problem-solving skills, especially in areas requiring optimization and low-level data processing. Understanding and utilizing these techniques effectively can set you apart in technical interviews and real-world programming challenges. By practicing these operations and incorporating them into your daily coding routines, you can gain a deeper understanding of how computers process data at the most fundamental level.