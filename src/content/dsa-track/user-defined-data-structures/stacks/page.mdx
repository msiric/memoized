export const metadata = {
  title: 'Comprehensive Guide to Stacks in JavaScript',
  description: 'Explore stack operations and their applications in computer science. Understand stack implementation, performance considerations, and practical examples.',
}

# **Stacks in JavaScript**

Stacks are a fundamental data structure used to store collections of elements in a Last-In-First-Out (LIFO) manner. This means the last element added to the stack is the first one to be removed.

## **Concept and Use Cases**

**Definition:**
A stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. Elements can be added to and removed from the top of the stack only.

**Common Use Cases:**
- Implementing undo functionality in applications.
- Evaluating expressions (e.g., postfix, prefix).
- Managing function calls in programming languages (call stack).
- Depth-First Search (DFS) in graph algorithms.
- Parsing and balancing symbols (e.g., parentheses in expressions).

## **When to Use**
- When you need a LIFO data structure.
- When implementing algorithms that require backtracking.
- When managing a series of operations where the last operation needs to be reversed first.

## **Time and Space Complexity**

**Time Complexity:**
- Push: O(1)
- Pop: O(1)
- Peek: O(1)
- Search: O(n)

**Space Complexity:**
- O(n), where n is the number of elements in the stack.

## **Stack Operations and Methods**

### **Creating a Stack**

**Example:**

<CodeGroup>

```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    // Methods to be defined...
}
```

```typescript
class Stack<T> {
    private items: T[] = [];

    // Methods to be defined...
}
```

</CodeGroup>

### **Pushing Elements**

**Example:**

<CodeGroup>

```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }
}
```

```typescript
class Stack<T> {
    private items: T[] = [];

    push(element: T): void {
        this.items.push(element);
    }
}
```

</CodeGroup>

### **Popping Elements**

**Example:**

<CodeGroup>

```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop();
    }
}
```

```typescript
class Stack<T> {
    private items: T[] = [];

    push(element: T): void {
        this.items.push(element);
    }

    pop(): T | "Underflow" {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop() as T;
    }
}
```

</CodeGroup>

### **Peeking the Top Element**

**Example:**

<CodeGroup>

```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop();
    }

    peek() {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }
}
```

```typescript
class Stack<T> {
    private items: T[] = [];

    push(element: T): void {
        this.items.push(element);
    }

    pop(): T | "Underflow" {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop() as T;
    }

    peek(): T | "No elements in Stack" {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }
}
```

</CodeGroup>

### **Checking if the Stack is Empty**

**Example:**

<CodeGroup>

```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop();
    }

    peek() {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }

    isEmpty() {
        return this.items.length === 0;
    }
}
```

```typescript
class Stack<T> {
    private items: T[] = [];

    push(element: T): void {
        this.items.push(element);
    }

    pop(): T | "Underflow" {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop() as T;
    }

    peek(): T | "No elements in Stack" {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }
}
```

</CodeGroup>

### **Getting the Size of the Stack**

**Example:**

<CodeGroup>

```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop();
    }

    peek() {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}
```

```typescript
class Stack<T> {
    private items: T[] = [];

    push(element: T): void {
        this.items.push(element);
    }

    pop(): T | "Underflow" {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop() as T;
    }

    peek(): T | "No elements in Stack" {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }
}
```

</CodeGroup>

### **Clearing the Stack**

**Example:**

<CodeGroup>

```javascript
class Stack {
    constructor() {
        this.items = [];
    }

    push(element) {
        this.items.push(element);
    }

    pop() {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop();
    }

    peek() {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }

    clear() {
        this.items = [];
    }
}
```

```typescript
class Stack<T> {
    private items: T[] = [];

    push(element: T): void {
        this.items.push(element);
    }

    pop(): T | "Underflow" {
        if (this.items.length === 0) return "Underflow";
        return this.items.pop() as T;
    }

    peek(): T | "No elements in Stack" {
        if (this.items.length === 0) return "No elements in Stack";
        return this.items[this.items.length - 1];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }

    clear(): void {
        this.items = [];
    }
}
```

</CodeGroup>

## **Practical Tips and Tricks**

- **Use Arrays for Simple Stacks:**
  In JavaScript, arrays can be used to implement simple stacks because they provide built-in methods like `push`, `pop`, and `length`.

  **Example:**

  <CodeGroup>

  ```javascript
  let stack = [];
  stack.push(1);
  stack.push(2);
  console.log(stack.pop());  // Output: 2
  console.log(stack);  // Output: [1]
  ```

  ```typescript
  let stack: number[] = [];
  stack.push(1);
  stack.push(2);
  console.log(stack.pop());  // Output: 2
  console.log(stack);  // Output: [1]
  ```

  </CodeGroup>

- **Avoid Underflow Errors:**
  Always check if the stack is empty before performing a `pop` operation to avoid underflow errors.

  **Example:**

  <CodeGroup>

  ```javascript
  let stack = new Stack();
  if (!stack.isEmpty()) {
      stack.pop();
  }
  ```

  ```typescript
  let stack = new Stack<number>();
  if (!stack.isEmpty()) {
      stack.pop();
  }
  ```

  </CodeGroup>

- **Use Stack for DFS:**
  Implement Depth-First Search (DFS) using a stack to manage the nodes to be visited.

  **Example:**

  <CodeGroup>

  ```javascript
  function dfs(graph, start) {
      let stack = [start];
      let visited = new Set();

      while (stack.length > 0) {
          let node = stack.pop();
          if (!visited.has(node)) {
              visited.add(node);
              console.log(node);
              for (let neighbor of graph[node]) {
                  stack.push(neighbor);
              }
          }
      }
  }
  ```

  ```typescript
  function dfs(graph: Record<number, number[]>, start: number): void {
      let stack: number[] = [start];
      let visited = new Set<number>();
  
      while (stack.length > 0) {
          let node = stack.pop()!;
          if (!visited.has(node)) {
              visited.add(node);
              console.log(node);
              for (let neighbor of graph[node]) {
                  stack.push(neighbor);
              }
          }
      }
  }
  ```

  </CodeGroup>

## **Common Gotchas**

- **Stack Overflow:**
  Be cautious of stack overflow when using recursion, especially in languages with limited stack size. In JavaScript, this is less of an issue for stack data structures but important in recursion.

  **Example:**

  <CodeGroup>  

  ```javascript
  function factorial(n) {
      if (n === 0) return 1;
      return n * factorial(n - 1);  // Risk of stack overflow for large n
  }
  ```  

  ```typescript
  function factorial(n: number): number {
      if (n === 0) return 1;
      return n * factorial(n - 1);  // Risk of stack overflow for large n
  }
  ```  

  </CodeGroup>

- **Non-Primitive Data Types:**
  When storing non-primitive data types in a stack, be mindful of references and mutations.

  **Example:**

  <CodeGroup>
  
  ```javascript
  let stack = [];
  let obj = {a: 1};
  stack.push(obj);
  obj.a = 2;
  console.log(stack[stack.length - 1]);  // Output: {a: 2}
  ```
  
  ```typescript
  let stack: {a: number}[] = [];
  let obj = {a: 1};
  stack.push(obj);
  obj.a = 2;
  console.log(stack[stack.length - 1]);  // Output: {a: 2}
  ```
  
  </CodeGroup>

## **Advanced Topics**

### **Implementing a Stack Using a Linked List**

**Example:**

<CodeGroup>

```javascript
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

class LinkedListStack {
    constructor() {
        this.top = null;
        this.size = 0;
    }

    push(value) {
        const newNode = new Node(value);
        newNode.next = this.top;
        this.top = newNode;
        this.size++;
    }

    pop() {
        if (this.size === 0) return "Underflow";
        const value = this.top.value;
        this.top = this.top.next;
        this.size--;
        return value;
    }

    peek() {
        if (this.size === 0) return "No elements in Stack";
        return this.top.value;
    }

    isEmpty() {
        return this.size === 0;
    }

    size() {
        return this.size;
    }

    clear() {
        this.top = null;
        this.size = 0;
    }
}
```

```typescript
class Node<T> {
    value: T;
    next: Node<T> | null = null;

    constructor(value: T) {
        this.value = value;
    }
}

class LinkedListStack<T> {
    private top: Node<T> | null = null;
    private _size: number = 0;

    push(value: T): void {
        const newNode = new Node(value);
        newNode.next = this.top;
        this.top = newNode;
        this._size++;
    }

    pop(): T | "Underflow" {
        if (this._size === 0) return "Underflow";
        const value = this.top!.value;
        this.top = this.top!.next;
        this._size--;
        return value;
    }

    peek(): T | "No elements in Stack" {
        if (this._size === 0) return "No elements in Stack";
        return this.top!.value;
    }

    isEmpty(): boolean {
        return this._size === 0;
    }

    size(): number {
        return this._size;
    }

    clear(): void {
        this.top = null;
        this._size = 0;
    }
}
```

</CodeGroup>

### **Min Stack**

A Min Stack supports push, pop, and retrieving the minimum element in constant time.

**Example:**

<CodeGroup>

```javascript
class MinStack {
    constructor() {
        this.stack = [];
        this.minStack = [];
    }

    push(value) {
        this.stack.push(value);
        if (this.minStack.length === 0 || value <= this.minStack[this.minStack.length - 1]) {
            this.minStack.push(value);
        }
    }

    pop() {
        if (this.stack.length === 0) return "Underflow";
        const value = this.stack.pop();
        if (value === this.minStack[this.minStack.length - 1]) {
            this.minStack.pop();
        }
        return value;
    }

    getMin() {
        if (this.minStack.length === 0) return "No elements in Stack";
        return this.minStack[this.minStack.length - 1];
    }

    peek() {
        if (this.stack.length === 0) return "No elements in Stack";
        return this.stack[this.stack.length - 1];
    }

    isEmpty() {
        return this.stack.length === 0;
    }

    size() {
        return this.stack.length;
    }

    clear() {
        this.stack = [];
        this.minStack = [];
    }
}
```

```typescript
class MinStack<T> {
    private stack: T[] = [];
    private minStack: T[] = [];

    push(value: T): void {
        this.stack.push(value);
        if (this.minStack.length === 0 || value <= this.minStack[this.minStack.length - 1]) {
            this.minStack.push(value);
        }
    }

    pop(): T | "Underflow" {
        if (this.stack.length === 0) return "Underflow";
        const value = this.stack.pop() as T;
        if (value === this.minStack[this.minStack.length - 1]) {
            this.minStack.pop();
        }
        return value;
    }

    getMin(): T | "No elements in Stack" {
        if (this.minStack.length === 0) return "No elements in Stack";
        return this.minStack[this.minStack.length - 1];
    }

    peek(): T | "No elements in Stack" {
        if (this.stack.length === 0) return "No elements in Stack";
        return this.stack[this.stack.length - 1];
    }

    isEmpty(): boolean {
        return this.stack.length === 0;
    }

    size(): number {
        return this.stack.length;
    }

    clear(): void {
        this.stack = [];
        this.minStack = [];
    }
}
```

</CodeGroup>

## **Stack Algorithms**
Below are some common stack algorithms you should be familiar with:

### **Balanced Parentheses**
Checking balanced parentheses ensures that every opening parenthesis has a corresponding closing parenthesis and they are properly nested.

**Example:**

<CodeGroup>

```javascript
function isBalanced(expression) {
    let stack = [];
    for (let char of expression) {
        if (char === '(') {
            stack.push(char);
        } else if (char === ')') {
            if (stack.length === 0) return false;
            stack.pop();
        }
    }
    return stack.length === 0;
}

console.log(isBalanced("(())"));  // Output: true
console.log(isBalanced("(()"));   // Output: false
```

```typescript
function isBalanced(expression: string): boolean {
    let stack: string[] = [];
    for (let char of expression) {
        if (char === '(') {
            stack.push(char);
        } else if (char === ')') {
            if (stack.length === 0) return false;
            stack.pop();
        }
    }
    return stack.length === 0;
}

console.log(isBalanced("(())"));  // Output: true
console.log(isBalanced("(()"));   // Output: false
```

</CodeGroup>

### **Evaluate Postfix Expression**
Evaluating a postfix expression computes the value of an expression written in postfix notation using a stack.

**Example:**

<CodeGroup>

```javascript
function evaluatePostfix(expression) {
    let stack = [];
    for (let char of expression) {
        if (!isNaN(char)) {
            stack.push(parseInt(char));
        } else {
            let b = stack.pop();
            let a = stack.pop();
            switch (char) {
                case '+':
                    stack.push(a + b);
                    break;
                case '-':
                    stack.push(a - b);
                    break;
                case '*':
                    stack.push(a * b);
                    break;
                case '/':
                    stack.push(a / b);
                    break;
            }
        }
    }
    return stack.pop();
}

console.log(evaluatePostfix("231*+9-"));  // Output: -4
```

```typescript
function evaluatePostfix(expression: string): number {
    let stack: number[] = [];
    for (let char of expression) {
        if (!isNaN(Number(char))) {
            stack.push(Number(char));
        } else {
            let b = stack.pop()!;
            let a = stack.pop()!;
            switch (char) {
                case '+':
                    stack.push(a + b);
                    break;
                case '-':
                    stack.push(a - b);
                    break;
                case '*':
                    stack.push(a * b);
                    break;
                case '/':
                    stack.push(a / b);
                    break;
            }
        }
    }
    return stack.pop()!;
}

console.log(evaluatePostfix("231*+9-"));  // Output: -4
```

</CodeGroup>

### **Reverse a String Using a Stack**
Reversing a string using a stack involves pushing all characters onto the stack and then popping them off in reverse order.

**Example:**

<CodeGroup>

```javascript
function reverseString(str) {
    let stack = [];
    for (let char of str) {
        stack.push(char);
    }
    let reversed = '';
    while (stack.length > 0) {
        reversed += stack.pop();
    }
    return reversed;
}

console.log(reverseString("hello"));  // Output: "olleh"
```

```typescript
function reverseString(str: string): string {
    let stack: string[] = [];
    for (let char of str) {
        stack.push(char);
    }
    let reversed = '';
    while (stack.length > 0) {
        reversed += stack.pop();
    }
    return reversed;
}

console.log(reverseString("hello"));  // Output: "olleh"
```

</CodeGroup>

## **Interview Tips and Tricks**

- **Understand Basic Operations:**
  Be comfortable with implementing push, pop, peek, isEmpty, size, and clear operations.
- **Practice Common Algorithms:**
  Familiarize yourself with algorithms like balanced parentheses, evaluating postfix expressions, and reversing strings.
- **Consider Edge Cases:**
  Always consider edge cases like empty stacks, single element stacks, and stack underflow.
- **Optimize Space and Time:**
  Understand how to implement stacks efficiently using arrays and linked lists, and the trade-offs involved.

## **Common Mistakes**

- **Stack Overflow and Underflow:**
  Be cautious of stack overflow in recursive functions and stack underflow when performing pop operations.
- **Incorrect Pointer Updates:**
  When implementing stacks with linked lists, ensure pointers are correctly updated during push and pop operations.
- **Ignoring Edge Cases:**
  Consider all edge cases, such as operations on an empty stack or a stack with a single element.

By mastering stacks and understanding their intricacies, you will be well-equipped to handle a variety of interview questions and real-world problems involving LIFO data structures. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.