export const metadata = {
  title: 'Comprehensive Guide to Queues in JavaScript',
  description: 'Understand the FIFO principle and how queues are implemented. Learn about queue operations, performance considerations, and practical examples.',
}

# **Queues in JavaScript**

Queues are a fundamental data structure used to store collections of elements in a First-In-First-Out (FIFO) manner. This means the first element added to the queue is the first one to be removed.

## **Concept and Use Cases**

**Definition:**
A queue is a linear data structure that follows the First-In-First-Out (FIFO) principle. Elements are added to the end of the queue and removed from the front.

**Common Use Cases:**
- Managing tasks in a sequential order (e.g., printer queue, task scheduling).
- Implementing breadth-first search (BFS) in graph algorithms.
- Handling requests in a server (e.g., request queue).
- Implementing real-time systems (e.g., message queue).

## **When to Use**
- When you need a FIFO data structure.
- When processing elements in the order they were added is essential.
- When implementing algorithms that require level-order traversal or BFS.

## **Time and Space Complexity**

**Time Complexity:**
- Enqueue (add): O(1)
- Dequeue (remove): O(1)
- Peek: O(1)
- Search: O(n)

**Space Complexity:**
- O(n), where n is the number of elements in the queue.

## **Queue Operations and Methods**

### **Creating a Queue**

**Example:**

<CodeGroup>

```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    // Methods to be defined...
}
```

```typescript
class Queue<T> {
    private items: T[] = [];

    // Methods to be defined...
}
```

</CodeGroup>

### **Enqueuing Elements**

**Example:**

<CodeGroup>

```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }
}
```

```typescript
class Queue<T> {
    private items: T[] = [];

    enqueue(element: T): void {
        this.items.push(element);
    }
}
```

</CodeGroup>

### **Dequeuing Elements**

**Example:**

<CodeGroup>

```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }

    dequeue() {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift();
    }
}
```

```typescript
class Queue<T> {
    private items: T[] = [];

    enqueue(element: T): void {
        this.items.push(element);
    }

    dequeue(): T | string {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift() as T;
    }
}
```

</CodeGroup>

### **Peeking the Front Element**

**Example:**

<CodeGroup>

```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }

    dequeue() {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift();
    }

    front() {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }
}
```

```typescript
class Queue<T> {
    private items: T[] = [];

    enqueue(element: T): void {
        this.items.push(element);
    }

    dequeue(): T | string {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift() as T;
    }

    front(): T | string {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }
}
```

</CodeGroup>

### **Checking if the Queue is Empty**

**Example:**

<CodeGroup>

```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }

    dequeue() {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift();
    }

    front() {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }
}
```

```typescript
class Queue<T> {
    private items: T[] = [];

    enqueue(element: T): void {
        this.items.push(element);
    }

    dequeue(): T | string {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift() as T;
    }

    front(): T | string {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }
}
```

</CodeGroup>

### **Getting the Size of the Queue**

**Example:**

<CodeGroup>

```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }

    dequeue() {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift();
    }

    front() {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }
}
```

```typescript
class Queue<T> {
    private items: T[] = [];

    enqueue(element: T): void {
        this.items.push(element);
    }

    dequeue(): T | string {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift() as T;
    }

    front(): T | string {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }
}
```

</CodeGroup>

### **Clearing the Queue**

**Example:**

<CodeGroup>

```javascript
class Queue {
    constructor() {
        this.items = [];
    }

    enqueue(element) {
        this.items.push(element);
    }

    dequeue() {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift();
    }

    front() {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }

    clear() {
        this.items = [];
    }
}
```

```typescript
class Queue<T> {
    private items: T[] = [];

    enqueue(element: T): void {
        this.items.push(element);
    }

    dequeue(): T | string {
        if (this.isEmpty()) return "Underflow";
        return this.items.shift() as T;
    }

    front(): T | string {
        if (this.isEmpty()) return "No elements in Queue";
        return this.items[0];
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }

    clear(): void {
        this.items = [];
    }
}
```

</CodeGroup>

## **Practical Tips and Tricks**

- **Use Arrays for Simple Queues:**
  In JavaScript, arrays can implement simple queues with methods like `push`, `shift`, and `length`. However, this approach isn't optimal for large queues because `shift` and `unshift` have an O(n) time complexity due to element reindexing. This is usually fine, but always clarify with your interviewer that you understand the performance implications.
  
  **Example:**

  <CodeGroup>
  
  ```javascript
  let queue = [];
  queue.push(1);
  queue.push(2);
  console.log(queue.shift());  // Output: 1
  console.log(queue);  // Output: [2]
  ```

  ```typescript
  let queue: number[] = [];
  queue.push(1);
  queue.push(2);
  console.log(queue.shift());  // Output: 1
  console.log(queue);  // Output: [2]
  ```

  </CodeGroup>

- **Avoid Underflow Errors:**
  Always check if the queue is empty before performing a `dequeue` operation to avoid underflow errors.
  
  **Example:**

  <CodeGroup>
  
  ```javascript
  if (!queue.isEmpty()) {
      queue.dequeue();
  }
  ```

  ```typescript
  if (!queue.isEmpty()) {
      queue.dequeue();
  }
  ```

  </CodeGroup>

- **Use Queue for BFS:**
  Implement Breadth-First Search (BFS) using a queue to manage the nodes to be visited.
  
  **Example:**

  <CodeGroup>
  
  ```javascript
  function bfs(graph, start) {
      let queue = [start];
      let visited = new Set();

      while (queue.length > 0) {
          let node = queue.shift();
          if (!visited.has(node)) {
              visited.add(node);
              console.log(node);
              for (let neighbor of graph[node]) {
                  queue.push(neighbor);
              }
          }
      }
  }
  ```

  ```typescript
  function bfs(graph: Record<string, string[]>, start: string): void {
      let queue: string[] = [start];
      let visited: Set<string> = new Set();

      while (queue.length > 0) {
          let node = queue.shift()!;
          if (!visited.has(node)) {
              visited.add(node);
              console.log(node);
              for (let neighbor of graph[node]) {
                  queue.push(neighbor);
              }
          }
      }
  }
  ```

  </CodeGroup>

## **Common Gotchas**

- **Queue Underflow:**
  Always check if the queue is empty before performing a dequeue operation to avoid underflow errors.
  
  **Example:**

  <CodeGroup>
  
  ```javascript
  if (!queue.isEmpty()) {
      queue.dequeue();
  } else {
      console.log("Queue is empty");
  }
  ```

  ```typescript
  if (!queue.isEmpty()) {
      queue.dequeue();
  } else {
      console.log("Queue is empty");
  }
  ```

  </CodeGroup>

- **Non-Primitive Data Types:**
  When storing non-primitive data types in a queue, be mindful of references and mutations.
  
  **Example:**

  <CodeGroup>
  
  ```javascript
  let queue = [];
  let obj = {a: 1};
  queue.push(obj);
  obj.a = 2;
  console.log(queue[0]);  // Output: {a: 2}
  ```

  ```typescript
  let queue: Array<{a: number}> = [];
  let obj = {a: 1};
  queue.push(obj);
  obj.a = 2;
  console.log(queue[0]);  // Output: {a: 2}
  ```

  </CodeGroup>

## **Advanced Topics**

### **Implementing a Queue Using a Linked List**

**Example:**

<CodeGroup>

```javascript
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

class LinkedListQueue {
    constructor() {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }

    enqueue(value) {
        const newNode = new Node(value);
        if (this.rear) {
            this.rear.next = newNode;
        } else {
            this.front = newNode;
        }
        this.rear = newNode;
        this.size++;
    }

    dequeue() {
        if (this.size === 0) return "Underflow";
        const value = this.front.value;
        this.front = this.front.next;
        if (!this.front) {
            this.rear = null;
        }
        this.size--;
        return value;
    }

    peek() {
        if (this.size === 0) return "No elements in Queue";
        return this.front.value;
    }

    isEmpty() {
        return this.size === 0;
    }

    getSize() {
        return this.size;
    }

    clear() {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }
}
```

```typescript
class Node<T> {
    value: T;
    next: Node<T> | null = null;

    constructor(value: T) {
        this.value = value;
    }
}

class LinkedListQueue<T> {
    private front: Node<T> | null = null;
    private rear: Node<T> | null = null;
    private size: number = 0;

    enqueue(value: T): void {
        const newNode = new Node(value);
        if (this.rear) {
            this.rear.next = newNode;
        } else {
            this.front = newNode;
        }
        this.rear = newNode;
        this.size++;
    }

    dequeue(): T | string {
        if (this.size === 0) return "Underflow";
        const value = this.front!.value;
        this.front = this.front!.next;
        if (!this.front) {
            this.rear = null;
        }
        this.size--;
        return value;
    }

    peek(): T | string {
        if (this.size === 0) return "No elements in Queue";
        return this.front!.value;
    }

    isEmpty(): boolean {
        return this.size === 0;
    }

    getSize(): number {
        return this.size;
    }

    clear(): void {
        this.front = null;
        this.rear = null;
        this.size = 0;
    }
}
```

</CodeGroup>

### **Circular Queue**

A circular queue, also known as a ring buffer, efficiently uses the space by wrapping around the end to the beginning.

**Example:**

<CodeGroup>

```javascript
class CircularQueue {
    constructor(capacity) {
        this.items = new Array(capacity);
        this.capacity = capacity;
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }

    enqueue(element) {
        if (this.size === this.capacity) return "Overflow";
        this.items[this.rear] = element;
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
    }

    dequeue() {
        if (this.size === 0) return "Underflow";
        let element = this.items[this.front];
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        return element;
    }

    peek() {
        if (this.size === 0) return "No elements in Queue";
        return this.items[this.front];
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }

    getSize() {
        return this.size;
    }

    clear() {
        this.items = new Array(this.capacity);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }
}
```

```typescript
class CircularQueue<T> {
    private items: T[];
    private capacity: number;
    private front: number = 0;
    private rear: number = 0;
    private size: number = 0;

    constructor(capacity: number) {
        this.capacity = capacity;
        this.items = new Array<T>(capacity);
    }

    enqueue(element: T): string | void {
        if (this.size === this.capacity) return "Overflow";
        this.items[this.rear] = element;
        this.rear = (this.rear + 1) % this.capacity;
        this.size++;
    }

    dequeue(): T | string {
        if (this.size === 0) return "Underflow";
        let element = this.items[this.front];
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        return element;
    }

    peek(): T | string {
        if (this.size === 0) return "No elements in Queue";
        return this.items[this.front];
    }

    isEmpty(): boolean {
        return this.size === 0;
    }

    isFull(): boolean {
        return this.size === this.capacity;
    }

    getSize(): number {
        return this.size;
    }

    clear(): void {
        this.items = new Array<T>(this.capacity);
        this.front = 0;
        this.rear = 0;
        this.size = 0;
    }
}
```

</CodeGroup>

### **Priority Queue**

A priority queue is a special type of queue where elements are removed based on priority rather than insertion order.

**Example:**

<CodeGroup>

```javascript
class PriorityQueue {
    constructor() {
        this.items = [];
    }

    enqueue(element, priority) {
        let newItem = {element, priority};
        let added = false;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].priority > newItem.priority) {
                this.items.splice(i, 1, newItem);
                added = true;
                break;
            }
        }
        if (!added) {
            this.items.push(newItem);
        }
    }

    dequeue() {
        if (this.items.length === 0) return "Underflow";
        return this.items.shift().element;
    }

    peek() {
        if (this.items.length === 0) return "No elements in Queue";
        return this.items[0].element;
    }

    isEmpty() {
        return this.items.length === 0;
    }

    size() {
        return this.items.length;
    }

    clear() {
        this.items = [];
    }
}
```

```typescript
interface PriorityItem<T> {
    element: T;
    priority: number;
}

class PriorityQueue<T> {
    private items: PriorityItem<T>[] = [];

    enqueue(element: T, priority: number): void {
        let newItem: PriorityItem<T> = {element, priority};
        let added = false;
        for (let i = 0; i < this.items.length; i++) {
            if (this.items[i].priority > newItem.priority) {
                this.items.splice(i, 1, newItem);
                added = true;
                break;
            }
        }
        if (!added) {
            this.items.push(newItem);
        }
    }

    dequeue(): T | string {
        if (this.items.length === 0) return "Underflow";
        return this.items.shift()!.element;
    }

    peek(): T | string {
        if (this.items.length === 0) return "No elements in Queue";
        return this.items[0].element;
    }

    isEmpty(): boolean {
        return this.items.length === 0;
    }

    size(): number {
        return this.items.length;
    }

    clear(): void {
        this.items = [];
    }
}
```

</CodeGroup>

## **Queue Algorithms**
Below are some common queue algorithms you should be familiar with:

### **Breadth-First Search (BFS)**
Breadth-First Search (BFS) explores all the nodes at the present depth level before moving on to the nodes at the next depth level.

**Example:**

<CodeGroup>

```javascript
function bfs(graph, start) {
    let queue = [start];
    let visited = new Set();

    while (queue.length > 0) {
        let node = queue.shift();
        if (!visited.has(node)) {
            visited.add(node);
            console.log(node);
            for (let neighbor of graph[node]) {
                queue.push(neighbor);
            }
        }
    }
}

let graph = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E']
};

bfs(graph, 'A');  // Output: A B C D E F
```

```typescript
function bfs(graph: Record<string, string[]>, start: string): void {
    let queue: string[] = [start];
    let visited: Set<string> = new Set();

    while (queue.length > 0) {
        let node = queue.shift()!;
        if (!visited.has(node)) {
            visited.add(node);
            console.log(node);
            for (let neighbor of graph[node]) {
                queue.push(neighbor);
            }
        }
    }
}

let graph: Record<string, string[]> = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E']
};

bfs(graph, 'A');  // Output: A B C D E F
```

</CodeGroup>

### **Implementing a Cache Using a Queue**
An LRU (Least Recently Used) cache evicts the least recently accessed item when it reaches its capacity.

**Example:**

<CodeGroup>

```javascript
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
        this.queue = [];
    }

    get(key) {
        if (!this.cache.has(key)) return -1;
        let value = this.cache.get(key);
        this.queue = this.queue.filter(k => k !== key);
        this.queue.push(key);
        return value;
    }

    put(key, value) {
        if (this.cache.has(key)) {
            this.queue = this.queue.filter(k => k !== key);
        } else if (this.queue.length === this.capacity) {
            let oldestKey = this.queue.shift();
            this.cache.delete(oldestKey);
        }
        this.cache.set(key, value);
        this.queue.push(key);
    }
}

let cache = new LRUCache(2);
cache.put(1, 1);
cache.put(2, 2);
console.log(cache.get(1));  // Output: 1
cache.put(3, 3);
console.log(cache.get(2));  // Output: -1
cache.put(4, 4);
console.log(cache.get(1));  // Output: -1
console.log(cache.get(3));  // Output: 3
console.log(cache.get(4));  // Output: 4
```

```typescript
class LRUCache<T> {
    private capacity: number;
    private cache: Map<number, T>;
    private queue: number[];

    constructor(capacity: number) {
        this.capacity = capacity;
        this.cache = new Map<number, T>();
        this.queue = [];
    }

    get(key: number): T | number {
        if (!this.cache.has(key)) return -1;
        let value = this.cache.get(key)!;
        this.queue = this.queue.filter(k => k !== key);
        this.queue.push(key);
        return value;
    }

    put(key: number, value: T): void {
        if (this.cache.has(key)) {
            this.queue = this.queue.filter(k => k !== key);
        } else if (this.queue.length === this.capacity) {
            let oldestKey = this.queue.shift()!;
            this.cache.delete(oldestKey);
        }
        this.cache.set(key, value);
        this.queue.push(key);
    }
}

let cache = new LRUCache<number>(2);
cache.put(1, 1);
cache.put(2, 2);
console.log(cache.get(1));  // Output: 1
cache.put(3, 3);
console.log(cache.get(2));  // Output: -1
cache.put(4, 4);
console.log(cache.get(1));  // Output: -1
console.log(cache.get(3));  // Output: 3
console.log(cache.get(4));  // Output: 4
```

</CodeGroup>

## **Interview Tips and Tricks**

- **Understand Basic Operations:**
  Be comfortable with implementing enqueue, dequeue, peek, isEmpty, size, and clear operations.
- **Practice Common Algorithms:**
  Familiarize yourself with algorithms like BFS, implementing caches, and other queue-based problems.
- **Consider Edge Cases:**
  Always consider edge cases like empty queues, single element queues, and queue underflow.
- **Optimize Space and Time:**
  Understand how to implement queues efficiently using arrays and linked lists, and the trade-offs involved.

## **Common Mistakes**

- **Queue Underflow and Overflow:**
  Be cautious of queue underflow when dequeuing from an empty queue and overflow in fixed-size queues.
- **Incorrect Pointer Updates:**
  When implementing queues with linked lists, ensure pointers are correctly updated during enqueue and dequeue operations.
- **Ignoring Edge Cases:**
  Consider all edge cases, such as operations on an empty queue or a queue with a single element.

By mastering queues and understanding their intricacies, you will be well-equipped to handle a variety of interview questions and real-world problems involving FIFO data structures. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.