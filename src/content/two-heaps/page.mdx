# **Two Heaps Technique**

The Two Heaps technique is an efficient approach used to solve problems where you need to find the smallest element in one part of a set and the largest element in another part. This technique involves maintaining two heaps: a Max Heap for the first half of the data and a Min Heap for the second half.

## **Concept and Use Cases**

**Definition:** 
The Two Heaps technique uses two heaps to divide a data set into two parts:
- A Max Heap to keep track of the largest elements in the lower half.
- A Min Heap to keep track of the smallest elements in the upper half.

**Common Use Cases:**
- Finding the median of a data stream.
- Maintaining a dynamic set of data where you need quick access to the largest or smallest elements.
- Implementing dynamic order statistics.

## **When to Use**
- When you need to find the median of a dynamically changing data set.
- When you need efficient access to the smallest and largest elements in a split data set.
- When solving problems that require balancing two halves of a data set.

## **Time and Space Complexity**

**Time Complexity:** 
- O(log n) for insertion and deletion operations in heaps.

**Space Complexity:**
- O(n) for storing the elements in two heaps.

## **Finding the Median of a Data Stream**

**Problem:** Design a data structure that supports adding numbers from a data stream and finding the median of all numbers added so far.

**Step-by-Step Solution:**
1. Use two heaps: a Max Heap to store the smaller half of the numbers, and a Min Heap to store the larger half.
2. Balance the heaps such that the difference in size between the two heaps is at most one.
3. The median is either the root of the Max Heap (if it contains more elements) or the average of the roots of both heaps (if they contain the same number of elements).

**Code Example:**
```javascript
class MedianFinder {
    constructor() {
        this.maxHeap = new MaxHeap();  // Max Heap for the smaller half
        this.minHeap = new MinHeap();  // Min Heap for the larger half
    }

    addNum(num) {
        if (this.maxHeap.size() === 0 || num <= this.maxHeap.peek()) {
            this.maxHeap.insert(num);
        } else {
            this.minHeap.insert(num);
        }

        // Balance the heaps
        if (this.maxHeap.size() > this.minHeap.size() + 1) {
            this.minHeap.insert(this.maxHeap.extractMax());
        } else if (this.minHeap.size() > this.maxHeap.size()) {
            this.maxHeap.insert(this.minHeap.extractMin());
        }
    }

    findMedian() {
        if (this.maxHeap.size() > this.minHeap.size()) {
            return this.maxHeap.peek();
        } else {
            return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
        }
    }
}

// Max Heap implementation
class MaxHeap {
    constructor() {
        this.heap = [];
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.heap[0];
    }

    insert(value) {
        this.heap.push(value);
        this._heapifyUp();
    }

    extractMax() {
        if (this.size() === 1) return this.heap.pop();
        const max = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._heapifyDown();
        return max;
    }

    _heapifyUp() {
        let index = this.size() - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index] <= this.heap[parentIndex]) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    _heapifyDown() {
        let index = 0;
        const length = this.size();
        const element = this.heap[0];
        while (true) {
            let leftChildIndex = 2 * index + 1;
            let rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swap = null;

            if (leftChildIndex < length) {
                leftChild = this.heap[leftChildIndex];
                if (leftChild > element) swap = leftChildIndex;
            }

            if (rightChildIndex < length) {
                rightChild = this.heap[rightChildIndex];
                if ((swap === null && rightChild > element) || (swap !== null && rightChild > leftChild)) {
                    swap = rightChildIndex;
                }
            }

            if (swap === null) break;
            [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];
            index = swap;
        }
    }
}

// Min Heap implementation
class MinHeap {
    constructor() {
        this.heap = [];
    }

    size() {
        return this.heap.length;
    }

    peek() {
        return this.heap[0];
    }

    insert(value) {
        this.heap.push(value);
        this._heapifyUp();
    }

    extractMin() {
        if (this.size() === 1) return this.heap.pop();
        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this._heapifyDown();
        return min;
    }

    _heapifyUp() {
        let index = this.size() - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index] >= this.heap[parentIndex]) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    _heapifyDown() {
        let index = 0;
        const length = this.size();
        const element = this.heap[0];
        while (true) {
            let leftChildIndex = 2 * index + 1;
            let rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swap = null;

            if (leftChildIndex < length) {
                leftChild = this.heap[leftChildIndex];
                if (leftChild < element) swap = leftChildIndex;
            }

            if (rightChildIndex < length) {
                rightChild = this.heap[rightChildIndex];
                if ((swap === null && rightChild < element) || (swap !== null && rightChild < leftChild)) {
                    swap = rightChildIndex;
                }
            }

            if (swap === null) break;
            [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];
            index = swap;
        }
    }
}

// Example usage:
const medianFinder = new MedianFinder();
medianFinder.addNum(1);
medianFinder.addNum(2);
console.log(medianFinder.findMedian());  // Output: 1.5
medianFinder.addNum(3);
console.log(medianFinder.findMedian());  // Output: 2
```

**Tips and Tricks:**
- Ensure the Max Heap contains the smaller half of the numbers and the Min Heap contains the larger half.
- Balance the heaps to maintain the size property: the Max Heap can have at most one more element than the Min Heap.
- Use the heaps to quickly access the median by peeking at the roots.

**Frequent Gotchas:**
- Forgetting to balance the heaps after each insertion, leading to incorrect median calculation.
- Incorrectly managing the heaps, causing the elements to be in the wrong heap.
- Handling edge cases, such as finding the median when there is only one element.

## **Maintaining a Dynamic Set of Data**

**Problem:** Implement a data structure that supports adding numbers, removing numbers, and finding the median in O(log n) time.

**Step-by-Step Solution:**
1. Use two heaps: a Max Heap to store the smaller half of the numbers and a Min Heap to store the larger half.
2. Maintain the balance of the heaps to ensure efficient median calculation.
3. Implement methods to add, remove, and find the median of the numbers.

**Code Example:**
```javascript
class DynamicMedian {
    constructor() {
        this.maxHeap = new MaxHeap();  // Max Heap for the smaller half
        this.minHeap = new MinHeap();  // Min Heap for the larger half
    }

    addNum(num) {
        if (this.maxHeap.size() === 0 || num <= this.maxHeap.peek()) {
            this.maxHeap.insert(num);
        } else {
            this.minHeap.insert(num);
        }

        // Balance the heaps
        if (this.maxHeap.size() > this.minHeap.size() + 1) {
            this.minHeap.insert(this.maxHeap.extractMax());
        } else if (this.minHeap.size() > this.maxHeap.size()) {
            this.maxHeap.insert(this.minHeap.extractMin());
        }
    }

    removeNum(num) {
        if (num <= this.maxHeap.peek()) {
            this.maxHeap.remove(num);
        } else {
            this.minHeap.remove(num);
        }

        // Balance the heaps
        if (this.maxHeap.size() > this.minHeap.size() + 1) {
            this.minHeap.insert(this.maxHeap.extractMax());
        } else if (this.minHeap.size() > this.maxHeap.size()) {
            this.maxHeap.insert(this.minHeap.extractMin());
        }
    }

    findMedian() {
        if (this.maxHeap.size() > this.minHeap.size()) {
            return

 this.maxHeap.peek();
        } else {
            return (this.maxHeap.peek() + this.minHeap.peek()) / 2;
        }
    }
}

// Add a remove method to the MaxHeap and MinHeap classes for completeness
MaxHeap.prototype.remove = function(value) {
    const index = this.heap.indexOf(value);
    if (index === -1) return;
    if (index === this.heap.length - 1) {
        this.heap.pop();
    } else {
        this.heap[index] = this.heap.pop();
        this._heapifyDown(index);
        this._heapifyUp(index);
    }
};

MinHeap.prototype.remove = function(value) {
    const index = this.heap.indexOf(value);
    if (index === -1) return;
    if (index === this.heap.length - 1) {
        this.heap.pop();
    } else {
        this.heap[index] = this.heap.pop();
        this._heapifyDown(index);
        this._heapifyUp(index);
    }
};

// Example usage:
const dynamicMedian = new DynamicMedian();
dynamicMedian.addNum(1);
dynamicMedian.addNum(2);
console.log(dynamicMedian.findMedian());  // Output: 1.5
dynamicMedian.addNum(3);
console.log(dynamicMedian.findMedian());  // Output: 2
dynamicMedian.removeNum(2);
console.log(dynamicMedian.findMedian());  // Output: 2
```

**Tips and Tricks:**
- Ensure the Max Heap contains the smaller half of the numbers and the Min Heap contains the larger half.
- Balance the heaps to maintain the size property: the Max Heap can have at most one more element than the Min Heap.
- Use the heaps to quickly access the median by peeking at the roots.

**Frequent Gotchas:**
- Forgetting to balance the heaps after each insertion, leading to incorrect median calculation.
- Incorrectly managing the heaps, causing the elements to be in the wrong heap.
- Handling edge cases, such as finding the median when there is only one element.

By mastering the Two Heaps technique, you can efficiently solve a variety of problems involving dynamic median calculation, balancing two halves of a data set, and maintaining order statistics. This technique is essential for optimizing time complexity and handling heap-related data structures effectively in both technical interviews and real-world applications.

 