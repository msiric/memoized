export const metadata = {
  title: 'Comprehensive Guide to Hash Tables in JavaScript',
  description: 'Delve into hash table implementation and its various use cases. Understand hash table operations, performance considerations, and practical examples.',
}

# **Hash Tables in JavaScript**

Hash tables, also known as hash maps, are a crucial data structure that provides efficient key-value pair storage. They allow for quick insertion, deletion, and lookup operations, making them a fundamental tool in programming. In JavaScript, the `Map` object serves as an implementation of a hash map.

## **Concept and Use Cases**

**Definition:**
A hash table is a data structure that maps keys to values using a hash function to compute an index into an array of buckets or slots, from which the desired value can be found.

**Common Use Cases:**
- Implementing associative arrays or dictionaries.
- Counting occurrences of elements.
- Caching/memoization to store the results of expensive function calls.
- Implementing sets using the keys of the hash table to store unique elements.

## **Types of Hash Tables**
- **Chaining:** Uses linked lists to handle collisions by chaining multiple elements that hash to the same index.
- **Open Addressing:** Resolves collisions by probing, or searching through alternate locations in the array (linear probing, quadratic probing, double hashing).

## **When to Use**
- When you need constant time complexity for insertion, deletion, and lookup.
- When working with a large dataset where quick access to elements is required.
- When implementing data structures like sets or dictionaries.

## **Time and Space Complexity**

**Time Complexity:**
- Insertion: \(O(1)\)
- Deletion: \(O(1)\)
- Lookup: \(O(1)\)

**Space Complexity:**
- \(O(n)\), where \(n\) is the number of key-value pairs stored in the hash table.

## **Hash Table Operations and Methods**

### **Creating a Hash Table**

In JavaScript, a hash table can be created using the `Map` object:

**Example:**
```javascript
let map = new Map();
```

### **Inserting Elements**

**Example:**
```javascript
map.set('key1', 'value1');
map.set('key2', 'value2');
```

### **Deleting Elements**

**Example:**
```javascript
map.delete('key1');
```

### **Checking for Existence**

**Example:**
```javascript
console.log(map.has('key2'));  // Output: true
```

### **Retrieving Values**

**Example:**
```javascript
console.log(map.get('key2'));  // Output: 'value2'
```

## **Iterating Over Elements**

**Example:**
```javascript
map.forEach((value, key) => {
    console.log(key, value);
});
```

### **Handling Collisions**

Collisions occur when two keys hash to the same index. There are several strategies to handle collisions:

1. **Chaining:** Store a linked list or another data structure at each index to handle multiple entries.
2. **Open Addressing:** Find another open slot within the array through techniques like linear probing, quadratic probing, or double hashing.

## **Practical Tips and Tricks**

### **Use `Map` for Consistent Order**

Unlike objects, `Map` maintains the insertion order of keys, making it more predictable when iterating over its elements.

**Example:**
```javascript
let map = new Map();
map.set('b', 1);
map.set('a', 2);
map.set('c', 3);
for (let [key, value] of map) {
    console.log(key, value);  // Output: 'b' 1, 'a' 2, 'c' 3
}
```

### **Use `Object` for Simplicity**

For simple key-value pair storage, `Object` can be used. However, it does not maintain the order of insertion and can have prototype-related issues.

**Example:**
```javascript
let obj = {};
obj['key1'] = 'value1';
obj['key2'] = 'value2';
console.log(obj['key1']);  // Output: 'value1'
```

### **Handling Non-String Keys**

In `Object`, keys are automatically converted to strings. This can lead to unexpected behavior when using non-string keys.

**Example:**
```javascript
let obj = {};
obj[1] = 'value1';
console.log(obj['1']);  // Output: 'value1'
```

### **Performance with Large Data Sets**

While hash tables provide \(O(1)\) average-case complexity, their performance can degrade if the load factor (number of elements divided by the number of buckets) becomes too high. Ensure that the hash table is appropriately resized or rehashed to maintain performance.

## **Advanced Topics**

### **Custom Hash Functions**

In cases where the default hash function is not suitable, custom hash functions can be implemented to better distribute keys and reduce collisions.

**Example:**
```javascript
class CustomHashTable {
    constructor(size = 53) {
        this.keyMap = new Array(size);
    }

    _hash(key) {
        let total = 0;
        let PRIME_NUMBER = 31;
        for (let i = 0; i < Math.min(key.length, 100); i++) {
            let char = key[i];
            let value = char.charCodeAt(0) - 96;
            total = (total * PRIME_NUMBER + value) % this.keyMap.length;
        }
        return total;
    }

    set(key, value) {
        let index = this._hash(key);
        if (!this.keyMap[index]) {
            this.keyMap[index] = [];
        }
        this.keyMap[index].push([key, value]);
    }

    get(key) {
        let index = this._hash(key);
        if (this.keyMap[index]) {
            for (let i = 0; i < this.keyMap[index].length; i++) {
                if (this.keyMap[index][i][0] === key) {
                    return this.keyMap[index][i][1];
                }
            }
        }
        return undefined;
    }
}
```

### **Hash Table Algorithms**

#### **Rehashing**

Rehashing is the process of resizing the hash table and redistributing the keys. This is typically done when the load factor exceeds a certain threshold.

**Example:**
```javascript
class RehashingHashTable extends CustomHashTable {
    constructor(size = 53) {
        super(size);
        this.loadFactor = 0.75;
        this.size = size;
        this.count = 0;
    }

    set(key, value) {
        super.set(key, value);
        this.count++;
        if (this.count / this.size > this.loadFactor) {
            this.rehash();
        }
    }

    rehash() {
        let oldKeyMap = this.keyMap;
        this.size *= 2;
        this.keyMap = new Array(this.size);
        this.count = 0;

        for (let bucket of oldKeyMap) {
            if (bucket) {
                for (let [key, value] of bucket) {
                    this.set(key, value);
                }
            }
        }
    }
}
```

### **Use Cases for Custom Hash Tables**

#### **Counting Elements**

Hash tables are often used for counting the frequency of elements in a dataset.

**Example:**
```javascript
function countElements(arr) {
    let map = new Map();
    for (let elem of arr) {
        map.set(elem, (map.get(elem) || 0) + 1);
    }
    return map;
}

console.log(countElements(['a', 'b', 'a', 'c', 'a', 'b']));  // Output: Map { 'a' => 3, 'b' => 2, 'c' => 1 }
```

#### **Caching/Memoization**

Hash tables can be used to store the results of expensive function calls to avoid redundant computations.

**Example:**
```javascript
function memoize(fn) {
    let cache = new Map();
    return function(...args) {
        let key = JSON.stringify(args);
        if (cache.has(key)) {
            return cache.get(key);
        }
        let result = fn(...args);
        cache.set(key, result);
        return result;
    };
}

function slowFunction(num) {
    for (let i = 0; i <= 1e6; i++) {}  // Simulate slow computation
    return num * 2;
}

let memoizedSlowFunction = memoize(slowFunction);
console.log(memoizedSlowFunction(5));  // Output: 10
console.log(memoizedSlowFunction(5));  // Output: 10 (retrieved from cache)
```

### **Practical Tips and Tricks**

#### **Use `Map` for Predictable Order**

Using the `Map` object in JavaScript ensures that keys are iterated in the order of insertion, making it more predictable for certain operations.

#### **Avoid Collisions**

Choose a good hash function to minimize collisions. A good hash function should distribute keys uniformly across the buckets.

#### **Resize Appropriately**

Resize the hash table when the load factor exceeds a threshold to maintain performance. This involves creating a new hash table of larger size and rehashing all existing entries.

## **Common Gotchas**

#### **Non-String Keys in `Object`**

When using `Object` for hash tables, remember that keys are automatically converted to strings. This can cause unexpected behavior when using non-string keys.

#### **Performance with Large Data Sets**

Although hash tables offer \(O(1)\) average-case time complexity, their performance can degrade if the load factor becomes too high. Ensure that the hash table is resized appropriately to maintain performance.

#### **Hash Collisions**

Even with a good hash function, collisions can still occur. Ensure your collision resolution strategy (chaining or open addressing) is implemented correctly to handle these cases.

### **Advanced Topics**

#### **Implementing a Hash Table with Open Addressing**

Open addressing is a collision resolution method that finds an open slot within the array when a collision occurs.

**Example:**
```javascript
class OpenAddressingHashTable {
    constructor(size = 53) {
        this.keyMap = new Array(size);
        this.size = size;
    }

    _hash(key) {
        let total = 0;
        let PRIME_NUMBER = 31;
        for (let i = 0; i < Math.min(key.length, 100); i++) {
            let char = key[i];
            let value = char.charCodeAt(0) - 96;
            total = (total * PRIME_NUMBER + value) % this.keyMap.length;
        }
        return total;
    }

    set(key, value) {
        let index = this._hash(key);
        while (this.keyMap[index]) {
            index = (index + 1) % this.size;
        }
        this.keyMap[index] = [key, value];
    }

    get(key) {
        let index = this._hash(key);
        while (this.keyMap[index]) {
            if (this.keyMap[index][0] === key) {
                return this.keyMap[index][1];
            }
            index = (index + 1) % this.size;
        }
        return undefined;
    }

    delete(key) {
        let index = this._hash(key);
        while (this.keyMap[index]) {
            if (this.keyMap[index][0] === key) {
                this.keyMap[index] = null;
                return true;
            }
            index = (index + 1) % this.size;
        }
        return false;
    }
}
```

## **Hash Table Algorithms**
Below are some common hash table algorithms you should be familiar with:

### **Counting Frequencies**
Counting frequencies involves determining how often each element appears in an array.

**Example:**
```javascript
function countFrequencies(arr) {
    let frequencyMap = new Map();
    for (let elem of arr) {
        frequencyMap.set(elem, (frequencyMap.get(elem) || 0) + 1);
    }
    return frequencyMap;
}

console.log(countFrequencies(['a', 'b', 'a', 'c', 'a', 'b']));  // Output: Map { 'a' => 3, 'b' => 2, 'c' => 1 }
```

### **Group Anagrams**
Grouping anagrams involves grouping words that are anagrams of each other.

**Example:**
```javascript
function groupAnagrams(words) {
    let map = new Map();
    for (let word of words) {
        let sorted = word.split('').sort().join('');
        if (!map.has(sorted)) {
            map.set(sorted, []);
        }
        map.get(sorted).push(word);
    }
    return Array.from(map.values());
}

console.log(groupAnagrams(['eat', 'tea', 'tan', 'ate', 'nat', 'bat']));  // Output: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]
```

### **Caching/Memoization**
Caching or memoization stores the results of expensive function calls to avoid redundant computations.

**Example:**
```javascript
function memoize(fn) {
    let cache = new Map();
    return function(...args) {
        let key = JSON.stringify(args);
        if (cache.has(key)) {
            return cache.get(key);
        }
        let result = fn(...args);
        cache.set(key, result);
        return result;
    };
}

function slowFunction(num) {
    for (let i = 0; i <= 1e6; i++) {}  // Simulate slow computation
    return num * 2;
}

let memoizedSlowFunction = memoize(slowFunction);
console.log(memoizedSlowFunction(5));  // Output: 10
console.log(memoizedSlowFunction(5));  // Output: 10 (retrieved from cache)
```

## **Interview Tips and Tricks**

- **Understand Basic Operations:**
  Be comfortable with implementing basic operations like `set`, `get`, and `delete`. Understand the underlying principles of hashing and collision resolution strategies.
- **Practice Common Algorithms:**
  Familiarize yourself with common algorithms that use hash tables, such as counting frequencies, detecting duplicates, and implementing caches.
- **Consider Edge Cases:**
  Always consider edge cases like handling collisions, resizing the hash table, and dealing with non-string keys when using `Object`.
- **Optimize Space and Time:**
  Understand how to implement hash tables efficiently, choosing appropriate hash functions and collision resolution strategies.

## **Common Mistakes**

- **Incorrect Hash Function:**
  Using a poor hash function that does not distribute keys uniformly can lead to excessive collisions and degrade performance.
- **Ignoring Edge Cases:**
  Failing to handle edge cases like non-string keys, high load factors, or collision resolution can lead to incorrect or inefficient implementations.
- **Performance Degradation:**
  Not resizing the hash table appropriately when the load factor exceeds a certain threshold can lead to performance degradation.

By mastering hash tables and understanding their intricacies, you will be well-equipped to handle a variety of interview questions and real-world problems involving key-value pair storage. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.