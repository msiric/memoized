**Lesson Title**: **Promises and Asynchronous Patterns in JavaScript**

**Lesson Description**:  
Dive deep into the world of asynchronous programming in JavaScript by mastering Promises and common asynchronous patterns. Learn how to create and handle promises, and how to effectively use `Promise.all` and `Promise.race` to manage multiple asynchronous operations. This comprehensive lesson will enhance your ability to write non-blocking, efficient code, improve the responsiveness of your applications, and prepare you for technical interviews by covering these essential topics.

---

# **Promises and Asynchronous Patterns in JavaScript**

Asynchronous programming is crucial for developing responsive and efficient JavaScript applications, especially when dealing with operations like network requests, file I/O, or timers. Promises provide a powerful way to handle asynchronous operations, making your code cleaner and easier to manage. In this lesson, we'll explore how to create and handle promises, and how to use `Promise.all` and `Promise.race` to coordinate multiple asynchronous tasks.

---

## **Table of Contents**

1. **Introduction to Promises**
   - What is a Promise?
   - States of a Promise
   - Why Use Promises?
2. **Creating Promises**
   - The Promise Constructor
   - Resolving and Rejecting Promises
3. **Handling Promises**
   - `.then()`, `.catch()`, and `.finally()`
   - Chaining Promises
4. **Promise.all and Promise.race**
   - Using `Promise.all()`
   - Using `Promise.race()`
   - Examples and Use Cases
5. **Asynchronous Patterns**
   - Sequential vs. Parallel Execution
   - Combining Promises
   - Error Handling in Promises
6. **Best Practices**
7. **Common Interview Questions**
8. **Exercises**
9. **Conclusion**
10. **Next Steps**
11. **Appendix**

---

## **Introduction to Promises**

### **What is a Promise?**

- **Definition**: A **Promise** is an object representing the eventual completion or failure of an asynchronous operation.
- Promises provide a way to associate handlers with an asynchronous action's eventual success value or failure reason.

### **States of a Promise**

A Promise can be in one of three states:

1. **Pending**: Initial state, neither fulfilled nor rejected.
2. **Fulfilled**: The operation completed successfully.
3. **Rejected**: The operation failed.

![Promise States Diagram](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises/promises.png)

### **Why Use Promises?**

- **Avoid Callback Hell**: Promises help in avoiding deeply nested callbacks, making code more readable.
- **Better Error Handling**: Promises provide a unified way to handle errors through `.catch()`.
- **Chaining**: Promises can be chained, allowing for sequential asynchronous operations.
- **Composability**: Promises can be combined using methods like `Promise.all()` and `Promise.race()`.

---

## **Creating Promises**

### **The Promise Constructor**

To create a new Promise, you use the `Promise` constructor:

```javascript
const promise = new Promise((resolve, reject) => {
  // Asynchronous operation
})
```

- **Executor Function**: The constructor takes an executor function with two parameters:
  - **`resolve`**: A function to call when the promise is fulfilled.
  - **`reject`**: A function to call when the promise is rejected.

### **Resolving and Rejecting Promises**

**Example 1: Resolving a Promise**

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data received')
  }, 1000)
})
```

**Example 2: Rejecting a Promise**

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('Something went wrong'))
  }, 1000)
})
```

**Example 3: Conditional Resolution**

```javascript
const promise = new Promise((resolve, reject) => {
  const success = true
  if (success) {
    resolve('Operation succeeded')
  } else {
    reject(new Error('Operation failed'))
  }
})
```

---

## **Handling Promises**

### \*\*3.1 `.then()`, `.catch()`, and `.finally()`

- **`.then(onFulfilled, onRejected)`**:

  - **`onFulfilled`**: Function called when the promise is fulfilled.
  - **`onRejected`** (optional): Function called when the promise is rejected.

- **`.catch(onRejected)`**:

  - Equivalent to `.then(null, onRejected)`.
  - Catches errors in the promise chain.

- **`.finally(onFinally)`**:
  - Called when the promise is settled (fulfilled or rejected).
  - Does not receive any argument.

**Example:**

```javascript
promise
  .then((result) => {
    console.log('Success:', result)
  })
  .catch((error) => {
    console.error('Error:', error)
  })
  .finally(() => {
    console.log('Operation completed')
  })
```

### **Chaining Promises**

Promises can be chained to perform sequential asynchronous operations.

**Example:**

```javascript
doTask1()
  .then((result1) => {
    console.log('Result 1:', result1)
    return doTask2(result1)
  })
  .then((result2) => {
    console.log('Result 2:', result2)
    return doTask3(result2)
  })
  .then((result3) => {
    console.log('Result 3:', result3)
  })
  .catch((error) => {
    console.error('Error:', error)
  })
```

- Each `.then()` returns a new promise.
- If a promise is rejected, the control skips to the nearest `.catch()`.

---

## **Promise.all and Promise.race**

### **Using `Promise.all()`**

**Definition**:

- `Promise.all()` accepts an iterable (e.g., an array) of promises and returns a new promise.
- Resolves when all promises in the iterable have resolved.
- Rejects immediately if any promise rejects.

**Syntax**:

```javascript
Promise.all(iterable)
```

**Example:**

```javascript
const promise1 = Promise.resolve(1)
const promise2 = Promise.resolve(2)
const promise3 = Promise.resolve(3)

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log('Results:', results) // Outputs: Results: [1, 2, 3]
  })
  .catch((error) => {
    console.error('Error:', error)
  })
```

**Handling Rejections:**

```javascript
const promise1 = Promise.resolve(1)
const promise2 = Promise.reject(new Error('Failed'))
const promise3 = Promise.resolve(3)

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    // This will not execute
  })
  .catch((error) => {
    console.error('Error:', error) // Outputs: Error: Failed
  })
```

### **Using `Promise.race()`**

**Definition**:

- `Promise.race()` returns a promise that fulfills or rejects as soon as one of the promises in the iterable fulfills or rejects.

**Syntax**:

```javascript
Promise.race(iterable)
```

**Example:**

```javascript
const promise1 = new Promise((resolve) => setTimeout(resolve, 500, 'First'))
const promise2 = new Promise((resolve) => setTimeout(resolve, 100, 'Second'))

Promise.race([promise1, promise2])
  .then((result) => {
    console.log('Result:', result) // Outputs: Result: Second
  })
  .catch((error) => {
    console.error('Error:', error)
  })
```

**Handling Rejections:**

```javascript
const promise1 = new Promise((resolve, reject) =>
  setTimeout(reject, 500, 'Error in First'),
)
const promise2 = new Promise((resolve) => setTimeout(resolve, 100, 'Second'))

Promise.race([promise1, promise2])
  .then((result) => {
    console.log('Result:', result) // Outputs: Result: Second
  })
  .catch((error) => {
    console.error('Error:', error)
  })
```

- In this case, even though `promise1` rejects, `promise2` resolves first, so `Promise.race()` resolves.

---

## **Asynchronous Patterns**

### **Sequential vs. Parallel Execution**

**Sequential Execution**:

- Operations are performed one after another.
- Each operation waits for the previous one to complete.

**Example**:

```javascript
doTask1()
  .then((result1) => doTask2(result1))
  .then((result2) => doTask3(result2))
  .then((result3) => console.log('Final Result:', result3))
  .catch((error) => console.error('Error:', error))
```

**Parallel Execution**:

- Multiple operations are initiated at the same time.
- Execution does not wait for other operations to complete.

**Example**:

```javascript
const promise1 = doTask1()
const promise2 = doTask2()
const promise3 = doTask3()

Promise.all([promise1, promise2, promise3])
  .then((results) => {
    console.log('Results:', results)
  })
  .catch((error) => console.error('Error:', error))
```

### **Combining Promises**

**Example: Fetching Multiple URLs**

```javascript
function fetchUrl(url) {
  return fetch(url).then((response) => response.json())
}

const urls = ['https://api.example.com/data1', 'https://api.example.com/data2']

const promises = urls.map((url) => fetchUrl(url))

Promise.all(promises)
  .then((results) => {
    console.log('Data:', results)
  })
  .catch((error) => console.error('Error:', error))
```

### **Error Handling in Promises**

- Errors propagate down the promise chain until they are caught.
- Use `.catch()` at the end of the chain to handle errors.

**Example:**

```javascript
doTask1()
  .then((result1) => {
    return doTask2(result1)
  })
  .then((result2) => {
    return doTask3(result2)
  })
  .catch((error) => {
    console.error('Error occurred:', error)
  })
```

- If any of the tasks reject, the error is caught in the `.catch()` block.

---

## **Best Practices**

### **Always Return Promises**

- Ensure that you return promises from functions to maintain the chain.

**Bad:**

```javascript
function doTask() {
  new Promise((resolve, reject) => {
    // Asynchronous operation
  })
}
```

**Good:**

```javascript
function doTask() {
  return new Promise((resolve, reject) => {
    // Asynchronous operation
  })
}
```

### **Handle Errors Appropriately**

- Always add a `.catch()` handler to your promise chains.

**Example:**

```javascript
promise
  .then((result) => {
    // Handle result
  })
  .catch((error) => {
    // Handle error
  })
```

### **Use `Promise.allSettled()` for Independent Promises**

- If you have multiple promises and you want to wait for all of them to settle regardless of whether they fulfill or reject, use `Promise.allSettled()`.

**Example:**

```javascript
Promise.allSettled([promise1, promise2, promise3]).then((results) => {
  results.forEach((result) => {
    if (result.status === 'fulfilled') {
      console.log('Fulfilled:', result.value)
    } else {
      console.error('Rejected:', result.reason)
    }
  })
})
```

### **Avoid the Promise Constructor Anti-Pattern**

- Do not wrap promises inside new promises unnecessarily.

**Anti-Pattern:**

```javascript
function fetchData() {
  return new Promise((resolve, reject) => {
    fetch(url)
      .then((response) => resolve(response))
      .catch((error) => reject(error))
  })
}
```

**Better Approach:**

```javascript
function fetchData() {
  return fetch(url)
}
```

### **Use Async/Await for Simplicity**

- For sequential asynchronous operations, consider using `async/await` syntax.

**Example:**

```javascript
async function processTasks() {
  try {
    const result1 = await doTask1()
    const result2 = await doTask2(result1)
    const result3 = await doTask3(result2)
    console.log('Final Result:', result3)
  } catch (error) {
    console.error('Error:', error)
  }
}

processTasks()
```

---

## **Common Interview Questions**

1. **What is a Promise in JavaScript, and why is it useful?**

   **Answer:**

   - A Promise is an object representing the eventual completion or failure of an asynchronous operation.
   - It provides a cleaner, more manageable way to handle asynchronous code compared to callbacks.
   - Promises help avoid callback hell, improve error handling, and allow for chaining and composing asynchronous operations.

2. **Explain how `Promise.all()` works and when you would use it.**

   **Answer:**

   - `Promise.all()` accepts an iterable of promises and returns a new promise.
   - It resolves when all the input promises have resolved, with an array of their results.
   - It rejects immediately if any of the input promises reject, with the reason from the first promise that rejects.
   - Use `Promise.all()` when you need to perform multiple asynchronous operations in parallel and wait for all of them to complete before proceeding.

3. **What is the difference between `Promise.all()` and `Promise.race()`?**

   **Answer:**

   - **`Promise.all()`**:

     - Waits for all promises to fulfill or any to reject.
     - Resolves with an array of results when all promises fulfill.
     - Rejects immediately when any promise rejects.

   - **`Promise.race()`**:

     - Returns a promise that fulfills or rejects as soon as one of the promises fulfills or rejects.
     - Resolves or rejects with the value or reason from the first settled promise.

4. **How do you handle errors in promise chains?**

   **Answer:**

   - Errors in a promise chain can be handled using the `.catch()` method.
   - If any promise in the chain rejects or throws an error, the control passes to the nearest `.catch()` handler.
   - It's good practice to place a `.catch()` at the end of the chain to handle any errors that may occur.

5. **Can you explain the Promise constructor anti-pattern?**

   **Answer:**

   - The Promise constructor anti-pattern involves creating a new Promise and unnecessarily wrapping code that already returns a promise.
   - This results in more complex code without any benefit.
   - Instead, you should return the existing promise directly.

   **Anti-Pattern Example:**

   ```javascript
   function badFunction() {
     return new Promise((resolve, reject) => {
       existingPromise.then(resolve).catch(reject)
     })
   }
   ```

   **Correct Approach:**

   ```javascript
   function goodFunction() {
     return existingPromise
   }
   ```

---

## **Exercises**

### **Exercise 1: Creating and Handling Promises**

**Question:**

Create a promise that resolves with the value "Hello, World!" after 2 seconds. Handle the promise to log the resolved value to the console.

**Answer:**

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Hello, World!')
  }, 2000)
})

promise.then((message) => {
  console.log(message) // Outputs after 2 seconds: Hello, World!
})
```

---

### **Exercise 2: Chaining Promises**

**Question:**

Given the following functions that return promises:

```javascript
function doubleAfter2Seconds(x) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(x * 2)
    }, 2000)
  })
}
```

Chain three calls to `doubleAfter2Seconds` to compute `((10 * 2) * 2) * 2` and log the result.

**Answer:**

```javascript
doubleAfter2Seconds(10)
  .then((result1) => {
    return doubleAfter2Seconds(result1)
  })
  .then((result2) => {
    return doubleAfter2Seconds(result2)
  })
  .then((finalResult) => {
    console.log('Final Result:', finalResult) // Outputs: Final Result: 80
  })
```

---

### **Exercise 3: Using `Promise.all()`**

**Question:**

You have three functions that return promises resolving to different numbers after different delays:

```javascript
function getNumber1() {
  return new Promise((resolve) => setTimeout(() => resolve(5), 1000))
}

function getNumber2() {
  return new Promise((resolve) => setTimeout(() => resolve(10), 2000))
}

function getNumber3() {
  return new Promise((resolve) => setTimeout(() => resolve(15), 1500))
}
```

Use `Promise.all()` to compute the sum of these numbers once all promises have resolved.

**Answer:**

```javascript
Promise.all([getNumber1(), getNumber2(), getNumber3()])
  .then((numbers) => {
    const sum = numbers.reduce((acc, n) => acc + n, 0)
    console.log('Sum:', sum) // Outputs: Sum: 30
  })
  .catch((error) => console.error('Error:', error))
```

---

### **Exercise 4: Using `Promise.race()`**

**Question:**

Create two promises:

- One that resolves with "First" after 3 seconds.
- Another that resolves with "Second" after 1 second.

Use `Promise.race()` to log the result of the promise that resolves first.

**Answer:**

```javascript
const promise1 = new Promise((resolve) => setTimeout(resolve, 3000, 'First'))
const promise2 = new Promise((resolve) => setTimeout(resolve, 1000, 'Second'))

Promise.race([promise1, promise2])
  .then((result) => {
    console.log('Result:', result) // Outputs: Result: Second
  })
  .catch((error) => console.error('Error:', error))
```

---

### **Exercise 5: Error Handling in Promises**

**Question:**

Modify the following code to catch and handle the error:

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('Something went wrong'))
  }, 1000)
})

promise.then((result) => {
  console.log('Result:', result)
})
```

**Answer:**

```javascript
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    reject(new Error('Something went wrong'))
  }, 1000)
})

promise
  .then((result) => {
    console.log('Result:', result)
  })
  .catch((error) => {
    console.error('Error:', error.message) // Outputs: Error: Something went wrong
  })
```

---

## **Conclusion**

Promises are a fundamental part of modern JavaScript, providing a powerful way to handle asynchronous operations. By understanding how to create and handle promises, and how to use methods like `Promise.all()` and `Promise.race()`, you can write more efficient and maintainable asynchronous code. Mastering these concepts not only enhances your coding skills but also prepares you for technical interviews and complex development challenges.

---

## **Next Steps**

- **Practice:**

  - Write code that uses promises to handle real-world asynchronous operations like fetching data from APIs.
  - Convert callback-based asynchronous functions to return promises.

- **Explore:**

  - Learn about `async/await` syntax for handling promises more elegantly.
  - Study `Promise.allSettled()` and `Promise.any()` for additional promise handling patterns.

- **Prepare:**

  - Review and answer additional interview questions on promises and asynchronous patterns.
  - Explain these concepts to a peer or through writing to reinforce your understanding.

---

**Continue enhancing your JavaScript expertise by mastering promises and asynchronous patterns!**

---

## **Appendix**

### **Glossary**

- **Promise**: An object representing the eventual completion or failure of an asynchronous operation.

- **Fulfilled**: The state of a promise that has successfully completed.

- **Rejected**: The state of a promise that has failed.

- **Pending**: The initial state of a promise, neither fulfilled nor rejected.

- **Executor Function**: The function passed to the `Promise` constructor, which receives `resolve` and `reject` functions.

- **`Promise.all()`**: A method that waits for all promises in an iterable to fulfill or any to reject.

- **`Promise.race()`**: A method that returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects.

- **`Promise.allSettled()`**: A method that waits for all promises to settle (either fulfilled or rejected) and returns an array of their results.

- **Async/Await**: Syntactic sugar over promises, allowing asynchronous code to be written in a synchronous style.

---

**End of Lesson**
