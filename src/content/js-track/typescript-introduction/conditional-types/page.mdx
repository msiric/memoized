export const metadata = {   title: "Mapped and Conditional Types in TypeScript",   description: "Advance your TypeScript proficiency by mastering mapped and conditional types. This lesson explores the powerful features of the `keyof` and `typeof` operators, enabling you to create dynamic and flexible type definitions. Additionally, delve into conditional type expressions to build complex type logic that adapts based on input types. By understanding mapped and conditional types, you will enhance your ability to write expressive, type-safe, and maintainable TypeScript code. This comprehensive lesson will deepen your knowledge of TypeScript's advanced type system and prepare you for technical interviews by covering these essential topics.", }

# **Mapped and Conditional Types in TypeScript**

Mapped and conditional types are advanced features in TypeScript that allow developers to create sophisticated type transformations and logic. Mapped types enable you to create new types by transforming existing ones, while conditional types allow types to be defined based on conditions. This lesson covers how to effectively use the `keyof` and `typeof` operators, mapped types, and conditional type expressions to write more dynamic and flexible TypeScript code.



## **Introduction to Mapped and Conditional Types**

### **Overview of Advanced Type Features**

- **Mapped Types**: Types that transform properties in an existing type to create a new type.
- **Conditional Types**: Types that choose between two possible types based on a condition.
- **Operators**:
  - **`keyof`**: Creates a union of the keys of a type.
  - **`typeof`**: Gets the type of a value or variable.

### **Importance in TypeScript**

- **Type Transformation**: Enables dynamic creation and manipulation of types.
- **Type Safety**: Enhances code robustness by enforcing stricter type checks.
- **Code Reusability**: Facilitates the creation of generic and reusable type definitions.
- **Expressiveness**: Allows for complex type logic that adapts to different scenarios.

## **The `keyof` Operator**

### **Understanding `keyof`**

- **Definition**: The `keyof` operator takes an object type and produces a union of its keys.
- **Purpose**:
  - Extract property names from a type.
  - Useful for creating dynamic and type-safe property accessors.

### **Examples of `keyof` in Practice**

- **Basic Usage**:

  ```typescript
  interface Person {
    name: string
    age: number
    location: string
  }

  type PersonKeys = keyof Person // 'name' | 'age' | 'location'

  let key: PersonKeys = 'name' // Valid
  // key = 'height'; // Error: Type '"height"' is not assignable to type 'PersonKeys'
  ```

- **Using with Generics**:

  ```typescript
  function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key]
  }

  let person: Person = { name: 'Alice', age: 30, location: 'Wonderland' }
  let age = getProperty(person, 'age') // Type is number
  ```

- **Benefits**:
  - Enforces that only valid property names can be used.
  - Improves type safety in functions that operate on object properties.

## **The `typeof` Operator**

### **Type Queries with `typeof`**

- **Definition**: The `typeof` operator, when used in a type context, obtains the type of a value or variable.
- **Purpose**:
  - Capture the type of an existing variable or object.
  - Useful for creating types based on values.

### **Using `typeof` in Type Definitions**

- **Basic Usage**:

  ```typescript
  let s = 'hello'
  type Str = typeof s // Type is 'string'

  const person = { name: 'Bob', age: 25 }
  type PersonType = typeof person // { name: string; age: number; }
  ```

- **Creating Aliases**:

  ```typescript
  function greet(person: typeof person): void {
    console.log(`Hello, ${person.name}`)
  }

  greet({ name: 'Alice', age: 30 })
  ```

- **Using with `keyof`**:

  ```typescript
  type PersonKeys = keyof typeof person // 'name' | 'age'
  ```

- **Benefits**:
  - Eliminates duplication of type definitions.
  - Ensures consistency between variables and their types.

## **Mapped Types**

### **What are Mapped Types?**

- **Definition**: Mapped types create new types by transforming each property of an existing type.
- **Purpose**:
  - Apply a transformation to each property in a type.
  - Create variations of existing types (e.g., making all properties optional or readonly).

### **Basic Mapped Type Syntax**

- **Syntax**:

  ```typescript
  type MappedType = { [P in K]: T }
  ```

  - **`P`**: The property name variable.
  - **`K`**: A union of property names (often `keyof T`).
  - **`T`**: The type being mapped.

- **Example**:

  ```typescript
  type Readonly<T> = {
    readonly [P in keyof T]: T[P]
  }

  interface Person {
    name: string
    age: number
  }

  type ReadonlyPerson = Readonly<Person>

  const person: ReadonlyPerson = { name: 'Alice', age: 30 }
  // person.age = 31; // Error: Cannot assign to 'age' because it is a read-only property.
  ```

### **Using Mapped Types with `keyof`**

- **Creating Partial Types**:

  ```typescript
  type Partial<T> = {
    [P in keyof T]?: T[P]
  }

  type PartialPerson = Partial<Person>

  let partialPerson: PartialPerson = { name: 'Bob' } // 'age' is optional
  ```

- **Filtering Properties**:

  ```typescript
  type Pick<T, K extends keyof T> = {
    [P in K]: T[P]
  }

  type PersonName = Pick<Person, 'name'>

  let personName: PersonName = { name: 'Charlie' }
  ```

- **Modifying Property Types**:

  ```typescript
  type Record<K extends keyof any, T> = {
    [P in K]: T
  }

  type StringMap = Record<'a' | 'b' | 'c', string>

  let stringMap: StringMap = { a: 'foo', b: 'bar', c: 'baz' }
  ```

## **Conditional Types**

### **What are Conditional Types?**

- **Definition**: Conditional types allow types to be defined based on conditions, using a syntax similar to ternary operators.
- **Syntax**:

  ```typescript
  T extends U ? X : Y
  ```

  - If type `T` extends type `U`, then the type resolves to `X`; otherwise, it resolves to `Y`.

### **Syntax of Conditional Types**

- **Basic Example**:

  ```typescript
  type NonNullable<T> = T extends null | undefined ? never : T

  type A = NonNullable<string | null> // string
  type B = NonNullable<number | undefined> // number
  type C = NonNullable<string | null | undefined> // string
  ```

- **Using in Type Aliases**:

  ```typescript
  type IsString<T> = T extends string ? true : false

  type A = IsString<'hello'> // true
  type B = IsString<42> // false
  ```

### **Practical Examples**

- **Extracting Types**:

  ```typescript
  type Extract<T, U> = T extends U ? T : never

  type T0 = Extract<'a' | 'b' | 'c', 'a' | 'f'> // 'a'
  ```

- **Excluding Types**:

  ```typescript
  type Exclude<T, U> = T extends U ? never : T

  type T1 = Exclude<'a' | 'b' | 'c', 'a' | 'f'> // 'b' | 'c'
  ```

- **Inferring Types**:

  ```typescript
  type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any

  function getUser() {
    return { name: 'Alice', age: 30 }
  }

  type UserType = ReturnType<typeof getUser> // { name: string; age: number; }
  ```

## **Distributive Conditional Types**

### **Understanding Distributive Behavior**

- **Definition**: Conditional types distribute over unions. When a conditional type operates on a union type, it is applied to each member of the union individually.

- **Example**:

  ```typescript
  type NonNullable<T> = T extends null | undefined ? never : T

  type T0 = NonNullable<string | number | undefined> // string | number
  ```

- **Visualization**:

  ```
  NonNullable<string | number | undefined>
  =>
  NonNullable<string> | NonNullable<number> | NonNullable<undefined>
  =>
  string | number | never
  =>
  string | number
  ```

### **Common Use Cases**

- **Filtering Union Types**:

  - **Exclude** and **Extract** types are examples of distributive conditional types used to filter union types.

- **Applying Transformations**:

  - Modifying each member of a union type individually.

- **Example**:

  ```typescript
  type PromiseType<T> = T extends Promise<infer U> ? U : T

  type T1 = PromiseType<Promise<string>> // string
  type T2 = PromiseType<string> // string
  ```

## **Built-in Utility Types**

TypeScript provides several built-in utility types that leverage mapped and conditional types.

### **Partial**

- **Definition**: Constructs a type with all properties of `T` set to optional.

- **Syntax**:

  ```typescript
  type Partial<T> = {
    [P in keyof T]?: T[P]
  }
  ```

- **Example**:

  ```typescript
  interface User {
    id: number
    name: string
    email: string
  }

  type PartialUser = Partial<User>

  let user: PartialUser = { name: 'Alice' } // 'id' and 'email' are optional
  ```

### **Readonly**

- **Definition**: Constructs a type with all properties of `T` set to readonly.

- **Syntax**:

  ```typescript
  type Readonly<T> = {
    readonly [P in keyof T]: T[P]
  }
  ```

- **Example**:

  ```typescript
  type ReadonlyUser = Readonly<User>

  const user: ReadonlyUser = { id: 1, name: 'Bob', email: 'bob@example.com' }
  // user.name = 'Robert'; // Error: Cannot assign to 'name' because it is a read-only property.
  ```

### **Pick**

- **Definition**: Constructs a type by picking a set of properties `K` from `T`.

- **Syntax**:

  ```typescript
  type Pick<T, K extends keyof T> = {
    [P in K]: T[P]
  }
  ```

- **Example**:

  ```typescript
  type UserPreview = Pick<User, 'id' | 'name'>

  let userPreview: UserPreview = { id: 1, name: 'Charlie' }
  ```

### **Record**

- **Definition**: Constructs a type with a set of properties `K` of type `T`.

- **Syntax**:

  ```typescript
  type Record<K extends keyof any, T> = {
    [P in K]: T
  }
  ```

- **Example**:

  ```typescript
  type Roles = 'admin' | 'user' | 'guest'

  type Permissions = Record<Roles, boolean>

  let permissions: Permissions = {
    admin: true,
    user: true,
    guest: false,
  }
  ```

### **Exclude**

- **Definition**: Excludes from `T` those types that are assignable to `U`.

- **Syntax**:

  ```typescript
  type Exclude<T, U> = T extends U ? never : T
  ```

- **Example**:

  ```typescript
  type T0 = Exclude<'a' | 'b' | 'c', 'a' | 'f'> // 'b' | 'c'
  ```

### **Extract**

- **Definition**: Extracts from `T` those types that are assignable to `U`.

- **Syntax**:

  ```typescript
  type Extract<T, U> = T extends U ? T : never
  ```

- **Example**:

  ```typescript
  type T1 = Extract<'a' | 'b' | 'c', 'a' | 'f'> // 'a'
  ```

### **NonNullable**

- **Definition**: Excludes `null` and `undefined` from `T`.

- **Syntax**:

  ```typescript
  type NonNullable<T> = T extends null | undefined ? never : T
  ```

- **Example**:

  ```typescript
  type T2 = NonNullable<string | number | undefined> // string | number
  ```

### **ReturnType**

- **Definition**: Obtains the return type of a function type.

- **Syntax**:

  ```typescript
  type ReturnType<T extends (...args: any) => any> = T extends (
    ...args: any
  ) => infer R
    ? R
    : any
  ```

- **Example**:

  ```typescript
  function getUser() {
    return { id: 1, name: 'Alice' }
  }

  type UserType = ReturnType<typeof getUser> // { id: number; name: string; }
  ```

## **Advanced Examples**

### **Building Custom Utility Types**

- **DeepPartial**: Makes all properties in a type and its sub-types optional.

  ```typescript
  type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
  }

  interface User {
    id: number
    name: string
    address: {
      street: string
      city: string
    }
  }

  type PartialUser = DeepPartial<User>

  let user: PartialUser = {
    name: 'Bob',
    address: {
      city: 'New York',
    },
  }
  ```

- **Mutable**: Removes readonly modifiers from all properties.

  ```typescript
  type Mutable<T> = {
    -readonly [P in keyof T]: T[P]
  }

  type MutableUser = Mutable<ReadonlyUser>

  let mutableUser: MutableUser = {
    id: 1,
    name: 'Charlie',
    email: 'charlie@example.com',
  }
  mutableUser.name = 'Charles' // Now allowed
  ```

### **Real-world Applications**

- **API Response Types**:

  ```typescript
  type ApiResponse<T> = {
    data: T
    error?: string
  }

  interface User {
    id: number
    name: string
  }

  type UserResponse = ApiResponse<User>

  let response: UserResponse = { data: { id: 1, name: 'Alice' } }
  ```

- **Event Handlers**:

  ```typescript
  type EventHandlers<T> = {
    [K in keyof T as `on${Capitalize<string & K>}`]?: (value: T[K]) => void
  }

  interface FormFields {
    name: string
    age: number
  }

  type FormEventHandlers = EventHandlers<FormFields>

  let handlers: FormEventHandlers = {
    onName: (name) => console.log(`Name changed to ${name}`),
    onAge: (age) => console.log(`Age changed to ${age}`),
  }
  ```

## **Best Practices**

- **Leverage Built-in Utility Types**:

  - Use TypeScript's provided utility types before creating custom ones.

- **Understand Distributive Conditional Types**:

  - Be aware of how conditional types distribute over unions to avoid unexpected results.

- **Use Descriptive Type Parameter Names**:

  - Improve code readability by using meaningful names in mapped and conditional types.

- **Avoid Overcomplicating Types**:

  - Keep type definitions as simple as possible to maintain code clarity.

- **Test Complex Types**:

  - Use type assertions and assignments to validate complex type logic during development.

- **Keep Type Transformations Predictable**:
  - Ensure that mapped and conditional types behave as expected across different scenarios.

## **Exercises**

### **Exercise 1: Using `keyof` Operator**

**Question**:

Given the interface `Product`, define a type `ProductKeys` that represents all keys of `Product`. Then, write a function `getValue` that takes a `Product` and a key of `ProductKeys`, and returns the value corresponding to that key.

```typescript
interface Product {
  id: number
  name: string
  price: number
}
```

**Answer**:

```typescript
type ProductKeys = keyof Product // 'id' | 'name' | 'price'

function getValue(product: Product, key: ProductKeys): Product[ProductKeys] {
  return product[key]
}

// Usage
const product: Product = { id: 1, name: 'Laptop', price: 1200 }
console.log(getValue(product, 'name')) // Outputs: 'Laptop'
```

### **Exercise 2: Mapped Types**

**Question**:

Create a mapped type `Nullable<T>` that makes all properties of `T` nullable. Apply this type to an interface `User` and create an object with some properties set to `null`.

```typescript
interface User {
  id: number
  name: string
  email: string
}
```

**Answer**:

```typescript
type Nullable<T> = {
  [P in keyof T]: T[P] | null
}

type NullableUser = Nullable<User>

let user: NullableUser = {
  id: null,
  name: 'Alice',
  email: null,
}
```

### **Exercise 3: Conditional Types**

**Question**:

Define a conditional type `IsArray<T>` that checks if `T` is an array type. It should resolve to `true` if `T` is an array, and `false` otherwise. Test this type with different inputs.

**Answer**:

```typescript
type IsArray<T> = T extends any[] ? true : false

type Test1 = IsArray<string[]> // true
type Test2 = IsArray<number> // false
type Test3 = IsArray<boolean[]> // true
```

### **Exercise 4: Built-in Utility Types**

**Question**:

Using the built-in utility types, define a type `UserPreview` that includes only the `id` and `name` properties from the `User` interface.

```typescript
interface User {
  id: number
  name: string
  email: string
}
```

**Answer**:

```typescript
type UserPreview = Pick<User, 'id' | 'name'>

let userPreview: UserPreview = { id: 1, name: 'Bob' }
```

### **Exercise 5: Custom Utility Type**

**Question**:

Create a custom utility type `RequiredKeys<T>` that extracts the keys of `T` that are required (not optional). Apply this type to an interface and test it.

```typescript
interface Person {
  id: number
  name?: string
  age: number
}
```

**Answer**:

```typescript
type RequiredKeys<T> = {
  [K in keyof T]-?: T extends Record<K, T[K]> ? K : never
}[keyof T]

type PersonRequiredKeys = RequiredKeys<Person> // 'id' | 'age'
```


Mapped and conditional types are advanced features in TypeScript that empower developers to create dynamic, flexible, and type-safe code. By leveraging the `keyof` and `typeof` operators, you can manipulate and infer types based on existing structures and values. Mapped types allow you to transform types systematically, while conditional types enable you to define types that adapt based on conditions. Mastery of these advanced type system features enhances your ability to build robust TypeScript applications and prepares you for complex development challenges and technical interviews.
