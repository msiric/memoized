**Lesson Title**: **Enums and Literal Types in TypeScript**

**Lesson Description**:  
Enhance your TypeScript proficiency by mastering enums and literal types. This lesson focuses on understanding numeric and string enums, their usage, and benefits. Additionally, explore literal type constraints to define exact values a variable can hold, enabling you to create more precise and type-safe code. By learning about enums and literal types, you will gain the ability to write more expressive and robust TypeScript applications. This comprehensive lesson will deepen your understanding of TypeScript's type system and prepare you for technical interviews by covering these essential topics.

---

# **Enums and Literal Types in TypeScript**

Enums (short for enumerations) and literal types are powerful features in TypeScript that allow developers to define a set of named constants and restrict variables to specific values. Enums help in creating a collection of related values that can be numeric or string-based, improving code readability and maintainability. Literal types enable you to specify exact values for variables, enhancing type safety. This lesson delves into how to use enums and literal types effectively in TypeScript.

---

## **Table of Contents**

1. **Introduction to Enums**
   - What are Enums?
   - Benefits of Using Enums
2. **Numeric Enums**
   - Defining Numeric Enums
   - Auto-incrementing Behavior
   - Customizing Enum Values
3. **String Enums**
   - Defining String Enums
   - Differences from Numeric Enums
4. **Heterogeneous Enums**
   - Mixing Numeric and String Values
   - Use Cases and Considerations
5. **Enum Members**
   - Constant vs. Computed Members
   - Enum Member Types
6. **Enums at Runtime**
   - Reverse Mapping
   - Using Enums in Code
7. **Literal Types**
   - String Literal Types
   - Numeric Literal Types
   - Boolean Literal Types
8. **Type Aliases with Literal Types**
   - Union of Literal Types
   - Creating Custom Types
9. **Discriminated Unions**
   - Combining Enums and Literal Types
   - Pattern Matching with Type Guards
10. **Best Practices**
11. **Common Interview Questions**
12. **Exercises**
13. **Conclusion**
14. **Next Steps**
15. **Appendix**

---

## **Introduction to Enums**

### **What are Enums?**

- **Definition**: Enums are a way to define a set of named constants, which can be either numeric or string values.
- **Purpose**:
  - Provide meaningful names to numeric or string values.
  - Enhance code readability and maintainability.
  - Group related constants together.

### **Benefits of Using Enums**

- **Type Safety**: Enums are types in TypeScript, allowing for compile-time checks.
- **IntelliSense Support**: Enums provide better tooling support, including autocompletion.
- **Self-Documenting Code**: Using enums makes code more understandable by replacing magic numbers or strings with meaningful names.
- **Preventing Invalid Values**: Enums restrict values to a predefined set.

---

## **Numeric Enums**

Numeric enums are the default in TypeScript and assign numeric values to enum members.

### **Defining Numeric Enums**

- **Syntax**:

  ```typescript
  enum EnumName {
    Member1,
    Member2,
    Member3,
    // ...
  }
  ```

- **Example**:

  ```typescript
  enum Direction {
    North,
    East,
    South,
    West,
  }
  ```

### **Auto-incrementing Behavior**

- **Default Values**:

  - The first member defaults to `0`.
  - Subsequent members auto-increment by `1`.

- **Example**:

  ```typescript
  enum Direction {
    North, // 0
    East, // 1
    South, // 2
    West, // 3
  }

  let dir: Direction = Direction.North
  console.log(dir) // Outputs: 0
  ```

### **Customizing Enum Values**

- **Assigning Specific Values**:

  ```typescript
  enum Status {
    Success = 200,
    NotFound = 404,
    ServerError = 500,
  }
  ```

- **Auto-increment from Custom Value**:

  - If you assign a value to the first member, the subsequent members increment from that value.

  ```typescript
  enum Status {
    Success = 200,
    NotFound, // 201
    ServerError, // 202
  }
  ```

- **Assigning Values to All Members**:

  - You can assign specific values to each member.

  ```typescript
  enum Status {
    Success = 200,
    NotFound = 404,
    ServerError = 500,
  }
  ```

---

## **String Enums**

String enums are enums where each member is initialized with a string literal.

### **Defining String Enums**

- **Syntax**:

  ```typescript
  enum EnumName {
    Member1 = 'value1',
    Member2 = 'value2',
    // ...
  }
  ```

- **Example**:

  ```typescript
  enum Direction {
    North = 'NORTH',
    East = 'EAST',
    South = 'SOUTH',
    West = 'WEST',
  }

  let dir: Direction = Direction.North
  console.log(dir) // Outputs: 'NORTH'
  ```

### **Differences from Numeric Enums**

- **No Auto-incrementing**: Each member must be initialized with a string value.
- **No Reverse Mapping**: String enums do not have reverse mapping at runtime.
- **Useful for Serialization**: String values are more readable and useful when serializing data.

---

## **Heterogeneous Enums**

Enums that mix numeric and string members.

### **Mixing Numeric and String Values**

- **Syntax**:

  ```typescript
  enum MixedEnum {
    No = 0,
    Yes = 'YES',
  }
  ```

### **Use Cases and Considerations**

- **Use Cases**:

  - Rare and generally discouraged.
  - May be used when integrating with external libraries or APIs.

- **Considerations**:
  - Can lead to confusion and should be used sparingly.
  - Stick to either numeric or string enums for consistency.

---

## **Enum Members**

Enum members can be constant or computed.

### **Constant vs. Computed Members**

- **Constant Members**:

  - Simple expressions that can be evaluated at compile time.
  - Examples: Numeric literals, other enum members, mathematical operations.

- **Computed Members**:

  - Evaluated at runtime.
  - Must come after constant members.

- **Example**:

  ```typescript
  enum FileAccess {
    None, // 0
    Read = 1 << 1, // 2
    Write = 1 << 2, // 4
    ReadWrite = Read | Write, // 6
    G = '123'.length, // Computed member, value is 3
  }
  ```

### **Enum Member Types**

- **Numeric Enums**: Can have constant or computed members.
- **String Enums**: Members must have constant string values.

---

## **Enums at Runtime**

Enums are objects that exist at runtime.

### **Reverse Mapping**

- **Numeric Enums Support Reverse Mapping**:

  ```typescript
  enum Direction {
    North,
    East,
    South,
    West,
  }

  console.log(Direction[0]) // Outputs: 'North'
  console.log(Direction['North']) // Outputs: 0
  ```

- **String Enums Do Not Support Reverse Mapping**:

  ```typescript
  enum Direction {
    North = 'NORTH',
    East = 'EAST',
  }

  // Direction['NORTH'] is undefined
  ```

### **Using Enums in Code**

- **Comparisons**:

  ```typescript
  enum Status {
    Active,
    Inactive,
    Pending,
  }

  let currentStatus: Status = Status.Active

  if (currentStatus === Status.Active) {
    console.log('Status is active.')
  }
  ```

- **Functions with Enums**:

  ```typescript
  function respond(status: Status): void {
    // ...
  }

  respond(Status.Pending)
  ```

---

## **Literal Types**

Literal types allow you to specify exact values a variable can hold.

### **String Literal Types**

- **Definition**: Type of a variable must be a specific string value.

- **Syntax**:

  ```typescript
  let variableName: 'value1' | 'value2' | 'value3'
  ```

- **Example**:

  ```typescript
  type Direction = 'North' | 'East' | 'South' | 'West'

  let move: Direction

  move = 'North' // Valid
  move = 'Up' // Error: Type '"Up"' is not assignable to type 'Direction'.
  ```

### **Numeric Literal Types**

- **Definition**: Type of a variable must be a specific numeric value.

- **Example**:

  ```typescript
  type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6

  function rollDice(): DiceRoll {
    return (Math.floor(Math.random() * 6) + 1) as DiceRoll
  }
  ```

### **Boolean Literal Types**

- **Definition**: Type is either `true` or `false`.

- **Example**:

  ```typescript
  type Yes = true
  type No = false

  let answer: Yes | No

  answer = true // Valid
  answer = false // Valid
  answer = 'yes' // Error
  ```

---

## **Type Aliases with Literal Types**

Type aliases can be used to create custom types from literal types.

### **Union of Literal Types**

- **Example**:

  ```typescript
  type CardinalDirection = 'North' | 'East' | 'South' | 'West'

  function move(direction: CardinalDirection): void {
    // Implementation
  }

  move('North') // Valid
  move('Up') // Error
  ```

### **Creating Custom Types**

- **Example with Status Codes**:

  ```typescript
  type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'

  function request(url: string, method: HTTPMethod): void {
    // Implementation
  }

  request('/api/users', 'GET') // Valid
  request('/api/users', 'PATCH') // Error
  ```

---

## **Discriminated Unions**

Combining enums or literal types with type aliases to create flexible and type-safe code.

### **Combining Enums and Literal Types**

- **Example**:

  ```typescript
  interface Circle {
    kind: 'circle'
    radius: number
  }

  interface Rectangle {
    kind: 'rectangle'
    width: number
    height: number
  }

  type Shape = Circle | Rectangle

  function area(shape: Shape): number {
    if (shape.kind === 'circle') {
      return Math.PI * shape.radius ** 2
    } else if (shape.kind === 'rectangle') {
      return shape.width * shape.height
    } else {
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck // Error if a new shape is added and not handled
    }
  }
  ```

### **Pattern Matching with Type Guards**

- **Using `switch` Statements**:

  ```typescript
  function area(shape: Shape): number {
    switch (shape.kind) {
      case 'circle':
        return Math.PI * shape.radius ** 2
      case 'rectangle':
        return shape.width * shape.height
      default:
        const _exhaustiveCheck: never = shape
        return _exhaustiveCheck
    }
  }
  ```

- **Benefits**:
  - Compiler ensures all cases are handled.
  - If a new type is added to `Shape`, TypeScript will error if it's not handled.

---

## **Best Practices**

- **Use Enums for Related Constants**:

  - Group related constants for better organization.

- **Prefer String Enums When Readability Matters**:

  - String enums are more readable when logging or serializing.

- **Use Literal Types for Specific Values**:

  - Enforce that variables can only hold certain values.

- **Combine Enums and Literal Types with Type Aliases**:

  - Create flexible and expressive types.

- **Use Discriminated Unions for Complex Types**:

  - Ensure exhaustive checks and type safety.

- **Avoid Heterogeneous Enums**:

  - Stick to either numeric or string enums for consistency.

- **Be Mindful of Enum Values**:
  - Explicitly assign values if necessary to prevent unintended increments.

---

## **Common Interview Questions**

1. **What is an enum in TypeScript, and why would you use one?**

   **Answer**:

   - An enum is a way to define a set of named constants, which can be either numeric or string values.
   - Enums provide type safety, improve code readability, and group related constants.
   - They help prevent invalid values by restricting variables to predefined options.

2. **Explain the difference between numeric enums and string enums in TypeScript.**

   **Answer**:

   - **Numeric Enums**:
     - Default in TypeScript.
     - Members are assigned numeric values starting from `0` by default.
     - Support auto-incrementing and reverse mapping.
   - **String Enums**:
     - Members are initialized with string literals.
     - No auto-incrementing; each member must have an explicit string value.
     - Do not support reverse mapping.
     - Useful for readability and serialization.

3. **What are literal types in TypeScript, and how do they differ from enums?**

   **Answer**:

   - Literal types allow variables to be restricted to exact values (e.g., specific strings or numbers).
   - They are defined using type aliases and unions of literal values.
   - Enums define a type and a set of named constants, which can be used as values.
   - Literal types are more flexible and can be combined with other types to create complex types.

4. **How can discriminated unions be used in TypeScript, and what are their benefits?**

   **Answer**:

   - Discriminated unions combine union types with literal types or enums to create a type-safe way of handling different variants of a type.
   - Each variant has a common property (the discriminant) with a literal type.
   - Benefits include:
     - Type safety through exhaustive checks.
     - Compiler assistance in ensuring all cases are handled.
     - Clear and maintainable code structure.

5. **Why might you avoid using heterogeneous enums in TypeScript?**

   **Answer**:

   - Heterogeneous enums mix numeric and string values.
   - They can lead to confusion and inconsistency.
   - May introduce unexpected behavior or bugs.
   - It's generally better to stick to either numeric or string enums for clarity and maintainability.

---

## **Exercises**

### **Exercise 1: Defining Numeric Enums**

**Question**:

Define a numeric enum `LogLevel` with the following members: `Error`, `Warn`, `Info`, `Debug`. Assign explicit values starting from `1` for `Error` and incrementing by `1` for each level.

**Answer**:

```typescript
enum LogLevel {
  Error = 1,
  Warn, // 2
  Info, // 3
  Debug, // 4
}

// Usage
let level: LogLevel = LogLevel.Warn
console.log(level) // Outputs: 2
```

---

### **Exercise 2: Defining String Enums**

**Question**:

Create a string enum `ResponseStatus` with the members `Success`, `Failure`, and `Pending`, assigned to the string values `'SUCCESS'`, `'FAILURE'`, and `'PENDING'` respectively.

**Answer**:

```typescript
enum ResponseStatus {
  Success = 'SUCCESS',
  Failure = 'FAILURE',
  Pending = 'PENDING',
}

// Usage
let status: ResponseStatus = ResponseStatus.Success
console.log(status) // Outputs: 'SUCCESS'
```

---

### **Exercise 3: Using Literal Types**

**Question**:

Define a type alias `HTTPMethod` that can be one of the strings `'GET'`, `'POST'`, `'PUT'`, or `'DELETE'`. Write a function `sendRequest` that accepts a URL and an HTTP method of type `HTTPMethod`.

**Answer**:

```typescript
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'

function sendRequest(url: string, method: HTTPMethod): void {
  console.log(`Sending ${method} request to ${url}`)
}

// Usage
sendRequest('/api/data', 'GET') // Valid
// sendRequest('/api/data', 'PATCH'); // Error
```

---

### **Exercise 4: Discriminated Unions**

**Question**:

Create interfaces `Square` and `Circle`, each with a `kind` property (literal type) and properties specific to their shape (`sideLength` for `Square`, `radius` for `Circle`). Define a type `Shape` as a union of `Square` and `Circle`. Write a function `calculateArea` that computes the area based on the shape type.

**Answer**:

```typescript
interface Square {
  kind: 'square'
  sideLength: number
}

interface Circle {
  kind: 'circle'
  radius: number
}

type Shape = Square | Circle

function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case 'square':
      return shape.sideLength ** 2
    case 'circle':
      return Math.PI * shape.radius ** 2
    default:
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck
  }
}

// Usage
const mySquare: Square = { kind: 'square', sideLength: 5 }
const myCircle: Circle = { kind: 'circle', radius: 3 }

console.log(calculateArea(mySquare)) // Outputs: 25
console.log(calculateArea(myCircle)) // Outputs: Approx. 28.27
```

---

### **Exercise 5: Enum Reverse Mapping**

**Question**:

Given the numeric enum `Color` below, demonstrate how to perform reverse mapping to get the name of a color when given its numeric value.

```typescript
enum Color {
  Red = 1,
  Green,
  Blue,
}
```

**Answer**:

```typescript
// Usage
let colorName: string = Color[2]
console.log(colorName) // Outputs: 'Green'

let colorValue: Color = Color.Blue
console.log(colorValue) // Outputs: 3
```

---

## **Conclusion**

Enums and literal types are powerful features in TypeScript that enhance code expressiveness and type safety. Enums provide a way to define a set of named constants, improving code readability and maintainability. Literal types allow developers to specify exact values a variable can hold, enabling the creation of precise and flexible types. By mastering enums and literal types, you can write more robust, type-safe, and expressive TypeScript applications, preparing you for advanced development tasks and technical interviews.

---

## **Next Steps**

- **Practice**:

  - Implement enums and literal types in your projects.
  - Experiment with discriminated unions and type guards.

- **Explore**:

  - Learn about advanced type features like mapped types and conditional types.
  - Study how enums and literal types interact with generics and interfaces.

- **Prepare**:

  - Review additional interview questions on TypeScript enums and type system.
  - Build projects using enums and literal types to reinforce your understanding.

---

**Continue enhancing your TypeScript expertise by mastering enums and literal types!**

---

## **Appendix**

### **Glossary**

- **Enum**: A way to define a set of named constants, which can be numeric or string values.
- **Numeric Enum**: An enum where members are assigned numeric values.
- **String Enum**: An enum where members are assigned string literal values.
- **Heterogeneous Enum**: An enum that mixes numeric and string members.
- **Literal Type**: A type that specifies an exact value a variable can hold (e.g., specific string or number).
- **Type Alias**: A way to create a new name for a type, including unions of literal types.
- **Discriminated Union**: A union of types that share a common property (the discriminant) with a literal type, enabling type-safe pattern matching.
- **Reverse Mapping**: In numeric enums, the ability to map from a numeric value back to the name of the enum member.

---

**End of Lesson**
