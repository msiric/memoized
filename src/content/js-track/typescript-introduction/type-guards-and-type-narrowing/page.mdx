export const metadata = {   title: "Type Guards and Type Narrowing in TypeScript",   description: "Enhance your TypeScript expertise by mastering type guards and type narrowing. This lesson delves into user-defined type guards and discriminated unions, powerful features that enable you to refine types at runtime and ensure type safety. By understanding how to implement custom type guards and leverage discriminated unions, you will be able to write more robust, maintainable, and type-safe TypeScript code. This comprehensive lesson will deepen your understanding of TypeScript's type system and prepare you for technical interviews by covering these essential topics.", }

# **Type Guards and Type Narrowing in TypeScript**

Type guards and type narrowing are essential features in TypeScript that allow developers to refine types at runtime, ensuring that variables are used safely and correctly. User-defined type guards enable you to create custom checks that inform the TypeScript compiler about the specific type of a variable. Discriminated unions simplify type checking for union types by using a common property (the discriminant). This lesson explores how to effectively use type guards and discriminated unions to write safer and more expressive TypeScript code.



## **Introduction to Type Guards and Type Narrowing**

### **Overview of Type Guards**

- **Definition**: Type guards are expressions that perform runtime checks, allowing TypeScript to narrow the type within a conditional block.
- **Purpose**:
  - Enable safe access to properties and methods specific to a type.
  - Improve code safety by informing the compiler about variable types.

### **Importance in TypeScript**

- **Type Safety**: Prevent runtime errors by ensuring variables are of the expected type.
- **Code Readability**: Clarify the developer's intent regarding type handling.
- **Expressiveness**: Allow complex type checks and refinements.

## **Understanding Type Guards**

### **Built-in Type Guards**

TypeScript provides built-in type guards using operators like `typeof` and `instanceof`.

### **Using `typeof` Operator**

- **Definition**: Checks the type of a variable at runtime.
- **Applicable Types**: `number`, `string`, `boolean`, `symbol`, `undefined`, `object`, `function`.

- **Syntax**:

  ```typescript
  if (typeof variable === 'type') {
    // variable is narrowed to 'type'
  }
  ```

- **Example**:

  ```typescript
  function padLeft(value: string, padding: string | number): string {
    if (typeof padding === 'number') {
      return ' '.repeat(padding) + value
    }
    if (typeof padding === 'string') {
      return padding + value
    }
    throw new Error(`Expected string or number, got '${typeof padding}'.`)
  }
  ```

### **Using `instanceof` Operator**

- **Definition**: Checks if an object is an instance of a class or constructor function.

- **Syntax**:

  ```typescript
  if (variable instanceof ClassName) {
    // variable is narrowed to 'ClassName'
  }
  ```

- **Example**:

  ```typescript
  class Dog {
    bark() {
      console.log('Woof!')
    }
  }

  class Cat {
    meow() {
      console.log('Meow!')
    }
  }

  function makeSound(animal: Dog | Cat): void {
    if (animal instanceof Dog) {
      animal.bark()
    } else if (animal instanceof Cat) {
      animal.meow()
    }
  }
  ```

## **User-Defined Type Guards**

### **What are User-Defined Type Guards?**

- **Definition**: Custom functions that perform type checks and inform the TypeScript compiler of the type of a variable within a specific scope.
- **Type Predicates**: Special return types in the form `parameterName is Type`.

### **Implementing Type Guards with Type Predicates**

- **Syntax**:

  ```typescript
  function isType(variable: any): variable is Type {
    // Type check logic
  }
  ```

- **Example**:

  ```typescript
  interface Fish {
    swim(): void
  }

  interface Bird {
    fly(): void
  }

  function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined
  }
  ```

### **Practical Examples**

- **Example 1: Checking Interface Implementation**

  ```typescript
  function move(animal: Fish | Bird): void {
    if (isFish(animal)) {
      animal.swim()
    } else {
      animal.fly()
    }
  }
  ```

- **Example 2: Validating Object Shape**

  ```typescript
  interface Car {
    make: string
    model: string
    drive(): void
  }

  function isCar(vehicle: any): vehicle is Car {
    return (
      vehicle &&
      typeof vehicle.make === 'string' &&
      typeof vehicle.model === 'string' &&
      typeof vehicle.drive === 'function'
    )
  }

  function operate(vehicle: any): void {
    if (isCar(vehicle)) {
      vehicle.drive()
    } else {
      console.log('Not a car.')
    }
  }
  ```

## **Type Narrowing**

### **Understanding Type Narrowing**

- **Definition**: The process by which TypeScript infers more specific types based on control flow analysis.
- **Purpose**: Allow the compiler to understand and enforce type constraints within different code paths.

### **Control Flow Analysis**

- TypeScript analyzes the flow of code to determine variable types at different points.
- Variables can have different types in different branches.

### **Narrowing with Conditionals**

- **Example**:

  ```typescript
  function processValue(value: string | number | boolean): void {
    if (typeof value === 'string') {
      // value is string
      console.log(value.toUpperCase())
    } else if (typeof value === 'number') {
      // value is number
      console.log(value.toFixed(2))
    } else {
      // value is boolean
      console.log(value ? 'True' : 'False')
    }
  }
  ```

- **Type Guards in Action**:
  - Using `typeof`, `instanceof`, custom type guards, and control flow statements to narrow types.

## **Discriminated Unions**

### **What are Discriminated Unions?**

- **Definition**: A union of types that have a common literal property (the discriminant), allowing the compiler to narrow types based on the value of that property.
- **Purpose**: Simplify type checking and ensure all possible types are handled.

### **Defining Discriminated Unions**

- **Structure**:

  ```typescript
  interface TypeA {
    kind: 'A'
    // properties specific to TypeA
  }

  interface TypeB {
    kind: 'B'
    // properties specific to TypeB
  }

  type UnionType = TypeA | TypeB
  ```

### **Using Discriminated Unions with `switch` Statements**

- **Example**:

  ```typescript
  interface Square {
    kind: 'square'
    size: number
  }

  interface Rectangle {
    kind: 'rectangle'
    width: number
    height: number
  }

  interface Circle {
    kind: 'circle'
    radius: number
  }

  type Shape = Square | Rectangle | Circle

  function area(shape: Shape): number {
    switch (shape.kind) {
      case 'square':
        return shape.size ** 2
      case 'rectangle':
        return shape.width * shape.height
      case 'circle':
        return Math.PI * shape.radius ** 2
      default:
        // Exhaustiveness checking
        const _exhaustiveCheck: never = shape
        return _exhaustiveCheck
    }
  }
  ```

## **Exhaustiveness Checking**

### **Ensuring All Cases are Handled**

- **Purpose**: Verify that all possible types in a union are accounted for.
- **Technique**: Use `never` type in the default case to trigger a compile-time error if a new type is added but not handled.

### **Using `never` Type for Exhaustiveness**

- **Example**:

  ```typescript
  function assertNever(value: never): never {
    throw new Error(`Unexpected value: ${value}`)
  }

  function area(shape: Shape): number {
    switch (shape.kind) {
      case 'square':
        return shape.size ** 2
      case 'rectangle':
        return shape.width * shape.height
      case 'circle':
        return Math.PI * shape.radius ** 2
      default:
        return assertNever(shape) // Compile-time error if 'shape' is not 'never'
    }
  }
  ```

- **Benefits**:
  - Catch errors during development when new types are added but not handled.
  - Improve code robustness.

## **Advanced Type Guards**

### **Type Guards with `in` Operator**

- **Definition**: Checks if an object has a specific property.

- **Syntax**:

  ```typescript
  if ('property' in variable) {
    // variable is narrowed to types that have 'property'
  }
  ```

- **Example**:

  ```typescript
  interface Admin {
    name: string
    privileges: string[]
  }

  interface Employee {
    name: string
    startDate: Date
  }

  type Staff = Admin | Employee

  function printStaffInfo(staff: Staff): void {
    console.log(`Name: ${staff.name}`)
    if ('privileges' in staff) {
      console.log(`Privileges: ${staff.privileges.join(', ')}`)
    }
    if ('startDate' in staff) {
      console.log(`Start Date: ${staff.startDate.toDateString()}`)
    }
  }
  ```

### **Type Guards with Custom Functions**

- **Complex Checks**:

  ```typescript
  function isDate(value: any): value is Date {
    return value instanceof Date && !isNaN(value.getTime())
  }

  function process(input: string | Date): void {
    if (isDate(input)) {
      console.log(`Date is ${input.toDateString()}`)
    } else {
      console.log(`String is ${input}`)
    }
  }
  ```

## **Best Practices**

- **Use Type Guards to Narrow Types Safely**:

  - Utilize built-in operators and custom type guards to inform the compiler about types.

- **Leverage Discriminated Unions**:

  - Simplify type checks by using a common discriminant property.

- **Implement Exhaustiveness Checking**:

  - Use `never` type to ensure all cases are handled, catching errors during development.

- **Keep Type Guards Simple and Readable**:

  - Write clear and concise type guard functions.

- **Avoid Overusing Type Assertions**:
  - Prefer type guards over type assertions to maintain type safety.

## **Exercises**

### **Exercise 1: Implementing a User-Defined Type Guard**

**Question**:

Define interfaces `Dog` with a method `bark()` and `Cat` with a method `meow()`. Write a user-defined type guard `isDog` to determine if an object is a `Dog`. Create a function `makeSound` that uses the type guard to call the appropriate method.

**Answer**:

```typescript
interface Dog {
  name: string
  bark(): void
}

interface Cat {
  name: string
  meow(): void
}

function isDog(pet: Dog | Cat): pet is Dog {
  return (pet as Dog).bark !== undefined
}

function makeSound(pet: Dog | Cat): void {
  if (isDog(pet)) {
    pet.bark()
  } else {
    pet.meow()
  }
}

// Usage
const dog: Dog = { name: 'Rex', bark: () => console.log('Woof!') }
const cat: Cat = { name: 'Whiskers', meow: () => console.log('Meow!') }

makeSound(dog) // Outputs: Woof!
makeSound(cat) // Outputs: Meow!
```

### **Exercise 2: Using Discriminated Unions**

**Question**:

Create a discriminated union `Vehicle` with types `Car` and `Boat`. Both should have a `type` property (`'car'` or `'boat'`). `Car` should have a `drive()` method, and `Boat` should have a `sail()` method. Write a function `operateVehicle` that uses a `switch` statement to call the appropriate method based on the `type`.

**Answer**:

```typescript
interface Car {
  type: 'car'
  drive(): void
}

interface Boat {
  type: 'boat'
  sail(): void
}

type Vehicle = Car | Boat

function operateVehicle(vehicle: Vehicle): void {
  switch (vehicle.type) {
    case 'car':
      vehicle.drive()
      break
    case 'boat':
      vehicle.sail()
      break
    default:
      const _exhaustiveCheck: never = vehicle
      return _exhaustiveCheck
  }
}

// Usage
const car: Car = { type: 'car', drive: () => console.log('Driving') }
const boat: Boat = { type: 'boat', sail: () => console.log('Sailing') }

operateVehicle(car) // Outputs: Driving
operateVehicle(boat) // Outputs: Sailing
```

### **Exercise 3: Type Guards with `in` Operator**

**Question**:

Define interfaces `Square` with a property `sideLength` and `Rectangle` with properties `width` and `height`. Write a function `calculateArea` that accepts a parameter of type `Square | Rectangle` and uses the `in` operator to determine the shape and calculate the area accordingly.

**Answer**:

```typescript
interface Square {
  sideLength: number
}

interface Rectangle {
  width: number
  height: number
}

function calculateArea(shape: Square | Rectangle): number {
  if ('sideLength' in shape) {
    return shape.sideLength ** 2
  } else if ('width' in shape && 'height' in shape) {
    return shape.width * shape.height
  }
  throw new Error('Invalid shape')
}

// Usage
const square: Square = { sideLength: 5 }
const rectangle: Rectangle = { width: 4, height: 6 }

console.log(calculateArea(square)) // Outputs: 25
console.log(calculateArea(rectangle)) // Outputs: 24
```

### **Exercise 4: Type Narrowing with Control Flow**

**Question**:

Write a function `formatInput` that accepts a parameter of type `string | number | string[]`. Use type narrowing to handle each type differently: if it's a string, return it in uppercase; if it's a number, return it formatted with two decimal places; if it's an array of strings, join them with commas.

**Answer**:

```typescript
function formatInput(input: string | number | string[]): string {
  if (typeof input === 'string') {
    return input.toUpperCase()
  } else if (typeof input === 'number') {
    return input.toFixed(2)
  } else if (Array.isArray(input)) {
    return input.join(', ')
  }
  throw new Error('Invalid input type')
}

// Usage
console.log(formatInput('hello')) // Outputs: HELLO
console.log(formatInput(3.14159)) // Outputs: 3.14
console.log(formatInput(['a', 'b', 'c'])) // Outputs: a, b, c
```

### **Exercise 5: Exhaustiveness Checking**

**Question**:

Given the discriminated union `Shape` with types `Circle`, `Square`, and `Triangle`, write a function `describeShape` that uses a `switch` statement to handle each shape. Implement exhaustiveness checking to ensure all possible types are covered.

**Answer**:

```typescript
interface Circle {
  kind: 'circle'
  radius: number
}

interface Square {
  kind: 'square'
  sideLength: number
}

interface Triangle {
  kind: 'triangle'
  base: number
  height: number
}

type Shape = Circle | Square | Triangle

function describeShape(shape: Shape): string {
  switch (shape.kind) {
    case 'circle':
      return `A circle with radius ${shape.radius}`
    case 'square':
      return `A square with side length ${shape.sideLength}`
    case 'triangle':
      return `A triangle with base ${shape.base} and height ${shape.height}`
    default:
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck
  }
}

// Usage
const circle: Circle = { kind: 'circle', radius: 5 }
console.log(describeShape(circle)) // Outputs: A circle with radius 5
```


Type guards and type narrowing are powerful features in TypeScript that enable developers to write safer and more expressive code. By implementing user-defined type guards and leveraging discriminated unions, you can refine types at runtime and ensure that your code handles all possible cases correctly. Understanding and utilizing these features will enhance your ability to build robust TypeScript applications and prepare you for complex development challenges and technical interviews.
