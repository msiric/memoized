**Lesson Title**: **Basic Types and Type Annotations in TypeScript**

**Lesson Description**:  
Delve into the foundational aspects of TypeScript by exploring basic types and type annotations. This lesson focuses on the primitive data types—number, string, and boolean—as well as complex types like arrays and tuples. Learn how to use type annotations to enforce type safety and understand how TypeScript's type inference works to streamline code writing. By mastering these basic types and annotations, you will enhance your ability to write robust and error-free TypeScript code. This comprehensive lesson will deepen your understanding of TypeScript's type system and prepare you for technical interviews by covering these essential topics.

---

# **Basic Types and Type Annotations in TypeScript**

TypeScript builds upon JavaScript by adding a robust type system, enabling developers to write safer and more maintainable code. Understanding basic types and how to use type annotations is fundamental to leveraging TypeScript's capabilities. This lesson covers the core primitive types, arrays, tuples, and the concept of type inference, providing a solid foundation for your TypeScript journey.

---

## **Table of Contents**

1. **Introduction to TypeScript Types**
   - The Importance of Types
   - Static Typing vs. Dynamic Typing
2. **Primitive Types**
   - Number
   - String
   - Boolean
   - Null and Undefined
3. **Type Annotations**
   - Declaring Variables with Type Annotations
   - Function Parameters and Return Types
4. **Arrays**
   - Typed Arrays
   - Generic Array Types
5. **Tuples**
   - Defining Tuples
   - Accessing Tuple Elements
6. **Type Inference**
   - How Type Inference Works
   - Best Practices with Type Inference
7. **Any, Unknown, and Void Types**
   - The `any` Type
   - The `unknown` Type
   - The `void` Type
8. **Type Assertions**
   - Casting Types
   - When to Use Type Assertions
9. **Best Practices**
10. **Common Interview Questions**
11. **Exercises**
12. **Conclusion**
13. **Next Steps**
14. **Appendix**

---

## **Introduction to TypeScript Types**

### **The Importance of Types**

- **Type Safety**: Types help catch errors at compile time, reducing runtime exceptions.
- **Code Clarity**: Explicit types make code more readable and maintainable.
- **Tooling Support**: Types enhance IDE features like autocompletion and refactoring tools.

### **Static Typing vs. Dynamic Typing**

- **Static Typing**: Type checking is performed at compile time (e.g., TypeScript, Java).
- **Dynamic Typing**: Type checking is performed at runtime (e.g., JavaScript, Python).

---

## **Primitive Types**

TypeScript supports the same primitive types as JavaScript, along with type annotations.

### **Number**

- **Definition**: Represents both integer and floating-point numbers.
- **Example**:

  ```typescript
  let age: number = 25
  let price: number = 19.99
  let hex: number = 0xfff // Hexadecimal
  let binary: number = 0b1010 // Binary
  let octal: number = 0o744 // Octal
  ```

### **String**

- **Definition**: Represents text data, enclosed in single or double quotes, or backticks for template literals.
- **Example**:

  ```typescript
  let firstName: string = 'Alice'
  let lastName: string = 'Johnson'
  let greeting: string = `Hello, ${firstName} ${lastName}!`
  ```

### **Boolean**

- **Definition**: Represents logical values `true` and `false`.
- **Example**:

  ```typescript
  let isDone: boolean = false
  let hasPermission: boolean = true
  ```

### **Null and Undefined**

- **`null`**: Represents the intentional absence of any object value.
- **`undefined`**: Denotes a variable that has not been assigned a value.
- **Example**:

  ```typescript
  let empty: null = null
  let notAssigned: undefined = undefined
  ```

- **Note**: By default, `null` and `undefined` are subtypes of all other types. However, when using the `--strictNullChecks` compiler option, variables of type `null` or `undefined` are not assignable to other types unless explicitly specified.

---

## **Type Annotations**

Type annotations explicitly specify the type of a variable or function.

### **Declaring Variables with Type Annotations**

- **Syntax**:

  ```typescript
  let variableName: type = value
  ```

- **Example**:

  ```typescript
  let count: number = 10
  let username: string = 'Alice'
  let isActive: boolean = true
  ```

### **Function Parameters and Return Types**

- **Syntax**:

  ```typescript
  function functionName(parameter: type): returnType {
    // Function body
  }
  ```

- **Example**:

  ```typescript
  function add(a: number, b: number): number {
    return a + b
  }

  function greet(name: string): void {
    console.log(`Hello, ${name}!`)
  }
  ```

---

## **Arrays**

Arrays can be typed to specify the type of elements they contain.

### **Typed Arrays**

- **Syntax**:

  ```typescript
  let arrayName: type[] = [elements]
  ```

- **Example**:

  ```typescript
  let numbers: number[] = [1, 2, 3, 4, 5]
  let strings: string[] = ['apple', 'banana', 'cherry']
  ```

- **Multidimensional Arrays**:

  ```typescript
  let matrix: number[][] = [
    [1, 2],
    [3, 4],
  ]
  ```

### **Generic Array Types**

- **Syntax**:

  ```typescript
  let arrayName: Array<type> = [elements]
  ```

- **Example**:

  ```typescript
  let fruits: Array<string> = ['apple', 'banana', 'cherry']
  let scores: Array<number> = [85, 92, 78]
  ```

---

## **Tuples**

Tuples represent arrays with fixed sizes and known types at each index.

### **Defining Tuples**

- **Syntax**:

  ```typescript
  let tupleName: [type1, type2, ..., typeN] = [value1, value2, ..., valueN];
  ```

- **Example**:

  ```typescript
  let person: [string, number] = ['Alice', 25]
  let coordinates: [number, number, number] = [10, 20, 30]
  ```

### **Accessing Tuple Elements**

- **Example**:

  ```typescript
  let user: [number, string] = [1, 'Alice']
  let id: number = user[0] // 1
  let name: string = user[1] // 'Alice'
  ```

- **Adding Elements**:

  - Tuples can have optional elements or use the rest syntax for flexibility.

  ```typescript
  let employee: [number, string, ...string[]] = [
    1,
    'Alice',
    'Developer',
    'Engineer',
  ]
  ```

---

## **Type Inference**

TypeScript can automatically infer types based on assigned values.

### **How Type Inference Works**

- **Variable Initialization**:

  ```typescript
  let message = 'Hello, TypeScript!' // Inferred as string
  ```

- **Function Return Types**:

  ```typescript
  function multiply(a: number, b: number) {
    return a * b // Return type inferred as number
  }
  ```

- **Contextual Typing**:

  - TypeScript can infer types based on the context in which a variable or function is used.

  ```typescript
  window.onmousedown = function (event) {
    console.log(event.button) // `event` inferred as MouseEvent
  }
  ```

### **Best Practices with Type Inference**

- **Explicit vs. Inferred Types**:

  - Use explicit types when it improves code clarity or when inference is insufficient.
  - Let TypeScript infer types when the type is obvious or does not add clarity.

- **Examples**:

  ```typescript
  // Type inference is sufficient
  let count = 10 // Inferred as number

  // Explicit type annotation improves clarity
  let total: number = 0

  // Function parameters should have explicit types
  function divide(a: number, b: number): number {
    return a / b
  }
  ```

---

## **Any, Unknown, and Void Types**

### **The `any` Type**

- **Definition**: Represents any type, opting out of type checking.
- **Usage**:

  ```typescript
  let variable: any = 5
  variable = 'Hello'
  variable = true
  ```

- **Caution**: Overusing `any` defeats the purpose of TypeScript's type safety.

### **The `unknown` Type**

- **Definition**: Similar to `any`, but requires type checking before usage.
- **Usage**:

  ```typescript
  let input: unknown = 'Hello'

  if (typeof input === 'string') {
    console.log(input.toUpperCase())
  }
  ```

- **Benefit**: Encourages type safety by forcing type checks.

### **The `void` Type**

- **Definition**: Represents the absence of a type, commonly used as the return type for functions that do not return a value.
- **Usage**:

  ```typescript
  function logMessage(message: string): void {
    console.log(message)
  }
  ```

---

## **Type Assertions**

Type assertions allow you to override TypeScript's inferred type when you have more information about the type of a value.

### **Casting Types**

- **Syntax**:

  ```typescript
  let variable = value as type
  // or
  let variable = <type>value
  ```

- **Example**:

  ```typescript
  let someValue: unknown = 'Hello, TypeScript!'
  let strLength: number = (someValue as string).length
  ```

### **When to Use Type Assertions**

- **DOM Manipulation**:

  ```typescript
  let inputElement = document.getElementById('username') as HTMLInputElement
  inputElement.value = 'Alice'
  ```

- **Avoiding Excessive Use**:

  - Use type assertions sparingly.
  - Prefer refining types through type guards or proper type declarations.

---

## **Best Practices**

- **Explicit Types for Function Parameters and Return Types**:

  - Always annotate function parameters and return types for clarity.

- **Minimize Use of `any`**:

  - Avoid using `any` unless necessary.
  - Consider using `unknown` or proper types.

- **Leverage Type Inference**:

  - Let TypeScript infer types when it enhances code readability.

- **Consistent Coding Style**:

  - Follow a style guide.
  - Use linters like TSLint or ESLint with TypeScript support.

- **Use Readonly and Const**:

  - Use `readonly` for properties that should not change.
  - Use `const` for variables that are not reassigned.

---

## **Common Interview Questions**

1. **What are the basic primitive types in TypeScript?**

   **Answer**:

   - **Number**: Represents numeric values (both integer and floating-point).
   - **String**: Represents text data.
   - **Boolean**: Represents logical values `true` and `false`.
   - **Null**: Represents the absence of any object value.
   - **Undefined**: Denotes a variable that has not been assigned a value.

2. **Explain the difference between `any` and `unknown` types in TypeScript.**

   **Answer**:

   - **`any`**:

     - Opts out of type checking.
     - Allows any operation on the variable without type errors.
     - Should be used sparingly as it can lead to runtime errors.

   - **`unknown`**:

     - Similar to `any`, but safer.
     - Requires type checking before performing operations.
     - Encourages type safety by enforcing type checks.

3. **What is type inference in TypeScript, and how does it work?**

   **Answer**:

   - Type inference is the ability of TypeScript to automatically determine the type of a variable or expression based on its value or context.
   - It works by analyzing the assigned value and the context in which a variable or function is used.
   - Type inference reduces the need for explicit type annotations when the type is obvious.

4. **How do you define a tuple in TypeScript, and when would you use it?**

   **Answer**:

   - **Defining a Tuple**:

     ```typescript
     let tupleName: [type1, type2, ..., typeN] = [value1, value2, ..., valueN];
     ```

   - **Example**:

     ```typescript
     let person: [string, number] = ['Alice', 25]
     ```

   - **Usage**:

     - Tuples are used when you need to represent an array with a fixed number of elements of specific types.
     - They are useful for representing structured data where the position and type of each element are known.

5. **Why should you avoid overusing the `any` type in TypeScript?**

   **Answer**:

   - Overusing `any` defeats the purpose of TypeScript's type safety.
   - It disables type checking, allowing for potential runtime errors.
   - It makes code less readable and maintainable.
   - Prefer using specific types or `unknown` to maintain type safety.

---

## **Exercises**

### **Exercise 1: Type Annotations**

**Question**:

Declare variables with appropriate type annotations for the following:

1. A variable `studentName` storing the name "John Doe".
2. A variable `studentAge` storing the age 21.
3. A variable `isEnrolled` indicating whether the student is enrolled (true).

**Answer**:

```typescript
let studentName: string = 'John Doe'
let studentAge: number = 21
let isEnrolled: boolean = true
```

---

### **Exercise 2: Typed Arrays**

**Question**:

Create a typed array `colors` that can only contain strings. Add the colors "red", "green", and "blue" to the array.

**Answer**:

```typescript
let colors: string[] = ['red', 'green', 'blue']
```

---

### **Exercise 3: Tuples**

**Question**:

Define a tuple `userInfo` that contains a user's ID (number) and username (string). Initialize it with ID 1 and username "alice".

**Answer**:

```typescript
let userInfo: [number, string] = [1, 'alice']
```

---

### **Exercise 4: Type Inference**

**Question**:

Let TypeScript infer the types for the following variables and functions. Explain what types TypeScript infers.

1. Variable `count` initialized to 100.
2. Function `greet` that takes a parameter `name` and returns a greeting message.

**Answer**:

```typescript
let count = 100 // Inferred as number

function greet(name: string) {
  return `Hello, ${name}!` // Return type inferred as string
}
```

- **Type Inferences**:

  - `count`: TypeScript infers `count` as `number`.
  - `greet`: The parameter `name` should be explicitly typed as `string`. The return type is inferred as `string`.

---

### **Exercise 5: Type Assertions**

**Question**:

You have a DOM element retrieved using `document.getElementById('email')`. TypeScript doesn't know that this element is an `HTMLInputElement`. Use a type assertion to specify the correct type and assign a value to the input's `value` property.

**Answer**:

```typescript
let emailInput = document.getElementById('email') as HTMLInputElement
emailInput.value = 'user@example.com'
```

---

## **Conclusion**

Understanding basic types and type annotations is essential for writing robust TypeScript code. By leveraging primitive types, arrays, tuples, and type inference, you can enhance code safety and readability. Type annotations enable you to specify exactly what types of data your variables and functions can accept and return, catching errors early in the development process. Mastery of these fundamental concepts lays the groundwork for exploring more advanced TypeScript features and contributes to your growth as a proficient developer.

---

## **Next Steps**

- **Practice**:

  - Write TypeScript code using various types and annotations.
  - Refactor existing JavaScript code by adding type annotations.

- **Explore**:

  - Learn about advanced types like union, intersection, and literal types.
  - Study function types and how to type higher-order functions.

- **Prepare**:

  - Review additional interview questions on TypeScript types.
  - Build small projects to reinforce your understanding of type annotations.

---

**Continue enhancing your TypeScript expertise by mastering basic types and type annotations!**

---

## **Appendix**

### **Glossary**

- **Type Annotation**: Explicitly specifying the type of a variable or function parameter.
- **Type Inference**: The compiler's ability to automatically determine the type of a variable based on its value.
- **Primitive Types**: Basic data types like number, string, and boolean.
- **Array Type**: A type that represents a collection of elements of a specific type.
- **Tuple**: An array with a fixed number of elements of specified types.
- **Type Assertion**: A way to override TypeScript's inferred type when the developer has more information.
- **`any` Type**: A type that disables type checking, allowing any value.
- **`unknown` Type**: Similar to `any`, but requires type checking before usage.
- **`void` Type**: Represents the absence of a type, typically used for functions that do not return a value.

---

**End of Lesson**
