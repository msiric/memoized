**Lesson Title**: **Mastering the TypeScript Compiler API**

**Lesson Description**:  
Elevate your TypeScript expertise by delving into the TypeScript Compiler API. This lesson focuses on programmatic Abstract Syntax Tree (AST) manipulation and creating custom transformers. By understanding how to interact with the TypeScript compiler programmatically, you will gain the ability to analyze, transform, and generate TypeScript code dynamically. This comprehensive lesson will deepen your understanding of TypeScript's internals and prepare you for advanced development tasks and technical interviews by covering these essential topics.

---

# **Mastering the TypeScript Compiler API**

The TypeScript Compiler API provides powerful tools for programmatically analyzing and transforming TypeScript code. By leveraging the Compiler API, developers can create custom tools, linters, code generators, and more. This lesson explores how to interact with the TypeScript compiler programmatically, manipulate the AST, and implement custom transformers to modify code during the compilation process.

---

## **Table of Contents**

1. **Introduction to the TypeScript Compiler API**
   - What is the TypeScript Compiler API?
   - Importance and Use Cases
2. **Setting Up the Environment**
   - Installing TypeScript Compiler Package
   - Basic Project Structure
3. **Understanding the Abstract Syntax Tree (AST)**
   - What is an AST?
   - Exploring the TypeScript AST Structure
4. **Programmatic AST Manipulation**
   - Parsing TypeScript Code into AST
   - Traversing the AST
   - Modifying the AST
5. **Creating Custom Transformers**
   - What are Custom Transformers?
   - Transformer Factory Functions
   - Implementing Custom Transformers
6. **Applying Transformers during Compilation**
   - Using Transformers with `tsc`
   - Integrating Transformers in Build Tools (e.g., Webpack)
7. **Practical Examples**
   - Example 1: Logging Function Calls
   - Example 2: Automatic Property Binding
8. **Best Practices**
9. **Common Interview Questions**
10. **Exercises**
11. **Conclusion**
12. **Next Steps**
13. **Appendix**

---

## **Introduction to the TypeScript Compiler API**

### **What is the TypeScript Compiler API?**

- **Definition**: The TypeScript Compiler API allows developers to interact with the TypeScript compiler programmatically. It provides access to the compiler's internal processes, enabling code analysis, transformation, and generation.
- **Capabilities**:
  - Parse TypeScript code into an Abstract Syntax Tree (AST).
  - Traverse and inspect the AST nodes.
  - Modify the AST to transform code.
  - Emit transformed code back to TypeScript or JavaScript.

### **Importance and Use Cases**

- **Code Analysis**: Create tools that analyze TypeScript code for errors, code smells, or patterns.
- **Custom Linters and Formatters**: Develop custom linting rules or code formatting tools.
- **Code Transformation**: Implement code transformations for optimization, instrumentation, or feature enhancements.
- **Code Generation**: Generate code based on templates or patterns.
- **Educational Tools**: Build tools that visualize code structure or behavior for learning purposes.

---

## **Setting Up the Environment**

### **Installing TypeScript Compiler Package**

- **TypeScript as a Dependency**: Install the `typescript` package in your project to access the Compiler API.

  ```bash
  npm install typescript --save-dev
  ```

### **Basic Project Structure**

- **Directory Structure**:

  ```
  project-root/
  ├── src/
  │   └── index.ts
  ├── tsconfig.json
  └── package.json
  ```

- **`tsconfig.json`**: Configure TypeScript compiler options.

  ```json
  {
    "compilerOptions": {
      "target": "ES2015",
      "module": "CommonJS",
      "outDir": "dist",
      "strict": true
    },
    "include": ["src/**/*"]
  }
  ```

- **`index.ts`**: Entry point for your compiler tool or transformer.

---

## **Understanding the Abstract Syntax Tree (AST)**

### **What is an AST?**

- **Definition**: An Abstract Syntax Tree is a tree representation of the abstract syntactic structure of source code. Each node in the tree denotes a construct occurring in the source code.
- **Purpose**:
  - Provides a structured, programmatic representation of code.
  - Enables analysis and transformation of code at a granular level.

### **Exploring the TypeScript AST Structure**

- **AST Nodes**: Represent different syntactic elements like statements, expressions, declarations, etc.
- **TypeScript AST API**: Exposes interfaces and classes for various node types, such as `ts.Node`, `ts.Statement`, `ts.Expression`, etc.
- **Example**:

  ```typescript
  const code = `const x = 42;`;

  const sourceFile = ts.createSourceFile(
    'test.ts',
    code,
    ts.ScriptTarget.ES2015,
    true,
    ts.ScriptKind.TS
  );

  console.log(sourceFile.statements);
  ```

  - **Output**: The `statements` property contains an array of `Node` objects representing the top-level statements in the code.

---

## **Programmatic AST Manipulation**

### **Parsing TypeScript Code into AST**

- **`ts.createSourceFile`**: Parses code into an AST.

  ```typescript
  import * as ts from 'typescript';

  const code = `let message: string = 'Hello, World!';`;

  const sourceFile = ts.createSourceFile(
    'example.ts',
    code,
    ts.ScriptTarget.ES2015,
    true,
    ts.ScriptKind.TS
  );
  ```

### **Traversing the AST**

- **Visitor Pattern**: Traverse the AST by visiting each node recursively.

  ```typescript
  function visit(node: ts.Node) {
    console.log(`Visiting ${ts.SyntaxKind[node.kind]}`);
    ts.forEachChild(node, visit);
  }

  visit(sourceFile);
  ```

- **`ts.forEachChild`**: Iterates over the child nodes of a given node.

### **Modifying the AST**

- **Creating New Nodes**: Use factory functions from `ts.factory` to create new nodes.

  ```typescript
  const newVariable = ts.factory.createVariableStatement(
    undefined,
    ts.factory.createVariableDeclarationList(
      [
        ts.factory.createVariableDeclaration(
          'newVar',
          undefined,
          ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword),
          ts.factory.createNumericLiteral(100)
        ),
      ],
      ts.NodeFlags.Const
    )
  );
  ```

- **Replacing Nodes**: Return new nodes from visitor functions to replace existing ones.

  ```typescript
  function transformer<T extends ts.Node>(context: ts.TransformationContext) {
    return (rootNode: T) => {
      function visit(node: ts.Node): ts.Node {
        if (ts.isVariableDeclaration(node) && node.name.getText() === 'message') {
          return ts.factory.updateVariableDeclaration(
            node,
            node.name,
            node.exclamationToken,
            ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword),
            ts.factory.createStringLiteral('Transformed Message')
          );
        }
        return ts.visitEachChild(node, visit, context);
      }
      return ts.visitNode(rootNode, visit);
    };
  }
  ```

- **Applying Transformations**:

  ```typescript
  const result = ts.transform(sourceFile, [transformer]);
  const transformedSourceFile = result.transformed[0];
  ```

---

## **Creating Custom Transformers**

### **What are Custom Transformers?**

- **Definition**: Custom transformers are functions that receive and return AST nodes, allowing you to modify the code during the compilation process.
- **Purpose**:
  - Modify code before it's emitted.
  - Implement code transformations like code instrumentation, macro expansion, or custom syntax handling.

### **Transformer Factory Functions**

- **Transformer Factory**: A function that creates a transformer function.

  ```typescript
  type TransformerFactory<T extends ts.Node> = (context: ts.TransformationContext) => ts.Transformer<T>;
  ```

- **Transformation Context**: Provides methods to assist in node transformations.

### **Implementing Custom Transformers**

- **Example**: Create a transformer that renames all instances of a variable `oldName` to `newName`.

  ```typescript
  function renameVariable(oldName: string, newName: string): ts.TransformerFactory<ts.SourceFile> {
    return (context: ts.TransformationContext) => {
      return (sourceFile: ts.SourceFile) => {
        function visit(node: ts.Node): ts.Node {
          if (ts.isIdentifier(node) && node.text === oldName) {
            return ts.factory.createIdentifier(newName);
          }
          return ts.visitEachChild(node, visit, context);
        }
        return ts.visitNode(sourceFile, visit);
      };
    };
  }
  ```

---

## **Applying Transformers during Compilation**

### **Using Transformers with `tsc`**

- **Custom Transformers with `tsc`**: The TypeScript compiler (`tsc`) does not support custom transformers directly.
- **Workaround**: Use the Compiler API to create a custom compilation script.

  ```typescript
  import * as ts from 'typescript';

  const program = ts.createProgram(['src/index.ts'], { /* compiler options */ });

  const transformers = {
    before: [renameVariable('oldName', 'newName')],
    after: [],
  };

  const { emitSkipped, diagnostics } = program.emit(undefined, undefined, undefined, false, transformers);

  if (emitSkipped) {
    console.error('Emitting failed');
    console.error(diagnostics.map(diagnostic => diagnostic.messageText));
  }
  ```

### **Integrating Transformers in Build Tools**

- **Webpack**: Use `ts-loader` with custom transformers.

  ```javascript
  // webpack.config.js
  const ts = require('typescript');
  const path = require('path');

  const renameVariableTransformer = require('./transformers/renameVariable').default;

  module.exports = {
    // ... other config options
    module: {
      rules: [
        {
          test: /\.tsx?$/,
          loader: 'ts-loader',
          options: {
            getCustomTransformers: (program) => ({
              before: [renameVariableTransformer('oldName', 'newName')],
            }),
          },
          exclude: /node_modules/,
        },
      ],
    },
  };
  ```

- **Gulp**: Use `gulp-typescript` with custom transformers.

  ```javascript
  const gulp = require('gulp');
  const ts = require('gulp-typescript');
  const renameVariableTransformer = require('./transformers/renameVariable').default;

  const tsProject = ts.createProject('tsconfig.json', {
    getCustomTransformers: () => ({
      before: [renameVariableTransformer('oldName', 'newName')],
    }),
  });

  gulp.task('default', () => {
    return tsProject.src().pipe(tsProject()).js.pipe(gulp.dest('dist'));
  });
  ```

---

## **Practical Examples**

### **Example 1: Logging Function Calls**

- **Goal**: Automatically insert logging statements at the beginning of each function call.

- **Implementation**:

  ```typescript
  function logFunctionCalls(): ts.TransformerFactory<ts.SourceFile> {
    return (context) => {
      const visitor: ts.Visitor = (node) => {
        if (ts.isFunctionDeclaration(node) || ts.isMethodDeclaration(node)) {
          const functionName = node.name ? node.name.getText() : 'anonymous';
          const logStatement = ts.factory.createExpressionStatement(
            ts.factory.createCallExpression(
              ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier('console'), 'log'),
              undefined,
              [ts.factory.createStringLiteral(`Entering function ${functionName}`)]
            )
          );

          let newBody = node.body;

          if (newBody && ts.isBlock(newBody)) {
            newBody = ts.factory.updateBlock(newBody, [logStatement, ...newBody.statements]);
          }

          if (ts.isFunctionDeclaration(node)) {
            return ts.factory.updateFunctionDeclaration(
              node,
              node.decorators,
              node.modifiers,
              node.asteriskToken,
              node.name,
              node.typeParameters,
              node.parameters,
              node.type,
              newBody
            );
          } else if (ts.isMethodDeclaration(node)) {
            return ts.factory.updateMethodDeclaration(
              node,
              node.decorators,
              node.modifiers,
              node.asteriskToken,
              node.name,
              node.questionToken,
              node.typeParameters,
              node.parameters,
              node.type,
              newBody
            );
          }
        }
        return ts.visitEachChild(node, visitor, context);
      };

      return (node) => ts.visitNode(node, visitor);
    };
  }
  ```

- **Usage**:

  Apply the transformer during compilation as shown in the previous section.

### **Example 2: Automatic Property Binding**

- **Goal**: Automatically bind class methods to the instance, eliminating the need to manually bind `this` in constructors.

- **Implementation**:

  ```typescript
  function autoBindMethods(): ts.TransformerFactory<ts.SourceFile> {
    return (context) => {
      const visitor: ts.Visitor = (node) => {
        if (ts.isClassDeclaration(node)) {
          const constructor = node.members.find(ts.isConstructorDeclaration);

          const boundMethods = node.members
            .filter(
              (member) =>
                ts.isMethodDeclaration(member) &&
                member.modifiers &&
                member.modifiers.some((mod) => mod.kind === ts.SyntaxKind.PrivateKeyword) === false
            )
            .map((method) => {
              const methodName = method.name.getText();
              return ts.factory.createExpressionStatement(
                ts.factory.createBinaryExpression(
                  ts.factory.createPropertyAccessExpression(ts.factory.createThis(), method.name as ts.Identifier),
                  ts.SyntaxKind.EqualsToken,
                  ts.factory.createCallExpression(
                    ts.factory.createPropertyAccessExpression(
                      ts.factory.createPropertyAccessExpression(ts.factory.createThis(), method.name as ts.Identifier),
                      'bind'
                    ),
                    undefined,
                    [ts.factory.createThis()]
                  )
                )
              );
            });

          let newConstructor = constructor;

          if (constructor) {
            const statements = [...constructor.body.statements, ...boundMethods];
            newConstructor = ts.factory.updateConstructorDeclaration(
              constructor,
              constructor.decorators,
              constructor.modifiers,
              constructor.parameters,
              ts.factory.updateBlock(constructor.body, statements)
            );
          } else {
            newConstructor = ts.factory.createConstructorDeclaration(
              undefined,
              undefined,
              [],
              ts.factory.createBlock(boundMethods, true)
            );
          }

          const newMembers = ts.factory.createNodeArray(
            [newConstructor, ...node.members.filter((member) => !ts.isConstructorDeclaration(member))]
          );

          return ts.factory.updateClassDeclaration(
            node,
            node.decorators,
            node.modifiers,
            node.name,
            node.typeParameters,
            node.heritageClauses,
            newMembers
          );
        }
        return ts.visitEachChild(node, visitor, context);
      };

      return (node) => ts.visitNode(node, visitor);
    };
  }
  ```

- **Usage**:

  Apply the transformer during compilation.

---

## **Best Practices**

- **Understand the AST Structure**: Familiarize yourself with the TypeScript AST node types and their relationships.
- **Use Type Guards**: Utilize TypeScript's type guards like `ts.isFunctionDeclaration(node)` to safely work with specific node types.
- **Avoid Side Effects**: Transformers should be pure functions without side effects to prevent unexpected behaviors.
- **Test Thoroughly**: Ensure your transformers work correctly by testing them with various code samples.
- **Performance Considerations**: Be mindful of the performance impact of your transformers, especially when working with large codebases.
- **Stay Updated**: Keep up with TypeScript's updates, as the Compiler API may change between versions.

---

## **Common Interview Questions**

1. **What is the TypeScript Compiler API, and why is it useful?**

   **Answer**:

   - The TypeScript Compiler API allows developers to interact with the TypeScript compiler programmatically.
   - It provides access to the compiler's internal processes, enabling code analysis, AST manipulation, code transformation, and code generation.
   - Useful for creating custom tools like linters, code formatters, code generators, and implementing custom compile-time transformations.

2. **Explain how you can traverse and modify the AST in TypeScript.**

   **Answer**:

   - Traversal is typically done using the visitor pattern, recursively visiting each node using functions like `ts.forEachChild` or `ts.visitEachChild`.
   - Modification involves creating new nodes or updating existing ones using factory functions provided by `ts.factory`.
   - By returning new nodes from visitor functions, you can replace nodes in the AST, effectively modifying the code.

3. **What are custom transformers in TypeScript, and how do they work?**

   **Answer**:

   - Custom transformers are functions that receive and return AST nodes, allowing you to modify code during the compilation process.
   - They are implemented as transformer factory functions that take a `TransformationContext` and return a transformer function.
   - They are applied during the compilation process, modifying the AST before the code is emitted.

4. **Can you use custom transformers with the TypeScript compiler (`tsc`) directly? If not, how can you apply them?**

   **Answer**:

   - The TypeScript compiler (`tsc`) does not support custom transformers directly via command-line options.
   - To apply custom transformers, you can use the Compiler API to create a custom compilation script that invokes the compiler programmatically with the transformers.
   - Alternatively, integrate the transformers into build tools like Webpack (using `ts-loader`) or Gulp.

5. **Describe a scenario where you would use the TypeScript Compiler API to create a custom tool.**

   **Answer**:

   - **Scenario**: Creating a custom linter that enforces specific coding standards or detects code patterns not covered by existing linters.
   - By parsing the code into an AST and traversing it, you can analyze code structures, detect undesirable patterns, and report them.
   - Another scenario is generating code documentation by extracting comments and code structures from the AST.

---

## **Exercises**

### **Exercise 1: AST Traversal**

**Question**:

Write a script that parses a TypeScript file and logs all function names defined in the file.

**Answer**:

```typescript
import * as ts from 'typescript';
import * as fs from 'fs';

const fileName = 'example.ts';
const code = fs.readFileSync(fileName, 'utf8');

const sourceFile = ts.createSourceFile(fileName, code, ts.ScriptTarget.ES2015, true);

function logFunctionNames(node: ts.Node) {
  if (ts.isFunctionDeclaration(node) && node.name) {
    console.log(`Function: ${node.name.getText()}`);
  }
  ts.forEachChild(node, logFunctionNames);
}

logFunctionNames(sourceFile);
```

---

### **Exercise 2: Simple Transformer**

**Question**:

Create a custom transformer that converts all instances of `var` declarations to `let` in the code.

**Answer**:

```typescript
function varToLetTransformer(): ts.TransformerFactory<ts.SourceFile> {
  return (context) => {
    const visitor: ts.Visitor = (node) => {
      if (ts.isVariableDeclarationList(node) && (node.flags & ts.NodeFlags.Var)) {
        return ts.factory.updateVariableDeclarationList(node, node.declarations);
      }
      return ts.visitEachChild(node, visitor, context);
    };
    return (node) => ts.visitNode(node, visitor);
  };
}
```

---

### **Exercise 3: Identifying Deprecated Functions**

**Question**:

Write a script that traverses a TypeScript AST and identifies all calls to a function named `oldFunction`, logging the line numbers where it is used.

**Answer**:

```typescript
import * as ts from 'typescript';
import * as fs from 'fs';

const fileName = 'example.ts';
const code = fs.readFileSync(fileName, 'utf8');

const sourceFile = ts.createSourceFile(fileName, code, ts.ScriptTarget.ES2015, true);

function findDeprecatedFunctions(node: ts.Node) {
  if (ts.isCallExpression(node) && ts.isIdentifier(node.expression) && node.expression.text === 'oldFunction') {
    const { line } = sourceFile.getLineAndCharacterOfPosition(node.getStart());
    console.log(`Deprecated function 'oldFunction' used at line ${line + 1}`);
  }
  ts.forEachChild(node, findDeprecatedFunctions);
}

findDeprecatedFunctions(sourceFile);
```

---

### **Exercise 4: Code Generation**

**Question**:

Using the TypeScript Compiler API, programmatically generate a TypeScript file that defines an interface `Person` with properties `name: string` and `age: number`.

**Answer**:

```typescript
import * as ts from 'typescript';
import * as fs from 'fs';

const interfaceDeclaration = ts.factory.createInterfaceDeclaration(
  undefined,
  [ts.factory.createModifier(ts.SyntaxKind.ExportKeyword)],
  'Person',
  undefined,
  undefined,
  [
    ts.factory.createPropertySignature(
      undefined,
      'name',
      undefined,
      ts.factory.createKeywordTypeNode(ts.SyntaxKind.StringKeyword)
    ),
    ts.factory.createPropertySignature(
      undefined,
      'age',
      undefined,
      ts.factory.createKeywordTypeNode(ts.SyntaxKind.NumberKeyword)
    ),
  ]
);

const sourceFile = ts.factory.createSourceFile(
  [interfaceDeclaration],
  ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
  ts.NodeFlags.None
);

const printer = ts.createPrinter({ newLine: ts.NewLineKind.LineFeed });

const result = printer.printNode(ts.EmitHint.Unspecified, sourceFile, sourceFile);

fs.writeFileSync('person.ts', result);
```

---

### **Exercise 5: AST Modification**

**Question**:

Write a transformer that adds a console log at the beginning of every method in a class, logging the method name and arguments.

**Answer**:

```typescript
function logMethodCalls(): ts.TransformerFactory<ts.SourceFile> {
  return (context) => {
    const visitor: ts.Visitor = (node) => {
      if (ts.isMethodDeclaration(node)) {
        const methodName = node.name.getText();
        const logStatement = ts.factory.createExpressionStatement(
          ts.factory.createCallExpression(
            ts.factory.createPropertyAccessExpression(ts.factory.createIdentifier('console'), 'log'),
            undefined,
            [
              ts.factory.createStringLiteral(`Method ${methodName} called with arguments:`),
              ts.factory.createSpreadElement(ts.factory.createIdentifier('arguments')),
            ]
          )
        );

        const newBody = ts.factory.updateBlock(node.body!, [logStatement, ...node.body!.statements]);

        return ts.factory.updateMethodDeclaration(
          node,
          node.decorators,
          node.modifiers,
          node.asteriskToken,
          node.name,
          node.questionToken,
          node.typeParameters,
          node.parameters,
          node.type,
          newBody
        );
      }
      return ts.visitEachChild(node, visitor, context);
    };
    return (node) => ts.visitNode(node, visitor);
  };
}
```

---

## **Conclusion**

The TypeScript Compiler API empowers developers to analyze, manipulate, and generate TypeScript code programmatically. By mastering programmatic AST manipulation and custom transformers, you can create powerful tools and enhance the capabilities of your TypeScript projects. Understanding the Compiler API opens up opportunities for custom linting, code transformations, and more, preparing you for advanced development challenges and technical interviews.

---

## **Next Steps**

- **Practice**:
  - Experiment with creating custom transformers for your projects.
  - Build tools that analyze or modify TypeScript code using the Compiler API.

- **Explore**:
  - Dive deeper into advanced AST manipulations and learn about symbol tables and type checking.
  - Study how popular tools like TSLint and ESLint utilize the Compiler API.

- **Prepare**:
  - Review additional interview questions on TypeScript's Compiler API and code transformation.
  - Build projects that leverage the Compiler API to reinforce your understanding.

---

**Continue enhancing your TypeScript expertise by mastering the Compiler API!**

---

## **Appendix**

### **Glossary**

- **TypeScript Compiler API**: An API that allows developers to interact with the TypeScript compiler programmatically.
- **Abstract Syntax Tree (AST)**: A tree representation of the abstract syntactic structure of source code.
- **Node**: A basic unit in the AST representing a syntactic element.
- **Visitor Pattern**: A design pattern used to traverse and operate on elements of an object structure, such as an AST.
- **Transformer**: A function that receives and returns AST nodes, allowing code modification during compilation.
- **Transformation Context**: Provides methods and information to assist in node transformations.
- **Factory Functions**: Functions provided by `ts.factory` to create or update AST nodes.
- **Custom Transformer**: A user-defined transformer applied during the TypeScript compilation process.
- **Symbol Table**: A data structure used by the compiler to store information about identifiers (variables, functions, classes, etc.).
- **Emit**: The process of generating output code (e.g., JavaScript) from the AST.

---

**End of Lesson**