**Lesson Title**: **Generics and Constraints in TypeScript**

**Lesson Description**:  
Enhance your TypeScript expertise by mastering generics and constraints. This lesson focuses on generic functions and classes, allowing you to create reusable components that work with a variety of types. Additionally, learn how to use constraints with `extends` to restrict generic types, enabling you to enforce type requirements and improve type safety. By understanding generics and constraints, you will be able to write more flexible, maintainable, and type-safe code. This comprehensive lesson will deepen your understanding of TypeScript's advanced type system and prepare you for technical interviews by covering these essential topics.

---

# **Generics and Constraints in TypeScript**

Generics are a powerful feature in TypeScript that allow developers to create reusable components that can work with a variety of types while maintaining type safety. Constraints enable you to restrict the kinds of types that can be used with generics, ensuring that your code behaves as expected. This lesson delves into how to use generics in functions and classes, and how to apply constraints using the `extends` keyword.

---

## **Table of Contents**

1. **Introduction to Generics**
   - What are Generics?
   - Benefits of Using Generics
2. **Generic Functions**
   - Defining Generic Functions
   - Type Inference with Generics
   - Generic Constraints in Functions
3. **Generic Classes**
   - Defining Generic Classes
   - Using Generic Classes
   - Generic Constraints in Classes
4. **Using Constraints with `extends`**
   - Applying Type Constraints
   - Using Multiple Constraints
   - Bounded Generic Types
5. **Keyof Constraint**
   - Using `keyof` Operator
   - Index Types and Lookup Types
6. **Generic Interfaces**
   - Defining Generic Interfaces
   - Implementing Generic Interfaces
7. **Generic Constraints and Interfaces**
   - Extending Interfaces in Constraints
   - Constrained Generic Functions with Interfaces
8. **Best Practices**
9. **Common Interview Questions**
10. **Exercises**
11. **Conclusion**
12. **Next Steps**
13. **Appendix**

---

## **1. Introduction to Generics**

### **1.1 What are Generics?**

- **Definition**: Generics allow you to create components that can work with a variety of types rather than a single one.
- **Purpose**:
  - Increase code reusability.
  - Provide type safety while working with different types.
  - Allow for flexible and maintainable code.

### **1.2 Benefits of Using Generics**

- **Type Safety**: Ensures that the types used are consistent and valid.
- **Reusability**: Write code once and use it with multiple types.
- **Clarity**: Makes the intent of code clearer, indicating that a function or class is intended to work with multiple types.
- **Avoids `any` Type**: Provides a safer alternative to using `any`, which disables type checking.

---

## **2. Generic Functions**

### **2.1 Defining Generic Functions**

- **Syntax**:

  ```typescript
  function functionName<T>(parameter: T): T {
    // Function body
    return parameter
  }
  ```

- **Example**:

  ```typescript
  function identity<T>(arg: T): T {
    return arg
  }

  // Usage
  let output1 = identity<string>('Hello')
  let output2 = identity<number>(42)
  ```

### **2.2 Type Inference with Generics**

- **TypeScript Can Infer Generic Types**:

  ```typescript
  let output = identity('TypeScript') // Type inferred as string
  ```

- **Benefits**:
  - Reduces verbosity.
  - Improves code readability.

### **2.3 Generic Constraints in Functions**

- **Problem Without Constraints**:

  ```typescript
  function getLength<T>(arg: T): number {
    // Error: Property 'length' does not exist on type 'T'.
    return arg.length
  }
  ```

- **Solution Using Constraints**:

  ```typescript
  interface HasLength {
    length: number
  }

  function getLength<T extends HasLength>(arg: T): number {
    return arg.length
  }

  // Usage
  console.log(getLength('Hello')) // Outputs: 5
  console.log(getLength([1, 2, 3])) // Outputs: 3
  // console.log(getLength(123)); // Error: Type 'number' does not satisfy the constraint 'HasLength'.
  ```

---

## **3. Generic Classes**

### **3.1 Defining Generic Classes**

- **Syntax**:

  ```typescript
  class ClassName<T> {
    value: T
    constructor(value: T) {
      this.value = value
    }
    method(): T {
      return this.value
    }
  }
  ```

- **Example**:

  ```typescript
  class Box<T> {
    contents: T
    constructor(value: T) {
      this.contents = value
    }
    getContents(): T {
      return this.contents
    }
  }
  ```

### **3.2 Using Generic Classes**

- **Creating Instances**:

  ```typescript
  let stringBox = new Box<string>('Hello')
  console.log(stringBox.getContents()) // Outputs: Hello

  let numberBox = new Box<number>(100)
  console.log(numberBox.getContents()) // Outputs: 100
  ```

### **3.3 Generic Constraints in Classes**

- **Applying Constraints**:

  ```typescript
  interface Printable {
    print(): void
  }

  class Document<T extends Printable> {
    content: T
    constructor(content: T) {
      this.content = content
    }
    printContent(): void {
      this.content.print()
    }
  }
  ```

- **Usage**:

  ```typescript
  class Article implements Printable {
    title: string
    constructor(title: string) {
      this.title = title
    }
    print(): void {
      console.log(`Article: ${this.title}`)
    }
  }

  let article = new Article('Generics in TypeScript')
  let document = new Document<Article>(article)
  document.printContent() // Outputs: Article: Generics in TypeScript
  ```

---

## **4. Using Constraints with `extends`**

### **4.1 Applying Type Constraints**

- **Syntax**:

  ```typescript
  function functionName<T extends ConstraintType>(param: T): ReturnType {
    // Function body
  }
  ```

- **Example**:

  ```typescript
  function logProperty<T extends { name: string }>(obj: T): void {
    console.log(obj.name)
  }

  // Usage
  logProperty({ name: 'Alice', age: 30 }) // Outputs: Alice
  // logProperty({ age: 30 }); // Error: Property 'name' is missing
  ```

### **4.2 Using Multiple Constraints**

- **Extending Multiple Types with Intersection**:

  ```typescript
  function merge<T extends U, U>(target: T, source: U): T {
    for (let key in source) {
      target[key] = source[key] as any
    }
    return target
  }
  ```

- **Example with Multiple Constraints**:

  ```typescript
  interface Person {
    name: string
  }

  interface Employee {
    employeeId: number
  }

  function createEmployee<T extends Person & Employee>(person: T): void {
    console.log(`Employee: ${person.name}, ID: ${person.employeeId}`)
  }

  // Usage
  createEmployee({ name: 'Bob', employeeId: 123 })
  // createEmployee({ name: 'Bob' }); // Error: Property 'employeeId' is missing
  ```

### **4.3 Bounded Generic Types**

- **Limiting Types with Constraints**:

  ```typescript
  class Calculator<T extends number | string> {
    add(a: T, b: T): number {
      return Number(a) + Number(b)
    }
  }

  let calc = new Calculator<number>()
  console.log(calc.add(5, 10)) // Outputs: 15

  let calcString = new Calculator<string>()
  console.log(calcString.add('5', '10')) // Outputs: 15

  // let calcBoolean = new Calculator<boolean>(); // Error: Type 'boolean' does not satisfy the constraint 'number | string'
  ```

---

## **5. Keyof Constraint**

### **5.1 Using `keyof` Operator**

- **Definition**: The `keyof` operator takes an object type and produces a string or numeric literal union of its keys.

- **Example**:

  ```typescript
  interface Person {
    name: string
    age: number
    location: string
  }

  type PersonKeys = keyof Person // 'name' | 'age' | 'location'

  function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
    return obj[key]
  }

  let person: Person = { name: 'Alice', age: 30, location: 'Wonderland' }
  let name = getProperty(person, 'name') // Type is string
  // let invalid = getProperty(person, 'invalid'); // Error: Argument of type '"invalid"' is not assignable to parameter of type 'keyof Person'.
  ```

### **5.2 Index Types and Lookup Types**

- **Accessing Property Types**:

  ```typescript
  type NameType = Person['name'] // string
  ```

- **Using in Functions**:

  ```typescript
  function setProperty<T, K extends keyof T>(
    obj: T,
    key: K,
    value: T[K],
  ): void {
    obj[key] = value
  }

  setProperty(person, 'age', 31)
  // setProperty(person, 'age', 'thirty-one'); // Error: Type 'string' is not assignable to type 'number'
  ```

---

## **6. Generic Interfaces**

### **6.1 Defining Generic Interfaces**

- **Syntax**:

  ```typescript
  interface InterfaceName<T> {
    property: T
    method(param: T): T
  }
  ```

- **Example**:

  ```typescript
  interface KeyValuePair<K, V> {
    key: K
    value: V
  }

  let kvp: KeyValuePair<string, number> = { key: 'age', value: 30 }
  ```

### **6.2 Implementing Generic Interfaces**

- **Example**:

  ```typescript
  interface Comparable<T> {
    compareTo(other: T): number
  }

  class Rectangle implements Comparable<Rectangle> {
    width: number
    height: number
    constructor(width: number, height: number) {
      this.width = width
      this.height = height
    }
    compareTo(other: Rectangle): number {
      return this.area() - other.area()
    }
    area(): number {
      return this.width * this.height
    }
  }

  let rect1 = new Rectangle(10, 20)
  let rect2 = new Rectangle(15, 15)
  console.log(rect1.compareTo(rect2)) // Outputs: 50
  ```

---

## **7. Generic Constraints and Interfaces**

### **7.1 Extending Interfaces in Constraints**

- **Defining Constraints with Interfaces**:

  ```typescript
  interface Lengthwise {
    length: number
  }

  function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length)
    return arg
  }

  // Usage
  loggingIdentity({ length: 10, value: 3 }) // Outputs: 10
  // loggingIdentity(3); // Error: Type 'number' does not satisfy the constraint 'Lengthwise'
  ```

### **7.2 Constrained Generic Functions with Interfaces**

- **Example**:

  ```typescript
  interface CartItem {
    id: number
    name: string
    price: number
  }

  function getItemById<T extends { id: number }>(
    items: T[],
    id: number,
  ): T | undefined {
    return items.find((item) => item.id === id)
  }

  let cart: CartItem[] = [
    { id: 1, name: 'Laptop', price: 1200 },
    { id: 2, name: 'Phone', price: 800 },
  ]

  let item = getItemById(cart, 2)
  console.log(item) // Outputs: { id: 2, name: 'Phone', price: 800 }
  ```

---

## **8. Best Practices**

- **Use Generics When the Type is Variable**:

  - If a function or class works with multiple types, generics enhance flexibility.

- **Use Constraints to Enforce Type Requirements**:

  - Apply constraints to ensure that generic types have the necessary properties.

- **Prefer Specific Constraints Over `any`**:

  - Avoid using `any` as it disables type checking; use constraints to specify requirements.

- **Keep Generic Signatures Simple**:

  - Overly complex generic signatures can reduce readability.

- **Use Descriptive Type Parameter Names**:
  - Common conventions:
    - `T` for Type
    - `K` for Key
    - `V` for Value
    - `E` for Element

---

## **9. Common Interview Questions**

1. **What are generics in TypeScript, and why are they useful?**

   **Answer**:

   - Generics allow the creation of components that can work with a variety of types while providing type safety.
   - They enable writing reusable and flexible code.
   - Generics provide a way to parameterize types, making code more maintainable and reducing duplication.

2. **How do you apply constraints to a generic type in TypeScript?**

   **Answer**:

   - Constraints are applied using the `extends` keyword.
   - It restricts the types that can be used as generic parameters.

     ```typescript
     function functionName<T extends ConstraintType>(param: T): ReturnType {
       // Function body
     }
     ```

   - This ensures that the generic type has certain properties or methods.

3. **Explain the use of the `keyof` operator in TypeScript generics.**

   **Answer**:

   - The `keyof` operator takes an object type and produces a union of its keys.
   - It is used to constrain generic types to the keys of a given type.

     ```typescript
     function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
       return obj[key]
     }
     ```

   - This ensures that only valid property keys are used.

4. **Can you provide an example of a generic class with a constraint in TypeScript?**

   **Answer**:

   ```typescript
   interface Printable {
     print(): void
   }

   class Document<T extends Printable> {
     content: T
     constructor(content: T) {
       this.content = content
     }
     printContent(): void {
       this.content.print()
     }
   }
   ```

   - In this example, the generic class `Document` is constrained to types that implement the `Printable` interface.

5. **What are the benefits of using generics over the `any` type in TypeScript?**

   **Answer**:

   - Generics provide type safety by ensuring that the types used are consistent and valid.
   - They maintain type information, enabling better tooling support, such as autocompletion and type checking.
   - Using `any` disables type checking, which can lead to runtime errors.
   - Generics make code more maintainable and self-documenting.

---

## **10. Exercises**

### **Exercise 1: Generic Function**

**Question**:

Create a generic function `reverseArray` that takes an array of any type `T` and returns a new array with the elements in reverse order.

**Answer**:

```typescript
function reverseArray<T>(items: T[]): T[] {
  return items.slice().reverse()
}

// Usage
let numbers = [1, 2, 3, 4, 5]
let reversedNumbers = reverseArray(numbers)
console.log(reversedNumbers) // Outputs: [5, 4, 3, 2, 1]

let strings = ['a', 'b', 'c']
let reversedStrings = reverseArray(strings)
console.log(reversedStrings) // Outputs: ['c', 'b', 'a']
```

---

### **Exercise 2: Generic Class with Constraint**

**Question**:

Define an interface `Identifiable` with a property `id` of type `number`. Create a generic class `Repository<T>` constrained to `Identifiable` that manages a collection of items. Implement methods `add(item: T)` and `getById(id: number): T | undefined`.

**Answer**:

```typescript
interface Identifiable {
  id: number
}

class Repository<T extends Identifiable> {
  private items: T[] = []

  add(item: T): void {
    this.items.push(item)
  }

  getById(id: number): T | undefined {
    return this.items.find((item) => item.id === id)
  }
}

// Usage
interface User extends Identifiable {
  name: string
}

let userRepo = new Repository<User>()
userRepo.add({ id: 1, name: 'Alice' })
userRepo.add({ id: 2, name: 'Bob' })

let user = userRepo.getById(1)
console.log(user) // Outputs: { id: 1, name: 'Alice' }
```

---

### **Exercise 3: Generic Interface**

**Question**:

Create a generic interface `Pair<K, V>` representing a key-value pair. Implement a function `createPair` that takes a key of type `K` and a value of type `V` and returns a `Pair<K, V>`.

**Answer**:

```typescript
interface Pair<K, V> {
  key: K
  value: V
}

function createPair<K, V>(key: K, value: V): Pair<K, V> {
  return { key, value }
}

// Usage
let numberPair = createPair<number, string>(1, 'one')
console.log(numberPair) // Outputs: { key: 1, value: 'one' }

let stringPair = createPair<string, boolean>('isValid', true)
console.log(stringPair) // Outputs: { key: 'isValid', value: true }
```

---

### **Exercise 4: Using `keyof` Constraint**

**Question**:

Write a function `pluck` that takes an array of objects of type `T` and a property name `key` of type `K` (where `K` extends `keyof T`), and returns an array of property values of type `T[K]`.

**Answer**:

```typescript
function pluck<T, K extends keyof T>(items: T[], key: K): T[K][] {
  return items.map((item) => item[key])
}

// Usage
interface Person {
  name: string
  age: number
}

let people: Person[] = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
]

let names = pluck(people, 'name')
console.log(names) // Outputs: ['Alice', 'Bob']

let ages = pluck(people, 'age')
console.log(ages) // Outputs: [30, 25]
```

---

### **Exercise 5: Generic Constraint with Interface**

**Question**:

Define an interface `Equatable` with a method `equals(other: this): boolean`. Create a generic function `areEqual` that takes two parameters of type `T` (where `T` extends `Equatable`) and returns a boolean indicating if they are equal.

**Answer**:

```typescript
interface Equatable {
  equals(other: this): boolean
}

function areEqual<T extends Equatable>(a: T, b: T): boolean {
  return a.equals(b)
}

// Usage
class Point implements Equatable {
  x: number
  y: number
  constructor(x: number, y: number) {
    this.x = x
    this.y = y
  }
  equals(other: this): boolean {
    return this.x === other.x && this.y === other.y
  }
}

let p1 = new Point(5, 10)
let p2 = new Point(5, 10)
let p3 = new Point(10, 15)

console.log(areEqual(p1, p2)) // Outputs: true
console.log(areEqual(p1, p3)) // Outputs: false
```

---

## **11. Conclusion**

Generics and constraints are powerful features in TypeScript that enable you to write flexible, reusable, and type-safe code. By using generics in functions, classes, and interfaces, you can create components that work with a variety of types while maintaining strong type checking. Constraints with `extends` allow you to enforce type requirements, ensuring that your generic components behave as expected. Mastery of generics and constraints enhances your ability to build robust TypeScript applications and prepares you for advanced development tasks and technical interviews.

---

## **12. Next Steps**

- **Practice**:

  - Implement generics in your projects.
  - Experiment with constraints and the `keyof` operator.

- **Explore**:

  - Learn about advanced type features like conditional types and mapped types.
  - Study how generics interact with other TypeScript features like decorators.

- **Prepare**:

  - Review additional interview questions on TypeScript generics and type system.
  - Build projects using generics and constraints to reinforce your understanding.

---

**Continue enhancing your TypeScript expertise by mastering generics and constraints!**

---

## **13. Appendix**

### **Glossary**

- **Generics**: A feature that allows the creation of components that can work with a variety of types while providing type safety.
- **Constraints**: Restrictions applied to generic types using the `extends` keyword to ensure they meet certain requirements.
- **Type Parameter**: A variable used in generics to represent types.
- **Keyof Operator**: An operator that takes an object type and produces a union of its keys.
- **Index Types**: Types that use keys from another type to index into that type.
- **Generic Interface**: An interface that uses generics to work with multiple types.
- **Bounded Type Parameter**: A type parameter constrained by extending another type.

---

**End of Lesson**
