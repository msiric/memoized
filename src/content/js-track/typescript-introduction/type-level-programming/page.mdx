export const metadata = {   title: "Type-Level Programming in TypeScript",   description: "Advance your TypeScript expertise by mastering type-level programming. This lesson explores recursive types and advanced type manipulations, empowering you to harness the full potential of TypeScript's type system. By understanding how to create and manipulate types at an advanced level, you will be able to write more expressive, type-safe, and maintainable code. This comprehensive lesson will deepen your understanding of TypeScript's capabilities and prepare you for complex development tasks and technical interviews by covering these essential topics.", }

# **Type-Level Programming in TypeScript**

Type-level programming in TypeScript involves writing code that operates on types rather than values, allowing you to perform computations and transformations at the type level. This powerful feature enables the creation of complex and dynamic types that can enhance type safety and expressiveness in your applications. This lesson focuses on recursive types and advanced type manipulations, providing you with the tools to push the boundaries of what is possible with TypeScript's type system.



## **Introduction to Type-Level Programming**

### **What is Type-Level Programming?**

- **Definition**: Type-level programming is the practice of writing code that operates on types rather than values. It involves using TypeScript's type system to perform computations, transformations, and validations at the type level.
- **Purpose**:
  - Enhance type safety and correctness.
  - Create more expressive and flexible type definitions.
  - Enable complex type transformations and validations.

### **Importance in TypeScript**

- **Type Safety**: Improves the robustness of code by catching errors at compile time.
- **Expressiveness**: Allows for more precise type definitions that can model complex data structures and patterns.
- **Maintainability**: Reduces runtime errors and enhances code clarity, making it easier to maintain and scale applications.

## **Recursive Types**

### **Understanding Recursive Types**

- **Definition**: Recursive types are types that reference themselves in their definition. They are useful for modeling recursive data structures such as trees, linked lists, and nested objects.
- **Syntax**:

  ```typescript
  interface Node {
    value: string
    next?: Node
  }
  ```

### **Examples of Recursive Types**

- **Example 1: Linked List Node**

  ```typescript
  interface ListNode<T> {
    value: T
    next?: ListNode<T>
  }
  ```

- **Example 2: JSON Value**

  ```typescript
  type JSONValue =
    | string
    | number
    | boolean
    | null
    | JSONValue[]
    | { [key: string]: JSONValue }
  ```

- **Explanation**:

  - The `JSONValue` type represents any valid JSON data, including nested objects and arrays.
  - It uses recursion to define that a JSON value can be an object whose values are also `JSONValue`.

### **Practical Use Cases**

- **Nested Data Structures**: Defining types for nested objects, trees, or graphs.
- **Parsing and Serialization**: Validating data structures that can be serialized to or from formats like JSON or XML.
- **Complex Data Modeling**: Representing hierarchical relationships and self-referential types.

## **Advanced Type Manipulations**

### **Conditional Types Revisited**

- **Definition**: Conditional types allow for type expressions that depend on other types.
- **Syntax**:

  ```typescript
  T extends U ? X : Y
  ```

- **Example**:

  ```typescript
  type IsString<T> = T extends string ? true : false

  type A = IsString<string> // true
  type B = IsString<number> // false
  ```

- **Distributive Conditional Types**:

  - When a conditional type operates on a union type, it distributes over each member.

  ```typescript
  type Exclude<T, U> = T extends U ? never : T

  type T0 = Exclude<'a' | 'b' | 'c', 'a' | 'f'> // 'b' | 'c'
  ```

### **Mapped Types with Modifiers**

- **Adding Modifiers**: Use `+` or `-` to add or remove modifiers like `readonly` or `?`.

  ```typescript
  type Mutable<T> = {
    -readonly [P in keyof T]: T[P]
  }

  type Required<T> = {
    [P in keyof T]-?: T[P]
  }
  ```

- **Example**:

  ```typescript
  interface User {
    readonly id: number
    name?: string
  }

  type MutableUser = Mutable<User>
  // Now 'id' is not readonly

  type RequiredUser = Required<User>
  // Now 'name' is required
  ```

### **Infer Keyword and Type Inference**

- **Definition**: The `infer` keyword allows you to extract and manipulate types within conditional types.

- **Syntax**:

  ```typescript
  type ReturnType<T> = T extends (...args: any[]) => infer R ? R : any
  ```

- **Example**:

  ```typescript
  function getUser() {
    return { id: 1, name: 'Alice' }
  }

  type User = ReturnType<typeof getUser>
  // User is { id: number; name: string; }
  ```

- **Extracting Function Argument Types**:

  ```typescript
  type Parameters<T extends (...args: any[]) => any> = T extends (
    ...args: infer P
  ) => any
    ? P
    : never

  type UserFunction = (id: number, name: string) => void
  type Params = Parameters<UserFunction>
  // Params is [number, string]
  ```

## **Template Literal Types**

### **Introduction to Template Literal Types**

- **Definition**: Template literal types allow you to create string literal types by combining other types or string literals.

- **Syntax**:

  ```typescript
  type HelloWorld = `Hello ${string}`
  ```

### **String Manipulation at the Type Level**

- **Creating Union Types from Strings**:

  ```typescript
  type Direction = 'left' | 'right' | 'up' | 'down'

  type DirectionAction = `move_${Direction}`

  // DirectionAction is 'move_left' | 'move_right' | 'move_up' | 'move_down'
  ```

- **Capitalization Utilities**:

  ```typescript
  type CapitalizedDirection = Capitalize<Direction>
  // 'Left' | 'Right' | 'Up' | 'Down'
  ```

- **Example: Creating Event Names**

  ```typescript
  type Events = 'click' | 'hover' | 'scroll'

  type EventHandlerName<E extends string> = `on${Capitalize<E>}`

  type EventHandlers = EventHandlerName<Events>
  // 'onClick' | 'onHover' | 'onScroll'
  ```

### **Practical Applications**

- **Dynamic Property Names**: Generate types for objects with dynamic keys.

  ```typescript
  type RemovePrefix<T extends string> = T extends `on${infer U}`
    ? Uncapitalize<U>
    : T

  type EventName = RemovePrefix<'onClick'> // 'click'
  ```

- **Validation of String Formats**: Enforce specific string patterns at the type level.

## **Key Remapping in Mapped Types**

### **Changing Property Names**

- **Key Remapping Syntax**:

  ```typescript
  type Remapped<T> = {
    [K in keyof T as NewKeyType]: T[K]
  }
  ```

- **Example**:

  ```typescript
  interface User {
    id: number
    name: string
  }

  type PrefixKeys<T, Prefix extends string> = {
    [K in keyof T as `${Prefix}${Capitalize<string & K>}`]: T[K]
  }

  type PrefixedUser = PrefixKeys<User, 'user'>

  // PrefixedUser is:
  // {
  //   userId: number;
  //   userName: string;
  // }
  ```

### **Filtering and Transforming Keys**

- **Filtering Keys**:

  ```typescript
  type RemoveKeys<T, K extends keyof T> = {
    [P in keyof T as Exclude<P, K>]: T[P]
  }

  type UserWithoutId = RemoveKeys<User, 'id'>

  // { name: string }
  ```

- **Transforming Keys**:

  ```typescript
  type ToUpperCaseKeys<T> = {
    [K in keyof T as Uppercase<string & K>]: T[K]
  }

  type UpperCaseUser = ToUpperCaseKeys<User>
  // { ID: number; NAME: string; }
  ```

## **Variadic Tuple Types**

### **Working with Tuple Types**

- **Definition**: Tuples are fixed-length arrays with known types at each index.

  ```typescript
  type Point = [number, number]

  const point: Point = [10, 20]
  ```

### **Manipulating Tuples with Type-Level Functions**

- **Rest Elements in Tuple Types**:

  ```typescript
  type FirstElement<T extends any[]> = T extends [infer U, ...any[]] ? U : never

  type Element = FirstElement<[string, number, boolean]> // string
  ```

- **Concatenating Tuples**:

  ```typescript
  type Concat<T extends any[], U extends any[]> = [...T, ...U]

  type Combined = Concat<[1, 2], [3, 4]> // [1, 2, 3, 4]
  ```

- **Reverse a Tuple** (Advanced):

  ```typescript
  type Reverse<T extends any[]> = T extends [infer First, ...infer Rest]
    ? [...Reverse<Rest>, First]
    : []

  type Reversed = Reverse<[1, 2, 3]> // [3, 2, 1]
  ```

## **Creating Complex Types**

### **Composing Types**

- **Combining Types**:

  ```typescript
  type Intersection<T, U> = T & U

  interface A {
    a: string
  }

  interface B {
    b: number
  }

  type AB = Intersection<A, B>
  // { a: string; b: number; }
  ```

### **Building Utility Types**

- **DeepPartial**: Makes all properties and sub-properties optional.

  ```typescript
  type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
  }

  interface User {
    id: number
    name: string
    address: {
      street: string
      city: string
    }
  }

  type PartialUser = DeepPartial<User>

  const user: PartialUser = {
    name: 'Alice',
    address: {
      city: 'Wonderland',
    },
  }
  ```

- **DeepReadonly**: Makes all properties and sub-properties readonly.

  ```typescript
  type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]
  }

  type ReadonlyUser = DeepReadonly<User>

  const user: ReadonlyUser = {
    id: 1,
    name: 'Alice',
    address: {
      street: '123 Main St',
      city: 'Wonderland',
    },
  }

  // user.name = 'Bob'; // Error: Cannot assign to 'name' because it is a read-only property.
  // user.address.city = 'Oz'; // Error
  ```

## **Practical Examples**

### **Recursive Type Example: JSON Validation**

- **Validating JSON Structures**:

  ```typescript
  type JSONPrimitive = string | number | boolean | null
  type JSONArray = JSONValue[]
  type JSONObject = { [key: string]: JSONValue }
  type JSONValue = JSONPrimitive | JSONArray | JSONObject

  function isJSONValue(value: any): value is JSONValue {
    if (
      typeof value === 'string' ||
      typeof value === 'number' ||
      typeof value === 'boolean' ||
      value === null
    ) {
      return true
    }

    if (Array.isArray(value)) {
      return value.every(isJSONValue)
    }

    if (typeof value === 'object' && value !== null) {
      return Object.values(value).every(isJSONValue)
    }

    return false
  }
  ```

### **Advanced Type Manipulation Example: Flattening Types**

- **Flattening Nested Types**:

  ```typescript
  type Flatten<T> = T extends Array<infer U> ? Flatten<U> : T

  type NestedArray = number[][][]

  type Flat = Flatten<NestedArray> // number
  ```

- **Deep Merge Two Types** (Advanced):

  ```typescript
  type DeepMerge<T, U> = {
    [K in keyof T | keyof U]: K extends keyof U
      ? U[K]
      : K extends keyof T
        ? T[K]
        : never
  }
  ```

## **Best Practices**

- **Use Type Inference Wisely**: Leverage TypeScript's type inference to simplify type definitions.
- **Avoid Overcomplicating Types**: Keep type definitions as simple as possible to maintain code readability.
- **Test Complex Types**: Validate complex type manipulations with test cases and examples.
- **Document Advanced Types**: Provide documentation and comments for complex type-level code.
- **Leverage Built-in Utility Types**: Use TypeScript's built-in types before creating custom ones.
- **Stay Updated**: Keep abreast of the latest TypeScript features and enhancements.

## **Exercises**

### **Exercise 1: Recursive Type for a Tree Structure**

**Question**:

Define a recursive type `TreeNode` that represents a node in a tree. Each node has a `value` of type `T` and an array of `children`, which are also `TreeNode<T>`.

**Answer**:

```typescript
interface TreeNode<T> {
  value: T
  children?: TreeNode<T>[]
}

// Example usage
const tree: TreeNode<number> = {
  value: 1,
  children: [
    {
      value: 2,
      children: [{ value: 4 }, { value: 5 }],
    },
    { value: 3 },
  ],
}
```

### **Exercise 2: Type Inference with `infer`**

**Question**:

Create a type `FirstParameter<T>` that extracts the type of the first parameter of a function type `T`.

**Answer**:

```typescript
type FirstParameter<T extends (...args: any) => any> = T extends (
  arg1: infer P,
  ...args: any[]
) => any
  ? P
  : never

// Example usage
type Func = (name: string, age: number) => void
type Param1 = FirstParameter<Func> // string
```

### **Exercise 3: Template Literal Types for Event Names**

**Question**:

Given a union of event names `Events = 'start' | 'stop' | 'pause'`, create a type `EventHandlers` that represents the handler names in the format `on<Event>` (e.g., `onStart`).

**Answer**:

```typescript
type Events = 'start' | 'stop' | 'pause'

type EventHandlers = `on${Capitalize<Events>}`
// EventHandlers is 'onStart' | 'onStop' | 'onPause'
```

### **Exercise 4: Key Remapping to Remove Properties**

**Question**:

Given an interface `Person` with properties `id`, `name`, and `age`, create a type `PersonWithoutId` that removes the `id` property using key remapping in mapped types.

**Answer**:

```typescript
interface Person {
  id: number
  name: string
  age: number
}

type PersonWithoutId = {
  [K in keyof Person as Exclude<K, 'id'>]: Person[K]
}

// PersonWithoutId is { name: string; age: number; }
```

### **Exercise 5: Variadic Tuple Types for Function Composition**

**Question**:

Create a type `Compose<T extends any[], R>` that represents a function composition of functions with arguments `T` and return type `R`.

**Answer**:

```typescript
type Compose<T extends any[], R> = (...args: T) => R

// Example usage
type Func1 = (a: number, b: string) => boolean

type ComposedFunc = Compose<[number, string], boolean>
// ComposedFunc is (a: number, b: string) => boolean
```


Type-level programming in TypeScript opens up a world of possibilities for creating complex, expressive, and type-safe applications. By mastering recursive types, advanced type manipulations, template literal types, and variadic tuple types, you can harness the full power of TypeScript's type system. Understanding these advanced concepts will enhance your ability to build robust applications and prepare you for tackling complex development challenges and technical interviews.



