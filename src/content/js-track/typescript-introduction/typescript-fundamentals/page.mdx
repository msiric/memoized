**Lesson Title**: **TypeScript Fundamentals**

**Lesson Description**:  
Begin your journey into TypeScript by understanding its core fundamentals. This lesson introduces TypeScript, a statically typed superset of JavaScript that enhances code quality and developer productivity. Learn how to set up a TypeScript development environment, explore its key features, and discover the benefits it offers over traditional JavaScript. By mastering these fundamentals, you will be equipped to write robust, maintainable, and scalable applications. This comprehensive lesson will deepen your knowledge of type systems in JavaScript and prepare you for technical interviews by covering these essential topics.

---

# **TypeScript Fundamentals**

TypeScript is an open-source programming language developed and maintained by Microsoft. It builds upon JavaScript by adding static type definitions, enabling developers to catch errors early, improve code readability, and enhance tooling support. This lesson covers the basics of TypeScript, including how to set it up and the advantages it provides over plain JavaScript.

---

## **Table of Contents**

1. **Introduction to TypeScript**
   - What is TypeScript?
   - Key Features
2. **Setting Up TypeScript**
   - Installing TypeScript
   - Configuring the TypeScript Compiler
   - Integrating with Development Environments
3. **TypeScript vs. JavaScript**
   - Benefits of TypeScript
   - Common Misconceptions
4. **Basic Types and Syntax**
   - Primitive Types
   - Arrays and Tuples
   - Enums
   - Any, Unknown, and Void
5. **Interfaces and Type Aliases**
   - Defining Interfaces
   - Extending Interfaces
   - Type Aliases
6. **Classes and Inheritance**
   - Class Syntax in TypeScript
   - Access Modifiers
   - Inheritance and Abstract Classes
7. **Generics**
   - Understanding Generics
   - Generic Functions and Classes
8. **Modules and Namespaces**
   - Exporting and Importing Modules
   - Namespaces (Legacy)
9. **TypeScript Compiler Options**
   - Compiler Flags
   - Strict Mode
10. **Best Practices**
11. **Common Interview Questions**
12. **Exercises**
13. **Conclusion**
14. **Next Steps**
15. **Appendix**

---

## **Introduction to TypeScript**

### **What is TypeScript?**

- **Definition**: TypeScript is a statically typed superset of JavaScript that compiles to plain JavaScript.
- **Purpose**:
  - Adds optional static typing to JavaScript.
  - Enables developers to write more robust and maintainable code.
- **Compatibility**:
  - TypeScript code is transformed into JavaScript through a compiler.
  - Supports all JavaScript libraries and frameworks.

### **Key Features**

- **Static Typing**: Detects type errors at compile time.
- **Enhanced IDE Support**: Better code completion, refactoring, and navigation.
- **Advanced Type System**: Interfaces, generics, type inference, and unions.
- **Modern JavaScript Features**: Supports ES6 and beyond, including async/await, decorators, and more.
- **Code Scalability**: Facilitates large-scale application development.

---

## **Setting Up TypeScript**

### **Installing TypeScript**

- **Prerequisites**:
  - **Node.js and npm**: Ensure you have Node.js and npm installed.

- **Installation Command**:

  ```bash
  npm install -g typescript
  ```

- **Verify Installation**:

  ```bash
  tsc --version
  ```

  - Should display the installed TypeScript version.

### **Configuring the TypeScript Compiler**

- **`tsconfig.json` File**:

  - Configuration file for the TypeScript compiler (`tsc`).
  - Defines compiler options and project settings.

- **Creating `tsconfig.json`**:

  ```bash
  tsc --init
  ```

- **Sample `tsconfig.json`**:

  ```json
  {
    "compilerOptions": {
      "target": "ES6",
      "module": "commonjs",
      "strict": true,
      "outDir": "./dist",
      "rootDir": "./src",
      "esModuleInterop": true
    },
    "include": ["src/**/*"]
  }
  ```

- **Key Compiler Options**:

  - **`target`**: Specifies the JavaScript version to compile to.
  - **`module`**: Determines the module system (`commonjs`, `es6`, etc.).
  - **`strict`**: Enables strict type-checking options.
  - **`outDir`**: Output directory for compiled JavaScript files.
  - **`rootDir`**: Root directory of TypeScript source files.

### **Integrating with Development Environments**

- **Visual Studio Code**:

  - **Built-in TypeScript Support**: VS Code has excellent TypeScript integration.
  - **Features**:
    - Syntax highlighting.
    - IntelliSense (code completion).
    - Error detection.
    - Debugging capabilities.

- **Other IDEs**:

  - **WebStorm**: Provides comprehensive TypeScript support.
  - **Atom and Sublime Text**: Require plugins for TypeScript integration.

- **Setting Up Build Tasks**:

  - Automate the compilation process within the IDE.
  - **VS Code Example**:

    ```json
    // .vscode/tasks.json
    {
      "version": "2.0.0",
      "tasks": [
        {
          "type": "typescript",
          "tsconfig": "tsconfig.json",
          "problemMatcher": ["$tsc"],
          "group": {
            "kind": "build",
            "isDefault": true
          }
        }
      ]
    }
    ```

---

## **TypeScript vs. JavaScript**

### **Benefits of TypeScript**

- **Early Error Detection**:

  - **Compile-Time Checking**: Identifies type-related errors before execution.
  - **Example**:

    ```typescript
    let num: number = 'hello'; // Error: Type 'string' is not assignable to type 'number'.
    ```

- **Improved Code Readability and Maintainability**:

  - **Explicit Types**: Makes the code self-documenting.
  - **Interfaces and Types**: Define clear contracts within the code.

- **Enhanced Tooling and IDE Support**:

  - **IntelliSense**: Better autocompletion and suggestions.
  - **Refactoring Tools**: Safer and more reliable code transformations.

- **Large-Scale Application Development**:

  - **Modularity**: Encourages modular code organization.
  - **Scalability**: Facilitates managing complex codebases.

### **Common Misconceptions**

- **TypeScript Replaces JavaScript**:

  - **Reality**: TypeScript is a superset; it enhances JavaScript but does not replace it.

- **Steep Learning Curve**:

  - **Reality**: TypeScript builds on JavaScript knowledge; initial setup may require effort, but benefits outweigh the costs.

- **Reduces Flexibility**:

  - **Reality**: TypeScript allows opting into types; you can gradually introduce typing.

---

## **Basic Types and Syntax**

### **Primitive Types**

- **`number`**:

  ```typescript
  let age: number = 30;
  ```

- **`string`**:

  ```typescript
  let name: string = 'Alice';
  ```

- **`boolean`**:

  ```typescript
  let isActive: boolean = true;
  ```

- **`null` and `undefined`**:

  ```typescript
  let data: null = null;
  let notAssigned: undefined = undefined;
  ```

- **Type Inference**:

  - TypeScript infers the type based on the assigned value.

  ```typescript
  let message = 'Hello World'; // Inferred as string
  ```

### **Arrays and Tuples**

- **Arrays**:

  - **Syntax**:

    ```typescript
    let numbers: number[] = [1, 2, 3];
    ```

  - **Generic Array Type**:

    ```typescript
    let fruits: Array<string> = ['apple', 'banana'];
    ```

- **Tuples**:

  - Fixed-length arrays with known types.

  ```typescript
  let tuple: [string, number];
  tuple = ['Alice', 30]; // Correct
  // tuple = [30, 'Alice']; // Error
  ```

### **Enums**

- **Definition**:

  - Enums allow defining a set of named constants.

- **Numeric Enums**:

  ```typescript
  enum Direction {
    North,
    South,
    East,
    West,
  }

  let dir: Direction = Direction.North;
  ```

- **String Enums**:

  ```typescript
  enum Status {
    Active = 'ACTIVE',
    Inactive = 'INACTIVE',
    Pending = 'PENDING',
  }

  let currentStatus: Status = Status.Active;
  ```

### **Any, Unknown, and Void**

- **`any`**:

  - Opts out of type checking.

  ```typescript
  let randomValue: any = 10;
  randomValue = 'Hello';
  randomValue = true;
  ```

- **`unknown`**:

  - Similar to `any` but safer; requires type checking before usage.

  ```typescript
  let uncertainValue: unknown = 'Hello';

  if (typeof uncertainValue === 'string') {
    console.log(uncertainValue.toUpperCase());
  }
  ```

- **`void`**:

  - Indicates the absence of a type, commonly used in functions that do not return a value.

  ```typescript
  function logMessage(message: string): void {
    console.log(message);
  }
  ```

---

## **Interfaces and Type Aliases**

### **Defining Interfaces**

- **Purpose**:

  - Define contracts for objects and functions.

- **Syntax**:

  ```typescript
  interface Person {
    name: string;
    age: number;
    greet(): void;
  }

  const alice: Person = {
    name: 'Alice',
    age: 30,
    greet() {
      console.log(`Hello, my name is ${this.name}`);
    },
  };
  ```

### **Extending Interfaces**

- **Inheritance**:

  ```typescript
  interface Employee extends Person {
    employeeId: number;
  }

  const bob: Employee = {
    name: 'Bob',
    age: 25,
    employeeId: 12345,
    greet() {
      console.log(`Hello, my name is ${this.name}`);
    },
  };
  ```

### **Type Aliases**

- **Definition**:

  - Create aliases for complex types.

- **Syntax**:

  ```typescript
  type Point = {
    x: number;
    y: number;
  };

  let origin: Point = { x: 0, y: 0 };
  ```

- **Union Types**:

  ```typescript
  type ID = string | number;

  let userId: ID = 'abc123';
  ```

---

## **Classes and Inheritance**

### **Class Syntax in TypeScript**

- **Defining a Class**:

  ```typescript
  class Animal {
    name: string;

    constructor(name: string) {
      this.name = name;
    }

    move(distance: number): void {
      console.log(`${this.name} moved ${distance} meters.`);
    }
  }
  ```

### **Access Modifiers**

- **Public (default)**:

  - Accessible from anywhere.

- **Private**:

  - Accessible only within the class.

  ```typescript
  class Person {
    private ssn: string;

    constructor(ssn: string) {
      this.ssn = ssn;
    }
  }
  ```

- **Protected**:

  - Accessible within the class and subclasses.

  ```typescript
  class Employee {
    protected employeeId: number;

    constructor(employeeId: number) {
      this.employeeId = employeeId;
    }
  }

  class Manager extends Employee {
    constructor(employeeId: number) {
      super(employeeId);
      console.log(this.employeeId); // Accessible
    }
  }
  ```

- **Readonly**:

  - Value cannot be changed after initialization.

  ```typescript
  class Car {
    readonly make: string = 'Toyota';

    constructor(make: string) {
      this.make = make;
    }
  }
  ```

### **Inheritance and Abstract Classes**

- **Inheritance**:

  ```typescript
  class Dog extends Animal {
    bark(): void {
      console.log('Woof!');
    }
  }

  const dog = new Dog('Buddy');
  dog.bark(); // Outputs: Woof!
  dog.move(10); // Outputs: Buddy moved 10 meters.
  ```

- **Abstract Classes**:

  - Cannot be instantiated directly.
  - Contain abstract methods that must be implemented in derived classes.

  ```typescript
  abstract class Shape {
    abstract area(): number;
  }

  class Circle extends Shape {
    radius: number;

    constructor(radius: number) {
      super();
      this.radius = radius;
    }

    area(): number {
      return Math.PI * this.radius * this.radius;
    }
  }
  ```

---

## **Generics**

### **Understanding Generics**

- **Definition**:

  - Generics allow creating components that work with a variety of types.

- **Generic Functions**:

  ```typescript
  function identity<T>(arg: T): T {
    return arg;
  }

  let output = identity<string>('Hello');
  let numberOutput = identity<number>(42);
  ```

- **Type Inference with Generics**:

  ```typescript
  let inferredOutput = identity('TypeScript'); // Type inferred as string
  ```

### **Generic Classes and Interfaces**

- **Generic Class**:

  ```typescript
  class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
  }

  let myNumber = new GenericNumber<number>();
  myNumber.zeroValue = 0;
  myNumber.add = (x, y) => x + y;
  ```

- **Generic Interface**:

  ```typescript
  interface KeyValuePair<K, V> {
    key: K;
    value: V;
  }

  let kvp: KeyValuePair<number, string> = { key: 1, value: 'One' };
  ```

---

## **Modules and Namespaces**

### **Exporting and Importing Modules**

- **Exporting**:

  ```typescript
  // math.ts
  export function add(a: number, b: number): number {
    return a + b;
  }
  ```

- **Importing**:

  ```typescript
  // main.ts
  import { add } from './math';

  console.log(add(5, 3)); // Outputs: 8
  ```

- **Default Exports**:

  ```typescript
  // logger.ts
  export default function log(message: string): void {
    console.log(message);
  }

  // main.ts
  import log from './logger';

  log('Hello, TypeScript');
  ```

### **Namespaces (Legacy)**

- **Definition**:

  - Used to organize code within a global context.
  - Not recommended in modern TypeScript; use modules instead.

- **Syntax**:

  ```typescript
  namespace Utilities {
    export function log(message: string): void {
      console.log(message);
    }
  }

  Utilities.log('Logging a message');
  ```

---

## **TypeScript Compiler Options**

### **Compiler Flags**

- **`--target`**:

  - Specifies ECMAScript target version (`ES3`, `ES5`, `ES6`, `ES2015`, etc.).

- **`--module`**:

  - Module system to use (`commonjs`, `amd`, `es6`, etc.).

- **`--outDir` and `--rootDir`**:

  - Specify output and root directories.

- **`--sourceMap`**:

  - Generates source map files for debugging.

  ```bash
  tsc --sourceMap
  ```

### **Strict Mode**

- **`--strict` Flag**:

  - Enables all strict type-checking options.

- **Includes**:

  - `--noImplicitAny`: Flags variables with an implied `any` type.
  - `--strictNullChecks`: Ensures `null` and `undefined` are only assignable to themselves and `any`.
  - `--strictFunctionTypes`: Enforces strict checking of function types.
  - `--alwaysStrict`: Parses files in strict mode and emits `'use strict'` directive.

- **Benefits**:

  - Enhances code safety.
  - Catches more errors at compile time.

---

## **Best Practices**

- **Gradual Typing**:

  - Introduce TypeScript incrementally into JavaScript projects.

- **Use Interfaces and Types**:

  - Define clear contracts for objects and functions.

- **Enable Strict Mode**:

  - Use `--strict` for robust type-checking.

- **Avoid Using `any`**:

  - Prefer `unknown` or proper types to maintain type safety.

- **Consistent Coding Style**:

  - Follow a style guide and use linters like TSLint or ESLint with TypeScript support.

- **Leverage Advanced Features**:

  - Utilize generics, advanced types, and decorators where appropriate.

---

## **Common Interview Questions**

1. **What is TypeScript, and how does it differ from JavaScript?**

   **Answer**:

   - TypeScript is a statically typed superset of JavaScript developed by Microsoft.
   - It adds optional static typing, classes, interfaces, and other features.
   - TypeScript code is compiled into plain JavaScript.
   - It enhances developer productivity by catching errors at compile time and providing better tooling support.

2. **What are the benefits of using TypeScript over JavaScript?**

   **Answer**:

   - **Static Typing**: Detects errors early during development.
   - **Improved IDE Support**: Better code completion, navigation, and refactoring tools.
   - **Enhanced Readability**: Explicit types make the code more understandable.
   - **Scalability**: Facilitates the development of large applications.
   - **Modern Features**: Supports the latest ECMAScript features and beyond.

3. **Explain how interfaces are used in TypeScript.**

   **Answer**:

   - Interfaces define contracts for objects, specifying the structure they should adhere to.
   - They can define properties, methods, and their types.
   - Interfaces support inheritance through the `extends` keyword.
   - They help in type-checking and ensuring consistent object shapes.

   **Example**:

   ```typescript
   interface User {
     id: number;
     name: string;
     login(): void;
   }
   ```

4. **What are generics in TypeScript, and why are they useful?**

   **Answer**:

   - Generics allow the creation of components that can work with a variety of types while providing type safety.
   - They enable writing reusable and flexible code.
   - Generics provide a way to parameterize types.

   **Example**:

   ```typescript
   function identity<T>(arg: T): T {
     return arg;
   }
   ```

5. **How does TypeScript improve code maintainability in large-scale applications?**

   **Answer**:

   - **Type Safety**: Reduces runtime errors by catching them at compile time.
   - **Modularity**: Encourages breaking down code into modules and interfaces.
   - **Self-Documenting Code**: Explicit types make the codebase easier to understand.
   - **Refactoring Tools**: Enhanced IDE support aids in safely modifying code.
   - **Consistent Codebase**: Enforces coding standards and practices across teams.

---

## **Exercises**

### **Exercise 1: Setting Up a TypeScript Project**

**Question**:

Initialize a new TypeScript project with `tsconfig.json` configured to compile TypeScript files from the `src` directory to the `dist` directory, targeting ES6 and using CommonJS modules.

**Answer**:

1. **Initialize the Project**:

   ```bash
   mkdir my-typescript-project
   cd my-typescript-project
   npm init -y
   ```

2. **Install TypeScript**:

   ```bash
   npm install --save-dev typescript
   ```

3. **Create `tsconfig.json`**:

   ```bash
   npx tsc --init --rootDir src --outDir dist --target ES6 --module commonjs --strict
   ```

4. **Verify `tsconfig.json`**:

   ```json
   {
     "compilerOptions": {
       "target": "ES6",
       "module": "commonjs",
       "strict": true,
       "outDir": "./dist",
       "rootDir": "./src",
       "esModuleInterop": true
     },
     "include": ["src/**/*"]
   }
   ```

5. **Create Source Directory**:

   ```bash
   mkdir src
   ```

---

### **Exercise 2: Using Basic Types**

**Question**:

Write a TypeScript function `multiply` that takes two numbers as parameters and returns their product. Ensure that the function parameters and return type are properly typed.

**Answer**:

```typescript
function multiply(a: number, b: number): number {
  return a * b;
}

// Usage
console.log(multiply(5, 3)); // Outputs: 15
```

---

### **Exercise 3: Defining and Implementing Interfaces**

**Question**:

Define an interface `Vehicle` with properties `make` (string) and `model` (string), and a method `drive()` that returns void. Create a class `Car` that implements the `Vehicle` interface.

**Answer**:

```typescript
interface Vehicle {
  make: string;
  model: string;
  drive(): void;
}

class Car implements Vehicle {
  make: string;
  model: string;

  constructor(make: string, model: string) {
    this.make = make;
    this.model = model;
  }

  drive(): void {
    console.log(`Driving a ${this.make} ${this.model}`);
  }
}

// Usage
const myCar = new Car('Toyota', 'Corolla');
myCar.drive(); // Outputs: Driving a Toyota Corolla
```

---

### **Exercise 4: Generics in Functions**

**Question**:

Create a generic function `getArray` that takes an array of type `T` and returns a new array of the same type `T`. Demonstrate its usage with both number and string arrays.

**Answer**:

```typescript
function getArray<T>(items: T[]): T[] {
  return new Array<T>().concat(items);
}

// Usage with number array
let numberArray = getArray<number>([1, 2, 3]);
console.log(numberArray); // Outputs: [1, 2, 3]

// Usage with string array
let stringArray = getArray<string>(['a', 'b', 'c']);
console.log(stringArray); // Outputs: ['a', 'b', 'c']
```

---

### **Exercise 5: Using Modules**

**Question**:

Create a module `mathUtil.ts` that exports a function `square` which returns the square of a number. Import and use this function in another TypeScript file `app.ts`.

**Answer**:

**`mathUtil.ts`**:

```typescript
export function square(num: number): number {
  return num * num;
}
```

**`app.ts`**:

```typescript
import { square } from './mathUtil';

console.log(square(5)); // Outputs: 25
```

**Compilation and Execution**:

```bash
tsc
node dist/app.js
```

---

## **Conclusion**

TypeScript enhances JavaScript development by introducing static typing, advanced language features, and improved tooling support. By understanding TypeScript fundamentals, you can write more reliable, maintainable, and scalable code. Setting up TypeScript involves configuring the compiler and integrating it with your development environment, paving the way for efficient development workflows. Embracing TypeScript's benefits over JavaScript prepares you for modern application development and equips you with valuable skills for technical interviews and professional growth.

---

## **Next Steps**

- **Practice**:

  - Convert existing JavaScript code to TypeScript.
  - Explore advanced TypeScript features like advanced types, decorators, and mixins.

- **Explore**:

  - Integrate TypeScript with popular frameworks like React, Angular, or Node.js.
  - Learn about type declaration files (`.d.ts`) and how to use third-party libraries with TypeScript.

- **Prepare**:

  - Review additional interview questions on TypeScript and type systems.
  - Build projects using TypeScript to reinforce your understanding.

---

**Continue enhancing your development expertise by mastering TypeScript and type systems!**

---

## **Appendix**

### **Glossary**

- **Static Typing**: A feature where type checking is performed at compile time.
- **Type Inference**: The compiler automatically determines the type of a variable based on its value.
- **Interface**: A TypeScript structure that defines the contract in your application.
- **Generics**: A feature that allows the creation of reusable components that can work with a variety of types.
- **Module**: A file containing code that is encapsulated and can be exported and imported.
- **Namespace**: A way to group related code; in TypeScript, it's a way to organize code within the global scope (legacy feature).
- **Compiler Options**: Settings that configure how the TypeScript compiler (`tsc`) behaves.

---

**End of Lesson**