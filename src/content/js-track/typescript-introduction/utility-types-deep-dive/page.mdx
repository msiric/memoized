**Lesson Title**: **Utility Types Deep Dive in TypeScript**

**Lesson Description**:  
Enhance your TypeScript expertise by diving deep into utility types. This lesson focuses on understanding and effectively using built-in utility types such as `Partial`, `Readonly`, `Pick`, `Omit`, `Record`, `Exclude`, and `Extract`. These utility types leverage advanced TypeScript features like mapped types and conditional types to perform common type transformations. By mastering these utility types, you will be able to write more concise, flexible, and type-safe code. This comprehensive lesson will deepen your understanding of TypeScript's type system and prepare you for technical interviews by covering these essential topics.

---

# **Utility Types Deep Dive in TypeScript**

Utility types are built-in types provided by TypeScript that facilitate common type transformations. They are powerful tools that help you manipulate and transform types, making your code more robust and maintainable. This lesson explores the most commonly used utility types in TypeScript, providing detailed explanations and practical examples.

---

## **Table of Contents**

1. **Introduction to Utility Types**
   - What are Utility Types?
   - Importance in TypeScript
2. **Partial**
   - Understanding `Partial<T>`
   - Practical Examples
3. **Readonly**
   - Understanding `Readonly<T>`
   - Practical Examples
4. **Pick**
   - Understanding `Pick<T, K>`
   - Practical Examples
5. **Omit**
   - Understanding `Omit<T, K>`
   - Practical Examples
6. **Record**
   - Understanding `Record<K, T>`
   - Practical Examples
7. **Exclude**
   - Understanding `Exclude<T, U>`
   - Practical Examples
8. **Extract**
   - Understanding `Extract<T, U>`
   - Practical Examples
9. **Other Utility Types**
   - NonNullable
   - ReturnType
   - InstanceType
10. **Creating Custom Utility Types**
    - Combining Utility Types
    - Building Custom Types
11. **Best Practices**
12. **Common Interview Questions**
13. **Exercises**
14. **Conclusion**
15. **Next Steps**
16. **Appendix**

---

## **1. Introduction to Utility Types**

### **1.1 What are Utility Types?**

- **Definition**: Utility types are predefined types in TypeScript that provide type transformations.
- **Purpose**:
  - Simplify common type manipulations.
  - Reduce boilerplate code.
  - Enhance type safety and code readability.

### **1.2 Importance in TypeScript**

- **Efficiency**: Streamline the process of creating new types based on existing ones.
- **Consistency**: Ensure consistent type transformations across the codebase.
- **Expressiveness**: Provide powerful tools to express complex type relationships.

---

## **2. Partial**

### **2.1 Understanding `Partial<T>`**

- **Definition**: Constructs a type with all properties of `T` set to optional.
- **Syntax**:

  ```typescript
  type Partial<T> = {
    [P in keyof T]?: T[P]
  }
  ```

- **Use Cases**:
  - Creating functions that update objects partially.
  - Handling optional parameters in functions.

### **2.2 Practical Examples**

- **Example 1: Updating an Object**

  ```typescript
  interface User {
    id: number
    name: string
    email: string
  }

  function updateUser(id: number, updates: Partial<User>): User {
    const user = getUserFromDatabase(id)
    return { ...user, ...updates }
  }

  // Usage
  updateUser(1, { name: 'Alice' })
  ```

- **Example 2: Optional Form Fields**

  ```typescript
  interface FormFields {
    username: string
    password: string
    rememberMe: boolean
  }

  type OptionalFormFields = Partial<FormFields>

  const formValues: OptionalFormFields = {
    username: 'user123',
  }
  ```

---

## **3. Readonly**

### **3.1 Understanding `Readonly<T>`**

- **Definition**: Constructs a type with all properties of `T` set to `readonly`.
- **Syntax**:

  ```typescript
  type Readonly<T> = {
    readonly [P in keyof T]: T[P]
  }
  ```

- **Use Cases**:
  - Preventing modification of objects.
  - Ensuring immutability in data structures.

### **3.2 Practical Examples**

- **Example 1: Immutable Data Objects**

  ```typescript
  interface Point {
    x: number
    y: number
  }

  const origin: Readonly<Point> = { x: 0, y: 0 }
  // origin.x = 10; // Error: Cannot assign to 'x' because it is a read-only property.
  ```

- **Example 2: Freezing Objects**

  ```typescript
  function freezeObject<T>(obj: T): Readonly<T> {
    return Object.freeze(obj)
  }

  const user = freezeObject({ id: 1, name: 'Bob' })
  // user.name = 'Robert'; // Error
  ```

---

## **4. Pick**

### **4.1 Understanding `Pick<T, K>`**

- **Definition**: Constructs a type by picking a set of properties `K` from `T`.
- **Syntax**:

  ```typescript
  type Pick<T, K extends keyof T> = {
    [P in K]: T[P]
  }
  ```

- **Use Cases**:
  - Creating subsets of types.
  - Selecting specific properties for APIs or components.

### **4.2 Practical Examples**

- **Example 1: Creating a Subtype**

  ```typescript
  interface Employee {
    id: number
    name: string
    department: string
    salary: number
  }

  type EmployeePreview = Pick<Employee, 'id' | 'name'>

  const employee: EmployeePreview = { id: 1, name: 'Alice' }
  ```

- **Example 2: Simplifying Data Transfer Objects**

  ```typescript
  interface FullUser {
    id: number
    name: string
    email: string
    password: string
  }

  type UserDTO = Pick<FullUser, 'id' | 'name' | 'email'>

  function sendUserData(user: UserDTO): void {
    // Send user data without password
  }
  ```

---

## **5. Omit**

### **5.1 Understanding `Omit<T, K>`**

- **Definition**: Constructs a type by picking all properties from `T` and then removing `K`.
- **Syntax**:

  ```typescript
  type Omit<T, K extends keyof any> = Pick<T, Exclude<keyof T, K>>
  ```

- **Use Cases**:
  - Excluding certain properties from a type.
  - Modifying existing types for specific use cases.

### **5.2 Practical Examples**

- **Example 1: Removing Sensitive Information**

  ```typescript
  interface User {
    id: number
    name: string
    email: string
    password: string
  }

  type SafeUser = Omit<User, 'password'>

  const user: SafeUser = { id: 1, name: 'Bob', email: 'bob@example.com' }
  ```

- **Example 2: Adjusting Component Props**

  ```typescript
  interface ButtonProps {
    label: string
    onClick: () => void
    disabled: boolean
    theme: string
  }

  type IconButtonProps = Omit<ButtonProps, 'label'> & { icon: string }

  const iconButtonProps: IconButtonProps = {
    icon: 'settings',
    onClick: () => {},
    disabled: false,
    theme: 'dark',
  }
  ```

---

## **6. Record**

### **6.1 Understanding `Record<K, T>`**

- **Definition**: Constructs a type with a set of properties `K` of type `T`.
- **Syntax**:

  ```typescript
  type Record<K extends keyof any, T> = {
    [P in K]: T
  }
  ```

- **Use Cases**:
  - Creating dictionaries or maps with specific keys and value types.
  - Enforcing consistent value types across a set of properties.

### **6.2 Practical Examples**

- **Example 1: Mapping Roles to Permissions**

  ```typescript
  type Roles = 'admin' | 'editor' | 'viewer'

  interface Permissions {
    canEdit: boolean
    canDelete: boolean
    canView: boolean
  }

  type RolePermissions = Record<Roles, Permissions>

  const permissions: RolePermissions = {
    admin: { canEdit: true, canDelete: true, canView: true },
    editor: { canEdit: true, canDelete: false, canView: true },
    viewer: { canEdit: false, canDelete: false, canView: true },
  }
  ```

- **Example 2: Localized Strings**

  ```typescript
  type Languages = 'en' | 'es' | 'fr'

  type Translations = Record<Languages, string>

  const messages: Translations = {
    en: 'Hello',
    es: 'Hola',
    fr: 'Bonjour',
  }
  ```

---

## **7. Exclude**

### **7.1 Understanding `Exclude<T, U>`**

- **Definition**: Excludes from `T` those types that are assignable to `U`.
- **Syntax**:

  ```typescript
  type Exclude<T, U> = T extends U ? never : T
  ```

- **Use Cases**:
  - Removing types from a union.
  - Filtering out unwanted types.

### **7.2 Practical Examples**

- **Example 1: Filtering Union Types**

  ```typescript
  type Primitive = string | number | boolean | null | undefined

  type NonNullablePrimitive = Exclude<Primitive, null | undefined>

  let value: NonNullablePrimitive = 'Hello' // Valid
  // value = null; // Error
  ```

- **Example 2: Excluding Specific Types**

  ```typescript
  type AllKeys = 'id' | 'name' | 'email' | 'password'

  type PublicKeys = Exclude<AllKeys, 'password'>

  let key: PublicKeys = 'email' // Valid
  // key = 'password'; // Error
  ```

---

## **8. Extract**

### **8.1 Understanding `Extract<T, U>`**

- **Definition**: Extracts from `T` those types that are assignable to `U`.
- **Syntax**:

  ```typescript
  type Extract<T, U> = T extends U ? T : never
  ```

- **Use Cases**:
  - Selecting specific types from a union.
  - Narrowing down types.

### **8.2 Practical Examples**

- **Example 1: Extracting Shared Types**

  ```typescript
  type AllKeys = 'id' | 'name' | 'email' | 'password'

  type SensitiveKeys = Extract<AllKeys, 'password' | 'email'>

  let key: SensitiveKeys = 'email' // Valid
  // key = 'id'; // Error
  ```

- **Example 2: Filtering Types**

  ```typescript
  type Actions = 'CREATE' | 'READ' | 'UPDATE' | 'DELETE'

  type WriteActions = Extract<Actions, 'CREATE' | 'UPDATE' | 'DELETE'>

  let action: WriteActions = 'UPDATE' // Valid
  // action = 'READ'; // Error
  ```

---

## **9. Other Utility Types**

### **9.1 NonNullable**

- **Definition**: Excludes `null` and `undefined` from `T`.
- **Syntax**:

  ```typescript
  type NonNullable<T> = T extends null | undefined ? never : T
  ```

- **Example**:

  ```typescript
  type NullableString = string | null | undefined
  type NonNullString = NonNullable<NullableString> // string

  let name: NonNullString = 'Alice' // Valid
  // name = null; // Error
  ```

### **9.2 ReturnType**

- **Definition**: Obtains the return type of a function type.
- **Syntax**:

  ```typescript
  type ReturnType<T extends (...args: any) => any> = T extends (
    ...args: any
  ) => infer R
    ? R
    : any
  ```

- **Example**:

  ```typescript
  function getUser() {
    return { id: 1, name: 'Bob' }
  }

  type User = ReturnType<typeof getUser>

  const user: User = { id: 1, name: 'Bob' }
  ```

### **9.3 InstanceType**

- **Definition**: Obtains the instance type of a constructor function type.
- **Syntax**:

  ```typescript
  type InstanceType<T extends new (...args: any) => any> = T extends new (
    ...args: any
  ) => infer R
    ? R
    : any
  ```

- **Example**:

  ```typescript
  class Person {
    constructor(
      public name: string,
      public age: number,
    ) {}
  }

  type PersonInstance = InstanceType<typeof Person>

  const person: PersonInstance = new Person('Alice', 30)
  ```

---

## **10. Creating Custom Utility Types**

### **10.1 Combining Utility Types**

- **Example: DeepReadonly**

  ```typescript
  type DeepReadonly<T> = {
    readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P]
  }

  interface NestedObject {
    name: string
    details: {
      age: number
      address: {
        street: string
        city: string
      }
    }
  }

  const obj: DeepReadonly<NestedObject> = {
    name: 'Alice',
    details: {
      age: 30,
      address: {
        street: '123 Main St',
        city: 'Wonderland',
      },
    },
  }

  // obj.details.age = 31; // Error: Cannot assign to 'age' because it is a read-only property.
  ```

### **10.2 Building Custom Types**

- **Example: Mutable**

  ```typescript
  type Mutable<T> = {
    -readonly [P in keyof T]: T[P]
  }

  type MutableUser = Mutable<Readonly<User>>

  let user: MutableUser = { id: 1, name: 'Bob', email: 'bob@example.com' }
  user.name = 'Robert' // Now allowed
  ```

- **Example: Required**

  ```typescript
  type Required<T> = {
    [P in keyof T]-?: T[P]
  }

  interface OptionalUser {
    id?: number
    name?: string
    email?: string
  }

  type CompleteUser = Required<OptionalUser>

  const user: CompleteUser = {
    id: 1,
    name: 'Alice',
    email: 'alice@example.com',
  } // All properties are required
  ```

---

## **11. Best Practices**

- **Leverage Built-in Utility Types**:

  - Use TypeScript's built-in utility types before creating custom ones.

- **Understand Underlying Mechanics**:

  - Grasp how utility types work internally to create more effective custom types.

- **Avoid Overcomplicating Types**:

  - Keep type definitions simple and readable.

- **Consistent Naming Conventions**:

  - Use clear and descriptive names for custom utility types.

- **Test Type Transformations**:
  - Validate custom types with test cases to ensure they behave as expected.

---

## **12. Common Interview Questions**

1. **What is the purpose of the `Partial` utility type in TypeScript?**

   **Answer**:

   - The `Partial` utility type constructs a type with all properties of a given type `T` set to optional.
   - It is useful when you want to create a function or object that doesn't require all properties to be specified.
   - **Example**:

     ```typescript
     interface User {
       id: number
       name: string
       email: string
     }

     type PartialUser = Partial<User>
     ```

2. **How does the `Pick` utility type differ from the `Omit` utility type?**

   **Answer**:

   - `Pick<T, K>` constructs a type by selecting a set of properties `K` from type `T`.
   - `Omit<T, K>` constructs a type by excluding a set of properties `K` from type `T`.
   - **Example**:

     ```typescript
     interface User {
       id: number
       name: string
       email: string
       password: string
     }

     type UserPreview = Pick<User, 'id' | 'name'> // Includes 'id' and 'name'

     type SafeUser = Omit<User, 'password'> // Excludes 'password'
     ```

3. **What is the `Record` utility type used for in TypeScript?**

   **Answer**:

   - The `Record` utility type constructs a type with a set of properties `K` of type `T`.
   - It is useful for creating a type that maps keys to values of a specific type.
   - **Example**:

     ```typescript
     type Roles = 'admin' | 'editor' | 'viewer'

     type Permissions = Record<Roles, boolean>

     const permissions: Permissions = {
       admin: true,
       editor: false,
       viewer: true,
     }
     ```

4. **Explain how the `Exclude` and `Extract` utility types are different.**

   **Answer**:

   - `Exclude<T, U>` constructs a type by excluding from `T` all types that are assignable to `U`.
   - `Extract<T, U>` constructs a type by extracting from `T` all types that are assignable to `U`.
   - **Example**:

     ```typescript
     type AllKeys = 'id' | 'name' | 'email' | 'password'

     type PublicKeys = Exclude<AllKeys, 'password'> // 'id' | 'name' | 'email'

     type SensitiveKeys = Extract<AllKeys, 'password' | 'email'> // 'email' | 'password'
     ```

5. **How can you create a custom utility type to make all properties of a type `T` required?**

   **Answer**:

   - You can create a custom utility type `Required<T>` using mapped types.
   - The `-?` operator removes the optional modifier from properties.
   - **Example**:

     ```typescript
     type Required<T> = {
       [P in keyof T]-?: T[P]
     }

     interface OptionalUser {
       id?: number
       name?: string
       email?: string
     }

     type CompleteUser = Required<OptionalUser>
     ```

---

## **13. Exercises**

### **Exercise 1: Using `Partial`**

**Question**:

Given the interface `Task`, write a function `updateTask` that accepts an `id` and an object of type `Partial<Task>` to update the task. Demonstrate updating a task's `title` and `completed` status.

```typescript
interface Task {
  id: number
  title: string
  description: string
  completed: boolean
}
```

**Answer**:

```typescript
function updateTask(id: number, updates: Partial<Task>): Task {
  const task = getTaskFromDatabase(id) // Assume this function exists
  return { ...task, ...updates }
}

// Usage
updateTask(1, { title: 'New Title', completed: true })
```

---

### **Exercise 2: Creating a `Readonly` Array**

**Question**:

Create a `Readonly` array of strings called `fruits`. Attempt to modify the array by adding a new fruit and observe the TypeScript error.

**Answer**:

```typescript
const fruits: ReadonlyArray<string> = ['apple', 'banana', 'orange']

// fruits.push('grape'); // Error: Property 'push' does not exist on type 'readonly string[]'.
```

---

### **Exercise 3: Using `Pick`**

**Question**:

Given the interface `Article`, use `Pick` to create a type `ArticlePreview` that includes only the `title` and `summary` properties.

```typescript
interface Article {
  id: number
  title: string
  content: string
  summary: string
  author: string
}
```

**Answer**:

```typescript
type ArticlePreview = Pick<Article, 'title' | 'summary'>

const preview: ArticlePreview = {
  title: 'Understanding TypeScript',
  summary: 'A deep dive into TypeScript features.',
}
```

---

### **Exercise 4: Using `Omit`**

**Question**:

Using the same `Article` interface, create a type `ArticleContent` that includes all properties except `summary`.

**Answer**:

```typescript
type ArticleContent = Omit<Article, 'summary'>

const content: ArticleContent = {
  id: 1,
  title: 'Understanding TypeScript',
  content: 'Detailed content here...',
  author: 'John Doe',
}
```

---

### **Exercise 5: Combining Utility Types**

**Question**:

Create a custom utility type `PartialExcept<T, K>` that makes all properties of `T` optional except for `K`, which should remain required. Apply this to an interface `Profile` to make all properties optional except `id`.

```typescript
interface Profile {
  id: number
  name: string
  email: string
  age: number
}
```

**Answer**:

```typescript
type PartialExcept<T, K extends keyof T> = Partial<T> & Pick<T, K>

type ProfileWithRequiredId = PartialExcept<Profile, 'id'>

const profile: ProfileWithRequiredId = {
  id: 1,
  name: 'Alice',
  // 'email' and 'age' are optional
}
```

---

## **14. Conclusion**

Utility types in TypeScript are powerful tools that enhance your ability to manipulate and transform types effectively. By mastering utility types like `Partial`, `Readonly`, `Pick`, `Omit`, `Record`, `Exclude`, and `Extract`, you can write more concise, flexible, and type-safe code. These utility types simplify common type transformations, reduce boilerplate code, and improve code maintainability. Understanding and utilizing utility types will significantly enhance your TypeScript development skills and prepare you for advanced programming challenges and technical interviews.

---

## **15. Next Steps**

- **Practice**:

  - Implement utility types in your projects.
  - Create custom utility types to solve specific problems.

- **Explore**:

  - Learn about advanced utility types like `Awaited`, `ThisType`, and `Uppercase`.
  - Study how utility types interact with mapped and conditional types.

- **Prepare**:
  - Review additional interview questions on TypeScript utility types.
  - Build projects using utility types to reinforce your understanding.

---

**Continue enhancing your TypeScript expertise by mastering utility types!**

---
