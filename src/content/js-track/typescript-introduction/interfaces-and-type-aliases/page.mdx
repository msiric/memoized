**Lesson Title**: **Interfaces and Type Aliases in TypeScript**

**Lesson Description**:  
Deepen your understanding of TypeScript by mastering interfaces and type aliases. This lesson focuses on defining object shapes using interfaces, extending interfaces for reusability, and exploring type aliases for creating custom types. Learn how to leverage these powerful features to enforce type safety, enhance code readability, and create more maintainable codebases. By mastering interfaces and type aliases, you will be better equipped to design robust TypeScript applications. This comprehensive lesson will strengthen your grasp of TypeScript's type system and prepare you for technical interviews by covering these essential topics.

---

# **Interfaces and Type Aliases in TypeScript**

Interfaces and type aliases are fundamental features in TypeScript that allow developers to define custom types and object shapes. They provide a way to describe the structure of objects, enforce type contracts, and enhance code reusability. This lesson delves into how to define object shapes using interfaces, extend interfaces for inheritance, and utilize type aliases to create flexible and reusable types.

---

## **Table of Contents**

1. **Introduction to Interfaces and Type Aliases**
   - The Role of Interfaces and Type Aliases
   - Differences Between Interfaces and Type Aliases
2. **Defining Object Shapes with Interfaces**
   - Basic Interface Syntax
   - Optional Properties
   - Readonly Properties
3. **Function Types in Interfaces**
   - Defining Function Interfaces
   - Using Interfaces to Describe Function Signatures
4. **Extending Interfaces**
   - Interface Inheritance
   - Extending Multiple Interfaces
5. **Implementing Interfaces in Classes**
   - Using Interfaces with Classes
   - Enforcing Class Contracts
6. **Type Aliases**
   - Defining Type Aliases
   - Union and Intersection Types
   - Type Aliases vs. Interfaces
7. **Indexable Types and Interfaces**
   - Defining Index Signatures
   - Using Indexable Types
8. **Hybrid Types**
   - Combining Function and Object Types
   - Examples of Hybrid Types
9. **Best Practices**
10. **Common Interview Questions**
11. **Exercises**
12. **Conclusion**
13. **Next Steps**
14. **Appendix**

---

## **Introduction to Interfaces and Type Aliases**

### **The Role of Interfaces and Type Aliases**

- **Interfaces**:

  - Define contracts for objects, functions, and classes.
  - Describe the structure and types of object properties.
  - Enable type checking and enforce consistency.

- **Type Aliases**:
  - Create new names for existing types.
  - Define custom types, including union and intersection types.
  - Provide flexibility in type definitions.

### **Differences Between Interfaces and Type Aliases**

- **Interfaces**:

  - Primarily used to define object shapes.
  - Can be extended and implemented.
  - Support declaration merging.

- **Type Aliases**:
  - Can define any type, including primitives, unions, intersections, and tuples.
  - Cannot be re-opened to add new properties.
  - Cannot be implemented or extended in the same way as interfaces.

---

## **Defining Object Shapes with Interfaces**

Interfaces allow you to define the structure of an object by specifying its properties and their types.

### **Basic Interface Syntax**

- **Syntax**:

  ```typescript
  interface InterfaceName {
    property1: type1
    property2: type2
    // ...
  }
  ```

- **Example**:

  ```typescript
  interface User {
    id: number
    username: string
    email: string
  }

  const user: User = {
    id: 1,
    username: 'alice',
    email: 'alice@example.com',
  }
  ```

### **Optional Properties**

- **Definition**: Properties that may or may not be present in the object.

- **Syntax**:

  ```typescript
  interface InterfaceName {
    requiredProperty: type
    optionalProperty?: type
  }
  ```

- **Example**:

  ```typescript
  interface Product {
    id: number
    name: string
    description?: string // Optional property
  }

  const product1: Product = {
    id: 1,
    name: 'Laptop',
  }

  const product2: Product = {
    id: 2,
    name: 'Smartphone',
    description: 'Latest model with advanced features',
  }
  ```

### **Readonly Properties**

- **Definition**: Properties that cannot be changed after they are initialized.

- **Syntax**:

  ```typescript
  interface InterfaceName {
    readonly propertyName: type
  }
  ```

- **Example**:

  ```typescript
  interface Point {
    readonly x: number
    readonly y: number
  }

  const origin: Point = { x: 0, y: 0 }
  // origin.x = 5; // Error: Cannot assign to 'x' because it is a read-only property.
  ```

---

## **Function Types in Interfaces**

Interfaces can be used to define the shape of functions, specifying parameter types and return types.

### **Defining Function Interfaces**

- **Syntax**:

  ```typescript
  interface FunctionInterface {
    (param1: type1, param2: type2): returnType
  }
  ```

- **Example**:

  ```typescript
  interface StringProcessor {
    (input: string): string
  }

  const toUpperCase: StringProcessor = (input: string): string => {
    return input.toUpperCase()
  }

  console.log(toUpperCase('hello')) // Outputs: HELLO
  ```

### **Using Interfaces to Describe Function Signatures**

- **Example with Callback Functions**:

  ```typescript
  interface Comparator {
    (a: number, b: number): number
  }

  function sortNumbers(numbers: number[], compare: Comparator): number[] {
    return numbers.sort(compare)
  }

  const ascendingOrder: Comparator = (a, b) => a - b

  const sortedNumbers = sortNumbers([5, 2, 9, 1], ascendingOrder)
  console.log(sortedNumbers) // Outputs: [1, 2, 5, 9]
  ```

---

## **Extending Interfaces**

Interfaces can inherit from other interfaces, allowing for the creation of more complex types based on existing ones.

### **Interface Inheritance**

- **Syntax**:

  ```typescript
  interface BaseInterface {
    baseProperty: type
  }

  interface DerivedInterface extends BaseInterface {
    derivedProperty: type
  }
  ```

- **Example**:

  ```typescript
  interface Animal {
    name: string
    age: number
  }

  interface Dog extends Animal {
    breed: string
  }

  const myDog: Dog = {
    name: 'Buddy',
    age: 3,
    breed: 'Golden Retriever',
  }
  ```

### **Extending Multiple Interfaces**

- **Syntax**:

  ```typescript
  interface InterfaceA {
    propertyA: type
  }

  interface InterfaceB {
    propertyB: type
  }

  interface CombinedInterface extends InterfaceA, InterfaceB {
    propertyC: type
  }
  ```

- **Example**:

  ```typescript
  interface Shape {
    area: number
  }

  interface Colorful {
    color: string
  }

  interface ColoredShape extends Shape, Colorful {
    name: string
  }

  const square: ColoredShape = {
    name: 'Square',
    area: 25,
    color: 'blue',
  }
  ```

---

## **Implementing Interfaces in Classes**

Classes can implement interfaces to ensure they adhere to a specific structure.

### **Using Interfaces with Classes**

- **Syntax**:

  ```typescript
  interface InterfaceName {
    property: type
    method(): returnType
  }

  class ClassName implements InterfaceName {
    property: type
    method(): returnType {
      // Implementation
    }
  }
  ```

- **Example**:

  ```typescript
  interface Person {
    firstName: string
    lastName: string
    getFullName(): string
  }

  class Employee implements Person {
    firstName: string
    lastName: string
    employeeId: number

    constructor(firstName: string, lastName: string, employeeId: number) {
      this.firstName = firstName
      this.lastName = lastName
      this.employeeId = employeeId
    }

    getFullName(): string {
      return `${this.firstName} ${this.lastName}`
    }
  }

  const employee = new Employee('Alice', 'Johnson', 123)
  console.log(employee.getFullName()) // Outputs: Alice Johnson
  ```

### **Enforcing Class Contracts**

- **Benefit**: Ensures that a class provides specific methods and properties.

- **Example with Multiple Interfaces**:

  ```typescript
  interface CanFly {
    fly(): void
  }

  interface CanSwim {
    swim(): void
  }

  class Duck implements CanFly, CanSwim {
    fly(): void {
      console.log('Duck is flying.')
    }

    swim(): void {
      console.log('Duck is swimming.')
    }
  }

  const duck = new Duck()
  duck.fly() // Outputs: Duck is flying.
  duck.swim() // Outputs: Duck is swimming.
  ```

---

## **Type Aliases**

Type aliases allow you to create new names for types, including primitives, unions, intersections, and other types.

### **Defining Type Aliases**

- **Syntax**:

  ```typescript
  type AliasName = existingType
  ```

- **Example**:

  ```typescript
  type ID = number | string

  let userId: ID = 123
  userId = 'abc123'
  ```

### **Union and Intersection Types**

- **Union Types**:

  - Define a type that can be one of several types.

  - **Syntax**:

    ```typescript
    type UnionType = type1 | type2 | type3
    ```

  - **Example**:

    ```typescript
    type Status = 'success' | 'error' | 'loading'

    let currentStatus: Status = 'loading'
    ```

- **Intersection Types**:

  - Combine multiple types into one.

  - **Syntax**:

    ```typescript
    type IntersectionType = type1 & type2 & type3
    ```

  - **Example**:

    ```typescript
    interface ErrorResponse {
      errorCode: number
      message: string
    }

    interface DataResponse {
      data: any
    }

    type ApiResponse = ErrorResponse & DataResponse

    const response: ApiResponse = {
      errorCode: 0,
      message: 'Success',
      data: { id: 1, name: 'Item' },
    }
    ```

### **Type Aliases vs. Interfaces**

- **Interfaces**:

  - Better for defining object shapes.
  - Can be extended and implemented.
  - Support declaration merging.

- **Type Aliases**:

  - More flexible; can define unions, intersections, primitives, tuples.
  - Cannot be reopened to add new properties.

- **Choosing Between Them**:

  - Use interfaces to define object shapes and when you need to extend or implement.
  - Use type aliases for primitives, unions, intersections, and when flexibility is required.

---

## **Indexable Types and Interfaces**

Interfaces can define types that can be indexed, similar to arrays or objects with dynamic keys.

### **Defining Index Signatures**

- **Syntax**:

  ```typescript
  interface IndexableType {
    [index: type]: valueType
  }
  ```

- **Example**:

  ```typescript
  interface StringArray {
    [index: number]: string
  }

  const myArray: StringArray = ['Alice', 'Bob', 'Charlie']
  console.log(myArray[1]) // Outputs: Bob
  ```

### **Using Indexable Types**

- **Dynamic Property Names**:

  ```typescript
  interface NumberDictionary {
    [key: string]: number
    length: number // Can have specific properties
  }

  const numbers: NumberDictionary = {
    one: 1,
    two: 2,
    length: 2,
  }

  console.log(numbers['one']) // Outputs: 1
  ```

- **Constraints on Index Signatures**:

  - The type of the index signature must be 'string' or 'number'.
  - All properties must conform to the index signature type.

---

## **Hybrid Types**

Some types can act as both objects and functions.

### **Combining Function and Object Types**

- **Syntax**:

  ```typescript
  interface HybridType {
    (param: type): returnType
    property: type
  }
  ```

- **Example**:

  ```typescript
  interface Counter {
    (start: number): string
    increment(): number
    reset(): void
    value: number
  }

  function createCounter(): Counter {
    let counter = <Counter>function (start: number) {
      counter.value = start
      return `Counter started at ${start}`
    }
    counter.value = 0
    counter.increment = function () {
      return ++counter.value
    }
    counter.reset = function () {
      counter.value = 0
    }
    return counter
  }

  const myCounter = createCounter()
  console.log(myCounter(5)) // Outputs: Counter started at 5
  console.log(myCounter.increment()) // Outputs: 6
  myCounter.reset()
  console.log(myCounter.value) // Outputs: 0
  ```

### **Examples of Hybrid Types**

- **Event Handlers**:

  ```typescript
  interface EventHandler {
    (event: Event): void
    type: string
  }

  const clickHandler: EventHandler = (event: Event) => {
    console.log('Button clicked.')
  }
  clickHandler.type = 'click'
  ```

---

## **Best Practices**

- **Use Interfaces for Object Shapes**:

  - Prefer interfaces when defining the structure of objects.

- **Extend Interfaces Instead of Creating New Ones**:

  - Use inheritance to build upon existing interfaces.

- **Use Type Aliases for Unions and Intersections**:

  - Leverage type aliases when defining complex types that combine multiple types.

- **Avoid Excessive Use of Type Aliases for Objects**:

  - Interfaces are generally better suited for object shapes, especially when extending.

- **Consistent Naming Conventions**:

  - Use PascalCase for interface and type alias names.

- **Leverage Optional and Readonly Modifiers**:

  - Use `?` for optional properties and `readonly` for immutable properties.

---

## **Common Interview Questions**

1. **What is the purpose of interfaces in TypeScript, and how do they differ from type aliases?**

   **Answer**:

   - **Interfaces**:

     - Define contracts for objects, functions, and classes.
     - Describe the structure and types of object properties.
     - Can be extended and implemented.
     - Support declaration merging.

   - **Type Aliases**:

     - Create new names for existing types.
     - Can define primitives, unions, intersections, and other types.
     - Cannot be reopened to add new properties.
     - Cannot be implemented or extended in the same way as interfaces.

2. **How do you define optional and readonly properties in an interface?**

   **Answer**:

   - **Optional Properties**:

     - Use the `?` symbol after the property name.

     ```typescript
     interface User {
       id: number
       name?: string // Optional property
     }
     ```

   - **Readonly Properties**:

     - Use the `readonly` modifier before the property name.

     ```typescript
     interface Point {
       readonly x: number
       readonly y: number
     }
     ```

3. **Can interfaces extend multiple interfaces in TypeScript? Provide an example.**

   **Answer**:

   - Yes, interfaces can extend multiple interfaces.

   - **Example**:

     ```typescript
     interface A {
       propertyA: string
     }

     interface B {
       propertyB: number
     }

     interface C extends A, B {
       propertyC: boolean
     }

     const obj: C = {
       propertyA: 'Hello',
       propertyB: 42,
       propertyC: true,
     }
     ```

4. **When should you use a type alias over an interface in TypeScript?**

   **Answer**:

   - Use type aliases when:

     - Defining primitives, unions, intersections, or tuples.
     - You need flexibility in type definitions.
     - You are working with complex types that interfaces cannot represent.

   - Use interfaces when:

     - Defining object shapes.
     - You need to extend or implement types.
     - You want to take advantage of declaration merging.

5. **How can interfaces be used to enforce class contracts in TypeScript?**

   **Answer**:

   - Classes can implement interfaces to ensure they provide specific methods and properties.

   - The `implements` keyword is used to indicate that a class adheres to an interface.

   - **Example**:

     ```typescript
     interface Logger {
       log(message: string): void
     }

     class ConsoleLogger implements Logger {
       log(message: string): void {
         console.log(message)
       }
     }
     ```

---

## **Exercises**

### **Exercise 1: Defining an Interface**

**Question**:

Define an interface `Rectangle` that has properties `width` and `height` (both numbers). Create a function `calculateArea` that accepts a `Rectangle` and returns its area.

**Answer**:

```typescript
interface Rectangle {
  width: number
  height: number
}

function calculateArea(rect: Rectangle): number {
  return rect.width * rect.height
}

// Usage
const myRect: Rectangle = { width: 5, height: 10 }
console.log(calculateArea(myRect)) // Outputs: 50
```

---

### **Exercise 2: Extending Interfaces**

**Question**:

Create an interface `Person` with properties `name` (string) and `age` (number). Extend `Person` to create an interface `Employee` that adds a property `employeeId` (number). Create an object of type `Employee`.

**Answer**:

```typescript
interface Person {
  name: string
  age: number
}

interface Employee extends Person {
  employeeId: number
}

const employee: Employee = {
  name: 'Alice',
  age: 30,
  employeeId: 1234,
}
```

---

### **Exercise 3: Function Types in Interfaces**

**Question**:

Define an interface `StringManipulator` that describes a function taking a string and returning a string. Implement a function `reverseString` that matches this interface.

**Answer**:

```typescript
interface StringManipulator {
  (input: string): string
}

const reverseString: StringManipulator = (input: string): string => {
  return input.split('').reverse().join('')
}

// Usage
console.log(reverseString('hello')) // Outputs: olleh
```

---

### **Exercise 4: Using Type Aliases**

**Question**:

Create a type alias `Primitive` that can be either `string`, `number`, or `boolean`. Write a function `logValue` that accepts a parameter of type `Primitive` and logs its value.

**Answer**:

```typescript
type Primitive = string | number | boolean

function logValue(value: Primitive): void {
  console.log(value)
}

// Usage
logValue('Hello')
logValue(42)
logValue(true)
```

---

### **Exercise 5: Implementing Interfaces in Classes**

**Question**:

Define an interface `Clock` with a method `tick()` that returns `void`. Create a class `DigitalClock` that implements `Clock` and logs "beep beep" when `tick()` is called.

**Answer**:

```typescript
interface Clock {
  tick(): void
}

class DigitalClock implements Clock {
  tick(): void {
    console.log('beep beep')
  }
}

// Usage
const clock = new DigitalClock()
clock.tick() // Outputs: beep beep
```

---

## **Conclusion**

Interfaces and type aliases are powerful tools in TypeScript that enhance code organization, readability, and type safety. By defining object shapes with interfaces and extending them, you can create complex and reusable types that enforce consistent structures across your codebase. Type aliases offer flexibility in defining custom types, including unions and intersections. Mastery of interfaces and type aliases empowers you to write robust, maintainable, and scalable TypeScript applications, preparing you for advanced development challenges and technical interviews.

---

## **Next Steps**

- **Practice**:

  - Implement interfaces and type aliases in your projects.
  - Experiment with extending interfaces and creating complex types.

- **Explore**:

  - Learn about advanced type features like mapped types and conditional types.
  - Study how interfaces and type aliases interact with generics.

- **Prepare**:

  - Review additional interview questions on TypeScript interfaces and type system.
  - Build projects using interfaces and type aliases to reinforce your understanding.

---

**Continue enhancing your TypeScript expertise by mastering interfaces and type aliases!**

---

## **Appendix**

### **Glossary**

- **Interface**: A TypeScript structure that defines a contract for objects, functions, or classes, specifying properties and methods.
- **Type Alias**: A way to create a new name for a type, which can be a primitive, union, intersection, tuple, or any other type.
- **Optional Property**: A property in an interface that may or may not be present, denoted by a `?`.
- **Readonly Property**: A property that cannot be reassigned after initialization, marked with the `readonly` modifier.
- **Union Type**: A type that represents a value that can be one of several types, using the `|` operator.
- **Intersection Type**: A type that combines multiple types into one, using the `&` operator.
- **Index Signature**: A way to define types for properties accessed via dynamic keys, using `[key: type]: valueType`.
- **Hybrid Type**: A type that combines properties of multiple types, such as an object that is also callable like a function.
- **Declaration Merging**: A feature where multiple declarations with the same name are merged into a single definition.

---

**End of Lesson**
