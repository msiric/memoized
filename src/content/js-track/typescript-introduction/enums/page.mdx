export const metadata = {   title: "Enums and Literal Types in TypeScript",   description: "Enhance your TypeScript proficiency by mastering enums and literal types. This lesson focuses on understanding numeric and string enums, their usage, and benefits. Additionally, explore literal type constraints to define exact values a variable can hold, enabling you to create more precise and type-safe code. By learning about enums and literal types, you will gain the ability to write more expressive and robust TypeScript applications. This comprehensive lesson will deepen your understanding of TypeScript's type system and prepare you for technical interviews by covering these essential topics.", }

# **Enums and Literal Types in TypeScript**

Enums (short for enumerations) and literal types are powerful features in TypeScript that allow developers to define a set of named constants and restrict variables to specific values. Enums help in creating a collection of related values that can be numeric or string-based, improving code readability and maintainability. Literal types enable you to specify exact values for variables, enhancing type safety. This lesson delves into how to use enums and literal types effectively in TypeScript.



## **Introduction to Enums**

### **What are Enums?**

- **Definition**: Enums are a way to define a set of named constants, which can be either numeric or string values.
- **Purpose**:
  - Provide meaningful names to numeric or string values.
  - Enhance code readability and maintainability.
  - Group related constants together.

### **Benefits of Using Enums**

- **Type Safety**: Enums are types in TypeScript, allowing for compile-time checks.
- **IntelliSense Support**: Enums provide better tooling support, including autocompletion.
- **Self-Documenting Code**: Using enums makes code more understandable by replacing magic numbers or strings with meaningful names.
- **Preventing Invalid Values**: Enums restrict values to a predefined set.

## **Numeric Enums**

Numeric enums are the default in TypeScript and assign numeric values to enum members.

### **Defining Numeric Enums**

- **Syntax**:

  ```typescript
  enum EnumName {
    Member1,
    Member2,
    Member3,
    // ...
  }
  ```

- **Example**:

  ```typescript
  enum Direction {
    North,
    East,
    South,
    West,
  }
  ```

### **Auto-incrementing Behavior**

- **Default Values**:

  - The first member defaults to `0`.
  - Subsequent members auto-increment by `1`.

- **Example**:

  ```typescript
  enum Direction {
    North, // 0
    East, // 1
    South, // 2
    West, // 3
  }

  let dir: Direction = Direction.North
  console.log(dir) // Outputs: 0
  ```

### **Customizing Enum Values**

- **Assigning Specific Values**:

  ```typescript
  enum Status {
    Success = 200,
    NotFound = 404,
    ServerError = 500,
  }
  ```

- **Auto-increment from Custom Value**:

  - If you assign a value to the first member, the subsequent members increment from that value.

  ```typescript
  enum Status {
    Success = 200,
    NotFound, // 201
    ServerError, // 202
  }
  ```

- **Assigning Values to All Members**:

  - You can assign specific values to each member.

  ```typescript
  enum Status {
    Success = 200,
    NotFound = 404,
    ServerError = 500,
  }
  ```

## **String Enums**

String enums are enums where each member is initialized with a string literal.

### **Defining String Enums**

- **Syntax**:

  ```typescript
  enum EnumName {
    Member1 = 'value1',
    Member2 = 'value2',
    // ...
  }
  ```

- **Example**:

  ```typescript
  enum Direction {
    North = 'NORTH',
    East = 'EAST',
    South = 'SOUTH',
    West = 'WEST',
  }

  let dir: Direction = Direction.North
  console.log(dir) // Outputs: 'NORTH'
  ```

### **Differences from Numeric Enums**

- **No Auto-incrementing**: Each member must be initialized with a string value.
- **No Reverse Mapping**: String enums do not have reverse mapping at runtime.
- **Useful for Serialization**: String values are more readable and useful when serializing data.

## **Heterogeneous Enums**

Enums that mix numeric and string members.

### **Mixing Numeric and String Values**

- **Syntax**:

  ```typescript
  enum MixedEnum {
    No = 0,
    Yes = 'YES',
  }
  ```

### **Use Cases and Considerations**

- **Use Cases**:

  - Rare and generally discouraged.
  - May be used when integrating with external libraries or APIs.

- **Considerations**:
  - Can lead to confusion and should be used sparingly.
  - Stick to either numeric or string enums for consistency.

## **Enum Members**

Enum members can be constant or computed.

### **Constant vs. Computed Members**

- **Constant Members**:

  - Simple expressions that can be evaluated at compile time.
  - Examples: Numeric literals, other enum members, mathematical operations.

- **Computed Members**:

  - Evaluated at runtime.
  - Must come after constant members.

- **Example**:

  ```typescript
  enum FileAccess {
    None, // 0
    Read = 1 << 1, // 2
    Write = 1 << 2, // 4
    ReadWrite = Read | Write, // 6
    G = '123'.length, // Computed member, value is 3
  }
  ```

### **Enum Member Types**

- **Numeric Enums**: Can have constant or computed members.
- **String Enums**: Members must have constant string values.

## **Enums at Runtime**

Enums are objects that exist at runtime.

### **Reverse Mapping**

- **Numeric Enums Support Reverse Mapping**:

  ```typescript
  enum Direction {
    North,
    East,
    South,
    West,
  }

  console.log(Direction[0]) // Outputs: 'North'
  console.log(Direction['North']) // Outputs: 0
  ```

- **String Enums Do Not Support Reverse Mapping**:

  ```typescript
  enum Direction {
    North = 'NORTH',
    East = 'EAST',
  }

  // Direction['NORTH'] is undefined
  ```

### **Using Enums in Code**

- **Comparisons**:

  ```typescript
  enum Status {
    Active,
    Inactive,
    Pending,
  }

  let currentStatus: Status = Status.Active

  if (currentStatus === Status.Active) {
    console.log('Status is active.')
  }
  ```

- **Functions with Enums**:

  ```typescript
  function respond(status: Status): void {
    // ...
  }

  respond(Status.Pending)
  ```

## **Literal Types**

Literal types allow you to specify exact values a variable can hold.

### **String Literal Types**

- **Definition**: Type of a variable must be a specific string value.

- **Syntax**:

  ```typescript
  let variableName: 'value1' | 'value2' | 'value3'
  ```

- **Example**:

  ```typescript
  type Direction = 'North' | 'East' | 'South' | 'West'

  let move: Direction

  move = 'North' // Valid
  move = 'Up' // Error: Type '"Up"' is not assignable to type 'Direction'.
  ```

### **Numeric Literal Types**

- **Definition**: Type of a variable must be a specific numeric value.

- **Example**:

  ```typescript
  type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6

  function rollDice(): DiceRoll {
    return (Math.floor(Math.random() * 6) + 1) as DiceRoll
  }
  ```

### **Boolean Literal Types**

- **Definition**: Type is either `true` or `false`.

- **Example**:

  ```typescript
  type Yes = true
  type No = false

  let answer: Yes | No

  answer = true // Valid
  answer = false // Valid
  answer = 'yes' // Error
  ```

## **Type Aliases with Literal Types**

Type aliases can be used to create custom types from literal types.

### **Union of Literal Types**

- **Example**:

  ```typescript
  type CardinalDirection = 'North' | 'East' | 'South' | 'West'

  function move(direction: CardinalDirection): void {
    // Implementation
  }

  move('North') // Valid
  move('Up') // Error
  ```

### **Creating Custom Types**

- **Example with Status Codes**:

  ```typescript
  type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'

  function request(url: string, method: HTTPMethod): void {
    // Implementation
  }

  request('/api/users', 'GET') // Valid
  request('/api/users', 'PATCH') // Error
  ```

## **Discriminated Unions**

Combining enums or literal types with type aliases to create flexible and type-safe code.

### **Combining Enums and Literal Types**

- **Example**:

  ```typescript
  interface Circle {
    kind: 'circle'
    radius: number
  }

  interface Rectangle {
    kind: 'rectangle'
    width: number
    height: number
  }

  type Shape = Circle | Rectangle

  function area(shape: Shape): number {
    if (shape.kind === 'circle') {
      return Math.PI * shape.radius ** 2
    } else if (shape.kind === 'rectangle') {
      return shape.width * shape.height
    } else {
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck // Error if a new shape is added and not handled
    }
  }
  ```

### **Pattern Matching with Type Guards**

- **Using `switch` Statements**:

  ```typescript
  function area(shape: Shape): number {
    switch (shape.kind) {
      case 'circle':
        return Math.PI * shape.radius ** 2
      case 'rectangle':
        return shape.width * shape.height
      default:
        const _exhaustiveCheck: never = shape
        return _exhaustiveCheck
    }
  }
  ```

- **Benefits**:
  - Compiler ensures all cases are handled.
  - If a new type is added to `Shape`, TypeScript will error if it's not handled.

## **Best Practices**

- **Use Enums for Related Constants**:

  - Group related constants for better organization.

- **Prefer String Enums When Readability Matters**:

  - String enums are more readable when logging or serializing.

- **Use Literal Types for Specific Values**:

  - Enforce that variables can only hold certain values.

- **Combine Enums and Literal Types with Type Aliases**:

  - Create flexible and expressive types.

- **Use Discriminated Unions for Complex Types**:

  - Ensure exhaustive checks and type safety.

- **Avoid Heterogeneous Enums**:

  - Stick to either numeric or string enums for consistency.

- **Be Mindful of Enum Values**:
  - Explicitly assign values if necessary to prevent unintended increments.

## **Exercises**

### **Exercise 1: Defining Numeric Enums**

**Question**:

Define a numeric enum `LogLevel` with the following members: `Error`, `Warn`, `Info`, `Debug`. Assign explicit values starting from `1` for `Error` and incrementing by `1` for each level.

**Answer**:

```typescript
enum LogLevel {
  Error = 1,
  Warn, // 2
  Info, // 3
  Debug, // 4
}

// Usage
let level: LogLevel = LogLevel.Warn
console.log(level) // Outputs: 2
```

### **Exercise 2: Defining String Enums**

**Question**:

Create a string enum `ResponseStatus` with the members `Success`, `Failure`, and `Pending`, assigned to the string values `'SUCCESS'`, `'FAILURE'`, and `'PENDING'` respectively.

**Answer**:

```typescript
enum ResponseStatus {
  Success = 'SUCCESS',
  Failure = 'FAILURE',
  Pending = 'PENDING',
}

// Usage
let status: ResponseStatus = ResponseStatus.Success
console.log(status) // Outputs: 'SUCCESS'
```

### **Exercise 3: Using Literal Types**

**Question**:

Define a type alias `HTTPMethod` that can be one of the strings `'GET'`, `'POST'`, `'PUT'`, or `'DELETE'`. Write a function `sendRequest` that accepts a URL and an HTTP method of type `HTTPMethod`.

**Answer**:

```typescript
type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'DELETE'

function sendRequest(url: string, method: HTTPMethod): void {
  console.log(`Sending ${method} request to ${url}`)
}

// Usage
sendRequest('/api/data', 'GET') // Valid
// sendRequest('/api/data', 'PATCH'); // Error
```

### **Exercise 4: Discriminated Unions**

**Question**:

Create interfaces `Square` and `Circle`, each with a `kind` property (literal type) and properties specific to their shape (`sideLength` for `Square`, `radius` for `Circle`). Define a type `Shape` as a union of `Square` and `Circle`. Write a function `calculateArea` that computes the area based on the shape type.

**Answer**:

```typescript
interface Square {
  kind: 'square'
  sideLength: number
}

interface Circle {
  kind: 'circle'
  radius: number
}

type Shape = Square | Circle

function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case 'square':
      return shape.sideLength ** 2
    case 'circle':
      return Math.PI * shape.radius ** 2
    default:
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck
  }
}

// Usage
const mySquare: Square = { kind: 'square', sideLength: 5 }
const myCircle: Circle = { kind: 'circle', radius: 3 }

console.log(calculateArea(mySquare)) // Outputs: 25
console.log(calculateArea(myCircle)) // Outputs: Approx. 28.27
```

### **Exercise 5: Enum Reverse Mapping**

**Question**:

Given the numeric enum `Color` below, demonstrate how to perform reverse mapping to get the name of a color when given its numeric value.

```typescript
enum Color {
  Red = 1,
  Green,
  Blue,
}
```

**Answer**:

```typescript
// Usage
let colorName: string = Color[2]
console.log(colorName) // Outputs: 'Green'

let colorValue: Color = Color.Blue
console.log(colorValue) // Outputs: 3
```


Enums and literal types are powerful features in TypeScript that enhance code expressiveness and type safety. Enums provide a way to define a set of named constants, improving code readability and maintainability. Literal types allow developers to specify exact values a variable can hold, enabling the creation of precise and flexible types. By mastering enums and literal types, you can write more robust, type-safe, and expressive TypeScript applications, preparing you for advanced development tasks and technical interviews.



