export const metadata = {
  title: 'Comprehensive Guide to Recursion and Memoization in JavaScript',
  description: 'Use recursive techniques and optimize with memoization. Understand recursion and memoization, performance considerations, and practical examples.',
}

# **Recursion and Memoization**

Recursion is a technique where a function calls itself to solve a problem. Memoization is an optimization technique used to speed up recursive algorithms by storing the results of expensive function calls and reusing them when the same inputs occur again.

## **Concept and Use Cases**

**Definition:**
- **Recursion:** A process in which a function calls itself as a subroutine.
- **Memoization:** An optimization technique that involves storing the results of expensive function calls and returning the cached result when the same inputs occur again.

**Common Use Cases:**
- Solving problems with a natural recursive structure (e.g., tree traversals, factorial calculation).
- Dynamic programming problems (e.g., Fibonacci sequence, knapsack problem).
- Divide and conquer algorithms (e.g., merge sort, quick sort).

## **Key Concepts**

1. **Base Case:**
   - The condition under which the recursion stops.
   
2. **Recursive Case:**
   - The part of the function where the function calls itself with modified arguments.

3. **Memoization Table:**
   - A data structure (usually a dictionary or array) used to store the results of expensive function calls.

## **Time and Space Complexity**

**Time Complexity:**
- Recursion: Varies based on the problem; can be exponential without memoization.
- Memoization: Reduces the time complexity to polynomial time for many problems.

**Space Complexity:**
- Recursion: O(n) due to the call stack.
- Memoization: O(n) additional space for the memoization table.

## **Recursion and Memoization Techniques and Methods**

### **Recursive Fibonacci Sequence**

**Problem:**
Calculate the n-th Fibonacci number.

**Example:**
```javascript
function fib(n) {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
}

// Example usage:
console.log(fib(10));  // Output: 55
```

### **Memoized Fibonacci Sequence**

**Example:**
```javascript
function fibMemo(n, memo = {}) {
    if (n <= 1) return n;
    if (memo[n]) return memo[n];
    memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);
    return memo[n];
}

// Example usage:
console.log(fibMemo(10));  // Output: 55
```

### **Factorial Calculation**

**Problem:**
Calculate the factorial of a number n.

**Example:**
```javascript
function factorial(n) {
    if (n === 0) return 1;
    return n * factorial(n - 1);
}

// Example usage:
console.log(factorial(5));  // Output: 120
```

### **Memoized Factorial Calculation**

**Example:**
```javascript
function factorialMemo(n, memo = {}) {
    if (n === 0) return 1;
    if (memo[n]) return memo[n];
    memo[n] = n * factorialMemo(n - 1, memo);
    return memo[n];
}

// Example usage:
console.log(factorialMemo(5));  // Output: 120
```

### **Longest Common Subsequence**

**Problem:**
Find the length of the longest common subsequence between two strings.

**Example:**
```javascript
function lcs(x, y, m, n) {
    if (m === 0 || n === 0) return 0;
    if (x[m - 1] === y[n - 1]) return 1 + lcs(x, y, m - 1, n - 1);
    return Math.max(lcs(x, y, m, n - 1), lcs(x, y, m - 1, n));
}

// Example usage:
const x = 'AGGTAB';
const y = 'GXTXAYB';
console.log(lcs(x, y, x.length, y.length));  // Output: 4
```

### **Memoized Longest Common Subsequence**

**Example:**
```javascript
function lcsMemo(x, y, m, n, memo = {}) {
    const key = `${m},${n}`;
    if (memo[key]) return memo[key];
    if (m === 0 || n === 0) return 0;
    if (x[m - 1] === y[n - 1]) {
        memo[key] = 1 + lcsMemo(x, y, m - 1, n - 1, memo);
    } else {
        memo[key] = Math.max(lcsMemo(x, y, m, n - 1, memo), lcsMemo(x, y, m - 1, n, memo));
    }
    return memo[key];
}

// Example usage:
const x = 'AGGTAB';
const y = 'GXTXAYB';
console.log(lcsMemo(x, y, x.length, y.length));  // Output: 4
```

### **Knapsack Problem**

**Problem:**
Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.

**Example:**
```javascript
function knapsack(W, weights, values, n) {
    if (n === 0 || W === 0) return 0;
    if (weights[n - 1] > W) return knapsack(W, weights, values, n - 1);
    return Math.max(
        values[n - 1] + knapsack(W - weights[n - 1], weights, values, n - 1),
        knapsack(W, weights, values, n - 1)
    );
}

// Example usage:
const values = [60, 100, 120];
const weights = [10, 20, 30];
const W = 50;
const n = values.length;
console.log(knapsack(W, weights, values, n));  // Output: 220
```

### **Memoized Knapsack Problem**

**Example:**
```javascript
function knapsackMemo(W, weights, values, n, memo = {}) {
    const key = `${n},${W}`;
    if (memo[key]) return memo[key];
    if (n === 0 || W === 0) return 0;
    if (weights[n - 1] > W) {
        memo[key] = knapsackMemo(W, weights, values, n - 1, memo);
    } else {
        memo[key] = Math.max(
            values[n - 1] + knapsackMemo(W - weights[n - 1], weights, values, n - 1, memo),
            knapsackMemo(W, weights, values, n - 1, memo)
        );
    }
    return memo[key];
}

// Example usage:
const values = [60, 100, 120];
const weights = [10, 20, 30];
const W = 50;
const n = values.length;
console.log(knapsackMemo(W, weights, values, n));  // Output: 220
```

## **Practical Tips and Tricks**

- **Identify Overlapping Subproblems:**
  Recognize problems where overlapping subproblems occur to apply memoization effectively.
  
- **Use a Memoization Table:**
  Store the results of subproblems in a dictionary or array to avoid redundant calculations.

- **Recursive Base Case:**
  Ensure the base case is correctly defined to terminate the recursion.

- **Avoid Global Variables:**
  Pass the memoization table as an argument to avoid issues with global state.

## **Common Gotchas**

- **Stack Overflow:**
  Deep recursion can lead to stack overflow errors. Optimize using memoization or iterative solutions.

- **Memory Consumption:**
  Memoization can consume significant memory for large inputs. Use space efficiently.

- **Incorrect Memoization:**
  Ensure the memoization key is correctly defined to avoid incorrect results.

## **Advanced Topics**

### **Top-Down vs Bottom-Up Dynamic Programming**

**Top-Down (Memoization):**
- Solve the problem by breaking it down into subproblems and storing their results.
- Example: Recursive Fibonacci with memoization.

**Bottom-Up (Tabulation):**
- Solve the problem iteratively by building up the solution from the base cases.
- Example: Iterative Fibonacci.

**Example: Bottom-Up Fibonacci**

```javascript
function fibBottomUp(n) {
    if (n <= 1) return n;
    const dp = [0, 1];
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

// Example usage:
console.log(fibBottomUp(10));  // Output: 55
```

### **Tail Recursion**

**Description:**
A recursive function is tail-recursive if the recursive call is the last operation in the function. Tail recursion can be optimized by some compilers to avoid stack overflow.

**Example:**
```javascript
function tailRecFactorial(n, acc = 1) {
    if (n === 0) return acc;
    return tailRecFactorial(n - 1, n * acc);
}

// Example usage:
console.log(tailRecFactorial(5));  // Output: 120
```

## **Interview Tips and Tricks**

- **Explain Base and Recursive Cases:**
  Clearly explain the base and recursive cases in your recursive function.

- **Use Memoization:**
  Optimize recursive solutions with memoization to improve performance.

- **Iterative Solutions:**
  Discuss iterative alternatives for deep recursion to avoid stack overflow.

- **Space Complexity:**
  Be aware of the space complexity of recursive and memoized solutions, especially for large inputs.

## **Common Mistakes**

- **Incorrect Base Case:**
  Ensure the base case is correctly defined to terminate the recursion properly.

- **Missing Memoization:**
  Forgetting to use memoization can lead to redundant calculations and poor performance.

- **Global State:**
  Avoid using global variables for memoization to prevent unexpected results.

By mastering Recursion and Memoization and understanding their intricacies, you will be well-equipped to handle a variety of problems with efficient and elegant solutions. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.

## **Practice Problems**

1. [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
2. [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)
3. [Coin Change](https://leetcode.com/problems/coin-change/)
4. [Target Sum](https://leetcode.com/problems/target-sum/)
5. [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)