export const metadata = {
  title: 'Comprehensive Guide to Binary Search in JavaScript',
  description: 'Efficiently search sorted arrays. Understand binary search, performance considerations, and practical examples.',
}

# **Modified Binary Search**

Before diving into modified versions, it's essential to understand the conventional binary search algorithm. Binary search is an efficient algorithm for finding an item from a sorted list of items by repeatedly dividing the search interval in half.

## **Conventional Binary Search**

**Problem:** Given a sorted array of integers, find the index of a target value. If the target is not found, return -1.

**Step-by-Step Solution:**
1. Initialize two pointers, `left` and `right`, to the beginning and end of the array, respectively.
2. Calculate the middle index `mid`.
3. Compare the target value with the element at the middle index:
   - If the target is equal to the middle element, return the middle index.
   - If the target is less than the middle element, adjust the `right` pointer to `mid - 1`.
   - If the target is greater than the middle element, adjust the `left` pointer to `mid + 1`.
4. Repeat steps 2-3 until the target is found or the search interval is empty.

**Code Example:**
```javascript
function binarySearch(nums, target) {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;  // Target not found
}

// Example usage:
const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const target = 7;
console.log(binarySearch(nums, target));  // Output: 6
```

**Tips and Tricks:**
- Ensure the array is sorted before performing binary search.
- Use integer division to calculate the middle index to avoid decimal values.
- Adjust the `left` and `right` pointers based on the comparison results.

**Frequent Gotchas:**
- Forgetting to adjust the pointers correctly, leading to infinite loops.
- Misinterpreting the middle index calculation, resulting in incorrect comparisons.
- Not handling edge cases where the target is at the beginning or end of the array.

## **Modified Binary Search**

Now that we've covered the basics of binary search, let's move on to some common modifications.

## **Finding the First and Last Occurrence of an Element**

**Problem:** Given a sorted array, find the first and last position of a target element. If the target is not found, return [-1, -1].

**Step-by-Step Solution:**
1. Perform a modified binary search to find the first occurrence of the target.
2. Perform a modified binary search to find the last occurrence of the target.
3. Return the positions of the first and last occurrences.

**Code Example:**
```javascript
function searchRange(nums, target) {
    const result = [-1, -1];

    result[0] = findBound(nums, target, true);
    if (result[0] !== -1) {
        result[1] = findBound(nums, target, false);
    }

    return result;
}

function findBound(nums, target, isFirst) {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            if (isFirst) {
                if (mid === left || nums[mid - 1] !== target) {
                    return mid;
                }
                right = mid - 1;
            } else {
                if (mid === right || nums[mid + 1] !== target) {
                    return mid;
                }
                left = mid + 1;
            }
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }

    return -1;
}

// Example usage:
const nums = [5, 7, 7, 8, 8, 10];
const target = 8;
console.log(searchRange(nums, target));  // Output: [3, 4]
```

**Tips and Tricks:**
- Use two separate searches to find the first and last occurrences of the target.
- Adjust the search range based on whether you're looking for the first or last occurrence.
- Check boundary conditions to ensure correct identification of the target's position.

**Frequent Gotchas:**
- Forgetting to check if the target is found before performing the second search.
- Incorrectly updating the search range, leading to infinite loops or incorrect results.
- Handling edge cases where the target is at the beginning or end of the array.

## **Searching in a Rotated Sorted Array**

**Problem:** Given a rotated sorted array, find the index of a target element. If the target is not found, return -1.

**Step-by-Step Solution:**
1. Perform a modified binary search to identify the pivot point where the rotation occurs.
2. Use the pivot to determine which part of the array to search for the target.
3. Perform a standard binary search in the identified part of the array.

**Code Example:**
```javascript
function search(nums, target) {
    let left = 0, right = nums.length - 1;

    while (left <= right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] === target) {
            return mid;
        }

        if (nums[left] <= nums[mid]) {  // Left half is sorted
            if (nums[left] <= target && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {  // Right half is sorted
            if (nums[mid] < target && target <= nums[right]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }

    return -1;
}

// Example usage:
const nums = [4, 5, 6, 7, 0, 1, 2];
const target = 0;
console.log(search(nums, target));  // Output: 4
```

**Tips and Tricks:**
- Identify which part of the array is sorted and adjust the search range accordingly.
- Use boundary conditions to determine which half of the array to search.
- Perform a standard binary search once the correct part of the array is identified.

**Frequent Gotchas:**
- Misidentifying the sorted half of the array, leading to incorrect search ranges.
- Not handling edge cases where the target is at the pivot point.
- Incorrectly updating the search range, leading to infinite loops or incorrect results.

## **Finding the Peak Element in an Array**

**Problem:** Given an array, find a peak element. A peak element is an element that is greater than its neighbors. Return the index of the peak element. The array may contain multiple peaks, in which case return the index of any one of the peaks.

**Step-by-Step Solution:**
1. Perform a modified binary search to identify the peak element.
2. Compare the middle element with its neighbors to determine the search direction.
3. Continue the search until a peak element is found.

**Code Example:**
```javascript
function findPeakElement(nums) {
    let left = 0, right = nums.length - 1;

    while (left < right) {
        const mid = Math.floor((left + right) / 2);

        if (nums[mid] > nums[mid + 1]) {
            right = mid;
        } else {
            left = mid + 1;
        }
    }

    return left;
}

// Example usage:
const nums = [1, 2, 3, 1];
console.log(findPeakElement(nums));  // Output: 2
```

**Tips and Tricks:**
- Use binary search to divide the array and compare the middle element with its neighbors.
- Adjust the search range based on the comparison results to find a peak element.
- Ensure the search continues until a peak element is identified.

**Frequent Gotchas:**
- Forgetting to compare the middle element with its neighbors correctly.
- Misidentifying the search range, leading to incorrect results.
- Handling edge cases where the peak is at the beginning or end of the array.

By mastering both the conventional and modified binary search techniques, you can efficiently solve a variety of problems involving searching in sorted arrays, finding specific positions or conditions, and handling complex search scenarios. This technique is essential for optimizing time complexity and handling binary search-related problems effectively in both technical interviews and real-world applications.

## **Practice Problems**

1. [Binary Search](https://leetcode.com/problems/binary-search/)
2. [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
3. [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
4. [Find Peak Element](https://leetcode.com/problems/find-peak-element/)
5. [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)