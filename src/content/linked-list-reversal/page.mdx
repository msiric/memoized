export const metadata = {
  title: 'Comprehensive Guide to Linked List Reversal in JavaScript',
  description: 'Reverse linked lists in-place. Understand linked list reversal, performance considerations, and practical examples.',
}

# **In-Place Reversal of a Linked List**

The In-Place Reversal of a Linked List pattern is a powerful technique used to reverse the links between a set of nodes in a linked list. This pattern is often used in problems where the reversal of nodes is required without using extra memory, ensuring the operation is performed in place.

## **Concept and Use Cases**

**Definition:**
In-place reversal of a linked list involves reversing the links between nodes directly in the existing linked list structure, without using additional data structures or memory.

**Common Use Cases:**
- Reversing the entire linked list.
- Reversing a specific part of the linked list.
- Reversing nodes in k-sized groups.

## **When to Use**
- When you need to reverse the nodes of a linked list in place.
- When the problem constraints require the reversal to be done without extra memory.
- When reversing specific sections or groups of nodes within a linked list.

## **Time and Space Complexity**

**Time Complexity:** 
- O(n), where n is the number of nodes in the linked list. Each node is visited once.

**Space Complexity:**
- O(1), as the reversal is done in place without using additional data structures.

## **Reversing the Entire Linked List**

**Problem:** Given the head of a singly linked list, reverse the list and return its new head.

**Step-by-Step Solution:**
1. Initialize three pointers: `previous`, `current`, and `next`.
2. Iterate through the linked list.
3. For each node, store the next node, reverse the link, and move the pointers one step forward.
4. Continue until all nodes are reversed.

**Code Example:**
```javascript
class ListNode {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

function reverseLinkedList(head) {
    let previous = null;
    let current = head;

    while (current !== null) {
        const next = current.next;  // Store the next node
        current.next = previous;    // Reverse the link
        previous = current;         // Move previous to the current node
        current = next;             // Move current to the next node
    }

    return previous;  // New head of the reversed list
}

// Example usage:
const head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
head.next.next.next = new ListNode(4);
head.next.next.next.next = new ListNode(5);

const reversedHead = reverseLinkedList(head);
let current = reversedHead;
while (current !== null) {
    console.log(current.value);  // Output: 5 4 3 2 1
    current = current.next;
}
```

**Tips and Tricks:**
- Initialize the `previous` pointer to null to mark the end of the reversed list.
- Update the `next` pointer before reversing the link to avoid losing the reference to the next node.
- Move the `previous` and `current` pointers forward simultaneously to maintain the reversal process.

**Frequent Gotchas:**
- Forgetting to update the `next` pointer before reversing the link, leading to lost references.
- Not initializing the `previous` pointer correctly, resulting in incorrect reversal.
- Handling edge cases, such as an empty list or a list with a single node.

## **Reversing a Part of the Linked List**

**Problem:** Given the head of a linked list and two positions `m` and `n`, reverse the nodes of the list from position `m` to `n`.

**Step-by-Step Solution:**
1. Traverse the list to find the node at position `m-1`.
2. Reverse the nodes from `m` to `n` using the in-place reversal technique.
3. Reconnect the reversed sublist with the rest of the list.

**Code Example:**
```javascript
function reverseBetween(head, m, n) {
    if (m === n) return head;

    let current = head, previous = null;
    for (let i = 1; i < m; i++) {
        previous = current;
        current = current.next;
    }

    const connection = previous;
    const tail = current;

    let next = null;
    for (let i = 0; i < n - m + 1; i++) {
        next = current.next;
        current.next = previous;
        previous = current;
        current = next;
    }

    if (connection !== null) {
        connection.next = previous;
    } else {
        head = previous;
    }

    tail.next = current;

    return head;
}

// Example usage:
const head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
head.next.next.next = new ListNode(4);
head.next.next.next.next = new ListNode(5);

const m = 2, n = 4;
const newHead = reverseBetween(head, m, n);
let current = newHead;
while (current !== null) {
    console.log(current.value);  // Output: 1 4 3 2 5
    current = current.next;
}
```

**Tips and Tricks:**
- Keep track of the node before the start of the sublist (`connection`) and the node at the end of the sublist (`tail`).
- Reverse the nodes in the specified range using the same in-place reversal technique.
- Reconnect the reversed sublist with the rest of the list.

**Frequent Gotchas:**
- Incorrectly updating the `connection` and `tail` pointers, leading to incorrect reconnections.
- Handling edge cases, such as `m` and `n` being the same, or reversing the entire list.
- Ensuring the reversal process is confined to the specified range without affecting other nodes.

## **Reversing Nodes in k-Sized Groups**

**Problem:** Given the head of a linked list, reverse the nodes of the list `k` at a time, and return the modified list. If the number of nodes is not a multiple of `k`, the remaining nodes should remain as they are.

**Step-by-Step Solution:**
1. Traverse the list to count the total number of nodes.
2. Reverse the nodes in groups of `k` using the in-place reversal technique.
3. Reconnect the reversed groups with the rest of the list.

**Code Example:**
```javascript
function reverseKGroup(head, k) {
    if (head === null || k === 1) return head;

    let dummy = new ListNode(0);
    dummy.next = head;
    let current = dummy, next = dummy, previous = dummy;
    let count = 0;

    while (current.next !== null) {
        current = current.next;
        count++;
    }

    while (count >= k) {
        current = previous.next;
        next = current.next;
        for (let i = 1; i < k; i++) {
            current.next = next.next;
            next.next = previous.next;
            previous.next = next;
            next = current.next;
        }
        previous = current;
        count -= k;
    }

    return dummy.next;
}

// Example usage:
const head = new ListNode(1);
head.next = new ListNode(2);
head.next.next = new ListNode(3);
head.next.next.next = new ListNode(4);
head.next.next.next.next = new ListNode(5);

const k = 3;
const newHead = reverseKGroup(head, k);
let current = newHead;
while (current !== null) {
    console.log(current.value);  // Output: 3 2 1 4 5
    current = current.next;
}
```

**Tips and Tricks:**
- Use a dummy node to simplify the reversal process and handle edge cases.
- Count the total number of nodes to ensure correct group reversal.
- Reverse the nodes in groups of `k` using the in-place reversal technique and reconnect the groups.

**Frequent Gotchas:**
- Incorrectly updating the pointers during the group reversal, leading to incorrect results.
- Handling edge cases, such as the number of nodes not being a multiple of `k`.
- Ensuring the dummy node is used correctly to simplify the reversal process.

By mastering the In-Place Reversal of a Linked List technique, you can efficiently solve a variety of problems involving reversing nodes in linked lists. This technique is essential for optimizing time complexity and handling linked list-related data structures effectively in both technical interviews and real-world applications.