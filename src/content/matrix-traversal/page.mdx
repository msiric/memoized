export const metadata = {
  title: 'Comprehensive Guide to Matrix Traversal in JavaScript',
  description: 'Navigate through matrices efficiently. Understand matrix traversal techniques, performance considerations, and practical examples.',
}

# **Matrix Traversal**

The Islands (Matrix Traversal) technique involves exploring a matrix (grid) to identify and count distinct groups or clusters of connected cells that satisfy certain criteria. The most common application is counting the number of islands in a binary matrix, where islands are groups of '1's connected horizontally, vertically, or diagonally.

## **Concept and Use Cases**

**Definition:**
An island is a group of connected '1's in a binary matrix, where connectivity can be defined as horizontal, vertical, or diagonal adjacency. Matrix traversal algorithms, such as Depth-First Search (DFS) or Breadth-First Search (BFS), are used to explore the matrix and identify distinct islands.

**Common Use Cases:**
- Counting the number of islands in a binary matrix.
- Identifying connected components in a graph represented as a matrix.
- Solving problems related to flood fill, image processing, and region marking.

## **When to Use**
- When you need to explore and identify clusters or connected components in a matrix.
- When solving problems involving region-based traversal or marking in a grid.
- When dealing with scenarios that require distinguishing between different groups of connected cells.

## **Time and Space Complexity**

**Time Complexity:**
- O(M * N), where M is the number of rows and N is the number of columns in the matrix. Each cell is visited once.

**Space Complexity:**
- O(M * N) for the recursive call stack in DFS or the queue in BFS.

## **Common Problems**

1. **Number of Islands:**
   - **Problem:** Count the number of islands in a binary matrix.
   - **Approach:** Use DFS or BFS to explore all connected components.

2. **Max Area of Island:**
   - **Problem:** Find the maximum area of an island in a binary matrix.
   - **Approach:** Use DFS or BFS to calculate the area of each island and keep track of the maximum area.

3. **Surrounded Regions:**
   - **Problem:** Capture all regions surrounded by 'X' in a 2D board, flipping 'O' to 'X'.
   - **Approach:** Use DFS or BFS to mark safe regions starting from the boundaries and then flip the remaining 'O's.

4. **Walls and Gates:**
   - **Problem:** Fill each empty room with the distance to its nearest gate in a 2D grid.
   - **Approach:** Use multi-source BFS starting from all gates simultaneously.

## **Counting Islands using DFS**

**Problem:** Given a binary matrix, count the number of islands. An island is surrounded by water (0s) and is formed by connecting adjacent lands (1s) horizontally, vertically, or diagonally.

**Step-by-Step Solution:**
1. Iterate through each cell in the matrix.
2. When a '1' is encountered, it signifies the start of a new island.
3. Use DFS to mark all connected '1's as visited (change them to '0's or use a visited set).
4. Increment the island count.
5. Continue iterating through the matrix to find all islands.

**Code Example:**
```javascript
function numIslandsDFS(grid) {
    if (grid.length === 0) return 0;

    const rows = grid.length;
    const cols = grid[0].length;
    let islandCount = 0;

    function dfs(row, col) {
        if (row < 0 || col < 0 || row >= rows || col >= cols || grid[row][col] === '0') {
            return;
        }

        // Mark the cell as visited by changing it to '0'
        grid[row][col] = '0';

        // Traverse in all 8 directions
        dfs(row + 1, col);
        dfs(row - 1, col);
        dfs(row, col + 1);
        dfs(row, col - 1);
        dfs(row + 1, col + 1);
        dfs(row - 1, col - 1);
        dfs(row + 1, col - 1);
        dfs(row - 1, col + 1);
    }

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col] === '1') {
                islandCount++;
                dfs(row, col);
            }
        }
    }

    return islandCount;
}

// Example usage:
const grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
];
console.log(numIslandsDFS(grid));  // Output: 3
```

**Tips and Tricks:**
- Use DFS to explore all connected cells of an island recursively.
- Mark cells as visited to avoid counting the same island multiple times.

**Frequent Gotchas:**
- Forgetting to mark cells as visited, leading to infinite recursion.
- Handling edge cases where the matrix is empty or contains no islands.

## **Counting Islands using BFS**

**Step-by-Step Solution:**
1. Iterate through each cell in the matrix.
2. When a '1' is encountered, it signifies the start of a new island.
3. Use BFS to mark all connected '1's as visited (change them to '0's or use a visited set).
4. Increment the island count.
5. Continue iterating through the matrix to find all islands.

**Code Example:**
```javascript
function numIslandsBFS(grid) {
    if (grid.length === 0) return 0;

    const rows = grid.length;
    const cols = grid[0].length;
    let islandCount = 0;

    function bfs(row, col) {
        const queue = [[row, col]];
        grid[row][col] = '0';

        const directions = [
            [1, 0], [-1, 0], [0, 1], [0, -1], 
            [1, 1], [-1, -1], [1, -1], [-1, 1]
        ];

        while (queue.length > 0) {
            const [currentRow, currentCol] = queue.shift();

            for (const [dr, dc] of directions) {
                const newRow = currentRow + dr;
                const newCol = currentCol + dc;

                if (
                    newRow >= 0 && newRow < rows && 
                    newCol >= 0 && newCol < cols && 
                    grid[newRow][newCol] === '1'
                ) {
                    queue.push([newRow, newCol]);
                    grid[newRow][newCol] = '0';
                }
            }
        }
    }

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col] === '1') {
                islandCount++;
                bfs(row, col);
            }
        }
    }

    return islandCount;
}

// Example usage:
const grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
];
console.log(numIslandsBFS(grid));  // Output: 3
```

**Tips and Tricks:**
- Use BFS to explore all connected cells of an island iteratively.
- Utilize a queue to keep track of cells to be explored.

**Frequent Gotchas:**
- Forgetting to mark cells as visited, leading to infinite loops.
- Handling edge cases where the matrix is empty or contains no islands.

## **Max Area of Island**

**Problem:** Given a binary matrix, find the maximum area of an island. An island is a group of connected '1's, and the area is the number of '1's in the island.

**Step-by-Step Solution:**
1. Iterate through each cell in the matrix.
2. When a '1' is encountered, it signifies the start of a new island.
3. Use DFS or BFS to calculate the area of the island and mark all connected '1's as visited.
4. Keep track of the maximum area encountered.
5. Continue iterating through the matrix to find all islands.

**Code Example:**
```javascript
function maxAreaOfIsland(grid) {
    if (grid.length === 0) return 0;

    const rows = grid.length;
    const cols = grid[0].length;
    let maxArea = 0;

    function dfs(row, col) {
        if (row < 0 || col < 0 || row >= rows || col >= cols || grid[row][col] === '0') {
            return 0;
        }

        // Mark the cell as visited by changing it to '0'
        grid[row][col] = '0';
        let area = 1;

        // Traverse in all 8 directions
        area += dfs(row + 1, col);
        area += dfs(row - 1, col);
        area += dfs(row, col + 1);
        area += dfs(row, col - 1);
        area += dfs(row + 1, col + 1);
        area += dfs(row - 1, col - 1);
        area += dfs(row + 1, col - 1);
        area += dfs(row - 

1, col + 1);

        return area;
    }

    for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
            if (grid[row][col] === '1') {
                const area = dfs(row, col);
                maxArea = Math.max(maxArea, area);
            }
        }
    }

    return maxArea;
}

// Example usage:
const grid = [
    ['1', '1', '0', '0', '0'],
    ['1', '1', '0', '0', '0'],
    ['0', '0', '1', '0', '0'],
    ['0', '0', '0', '1', '1']
];
console.log(maxAreaOfIsland(grid));  // Output: 4
```

**Tips and Tricks:**
- Use DFS to explore and calculate the area of each island recursively.
- Keep track of the maximum area encountered during traversal.

**Frequent Gotchas:**
- Forgetting to mark cells as visited, leading to infinite recursion.
- Handling edge cases where the matrix is empty or contains no islands.

By mastering the Islands (Matrix Traversal) technique, you can efficiently solve a variety of problems involving connected components, region marking, and matrix traversal. This technique is essential for optimizing time complexity and handling matrix-related problems effectively in both technical interviews and real-world applications.

 