# Understanding TypeScript's Type System

## The Mental Model

### Types as Sets

Think of TypeScript types as sets of possible values:

- `number` is the set of all numeric values
- `string` is the set of all text values
- A union `string | number` is the combined set of all strings and numbers
- An intersection `A & B` is the set of values that belong to both A and B

### Structural vs Nominal Typing

TypeScript uses structural typing ("duck typing"): types are compatible if they share the same structure, regardless of their names.

```typescript
// These are compatible because they have the same structure
interface Point {
  x: number
  y: number
}

class Coordinate {
  constructor(
    public x: number,
    public y: number,
  ) {}
}

// This works! TypeScript sees they're structurally identical
const point: Point = new Coordinate(10, 20)
```

### Type System Goals

TypeScript's type system aims to:

1. Catch errors before runtime
2. Enable better tooling (autocomplete, refactoring)
3. Serve as documentation
4. Allow gradual adoption

## Type Inference

### How TypeScript Infers Types

TypeScript uses several strategies to infer types:

1. **Variable Initialization**

```typescript
// TypeScript infers the most specific type possible
let message = 'Hello' // type: "Hello" (literal type)
let count = 42 // type: number
let items = [] // type: any[]
let mixed = [1, 'two'] // type: (string | number)[]
```

2. **Return Type Inference**

```typescript
function createUser(name: string, age: number) {
  return {
    name,
    age,
    createdAt: new Date(),
  }
}
// TypeScript infers return type:
// { name: string; age: number; createdAt: Date }
```

3. **Context-based Type Inference**

```typescript
// TypeScript uses context to infer callback parameters
;[1, 2, 3].map((num) => num * 2)
// num is inferred as number
;['a', 'b'].map((str) => str.toUpperCase())
// str is inferred as string
```

### Best Practices for Type Inference

1. **Let TypeScript Do the Work**

```typescript
// Good: Let TypeScript infer obvious types
const numbers = [1, 2, 3]
const user = {
  name: 'John',
  age: 30,
}

// Bad: Unnecessary explicit types
const numbers: number[] = [1, 2, 3]
const user: { name: string; age: number } = {
  name: 'John',
  age: 30,
}
```

2. **Be Explicit When Needed**

```typescript
// Good: Explicit types for empty arrays
const numbers: number[] = []

// Good: Explicit types for complex objects
interface UserPreferences {
  theme: 'light' | 'dark'
  notifications: boolean
  fontSize: number
}

const defaultPreferences: UserPreferences = {
  theme: 'light',
  notifications: true,
  fontSize: 14,
}
```

### Control Flow Analysis

TypeScript analyzes code flow to refine types:

```typescript
function process(value: string | number) {
  if (typeof value === 'string') {
    // TypeScript knows value is string here
    console.log(value.toUpperCase())
  } else {
    // TypeScript knows value is number here
    console.log(value.toFixed(2))
  }
}

function handleValue(value: string | null) {
  if (!value) {
    // TypeScript knows value is null here
    return
  }

  // TypeScript knows value is non-null string here
  console.log(value.length)
}
```

## Union Types

### Understanding Union Types

Union types represent values that could be one of several types:

```typescript
type StringOrNumber = string | number

function printId(id: StringOrNumber) {
  if (typeof id === 'string') {
    // In here, id is string
    console.log(id.toUpperCase())
  } else {
    // In here, id is number
    console.log(id.toFixed(2))
  }
}
```

### Discriminated Unions

A powerful pattern for handling multiple related types:

```typescript
type Success = {
  type: 'success'
  data: string
}

type Error = {
  type: 'error'
  message: string
}

type Result = Success | Error

function handleResult(result: Result) {
  switch (result.type) {
    case 'success':
      // TypeScript knows result is Success here
      console.log(result.data)
      break
    case 'error':
      // TypeScript knows result is Error here
      console.log(result.message)
      break
  }
}
```

### Type Narrowing Techniques

1. **typeof Guards**

```typescript
function process(value: string | number) {
  if (typeof value === 'string') {
    return value.toUpperCase()
  }
  return value.toFixed(2)
}
```

2. **instanceof Guards**

```typescript
class Customer {
  constructor(public name: string) {}
}

class Employee {
  constructor(
    public name: string,
    public role: string,
  ) {}
}

function getPerson(person: Customer | Employee) {
  if (person instanceof Employee) {
    return `${person.name} (${person.role})`
  }
  return person.name
}
```

3. **Custom Type Guards**

```typescript
interface Fish {
  swim(): void
}

interface Bird {
  fly(): void
}

// Type predicate
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}

function move(pet: Fish | Bird) {
  if (isFish(pet)) {
    // TypeScript knows pet is Fish
    pet.swim()
  } else {
    // TypeScript knows pet is Bird
    pet.fly()
  }
}
```

4. **Exhaustiveness Checking**

```typescript
type Shape =
  | { kind: 'circle'; radius: number }
  | { kind: 'square'; size: number }
  | { kind: 'rectangle'; width: number; height: number }

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case 'circle':
      return Math.PI * shape.radius ** 2
    case 'square':
      return shape.size ** 2
    case 'rectangle':
      return shape.width * shape.height
    default:
      // TypeScript error if we miss a case
      const _exhaustiveCheck: never = shape
      return _exhaustiveCheck
  }
}
```

# Advanced Type System Features

## Intersection Types

### Understanding Intersection Types

Think of intersection types as combining multiple types into one:

- Like a recipe that must include all ingredients from multiple recipes
- The resulting type has all properties of all constituent types

```typescript
type HasName = { name: string }
type HasAge = { age: number }
type HasAddress = { address: string }

// Person must have all properties
type Person = HasName & HasAge & HasAddress

const person: Person = {
  name: 'John', // Required from HasName
  age: 30, // Required from HasAge
  address: '123 St', // Required from HasAddress
}
```

### Practical Use Cases

1. **Mixing Capabilities**

```typescript
interface Logger {
  log(message: string): void
}

interface ErrorHandler {
  handleError(error: Error): void
}

// Combined functionality
type LoggerWithErrors = Logger & ErrorHandler

class ApplicationLogger implements LoggerWithErrors {
  log(message: string) {
    console.log(message)
  }

  handleError(error: Error) {
    console.error(error)
  }
}
```

2. **Extending Configurations**

```typescript
type BaseConfig = {
  endpoint: string
  timeout: number
}

type AuthConfig = {
  apiKey: string
  userId: string
}

type AppConfig = BaseConfig &
  AuthConfig & {
    version: string
  }

const config: AppConfig = {
  endpoint: 'api.example.com',
  timeout: 5000,
  apiKey: 'secret',
  userId: '123',
  version: '1.0.0',
}
```

## Generics

### The Mental Model

Think of generics like variables for types:

- They let you write flexible, reusable code
- You can specify relationships between types
- They preserve type information through operations

### Basic Generic Patterns

1. **Generic Functions**

```typescript
function identity<T>(value: T): T {
  return value
}

// Type inference works!
const str = identity('hello') // type: string
const num = identity(42) // type: number

// Explicit type argument
const explicit = identity<string>('hello')
```

2. **Generic Interfaces**

```typescript
interface Box<T> {
  value: T
  map<U>(fn: (value: T) => U): Box<U>
}

class DataBox<T> implements Box<T> {
  constructor(public value: T) {}

  map<U>(fn: (value: T) => U): Box<U> {
    return new DataBox(fn(this.value))
  }
}

const box = new DataBox(123).map((n) => n.toString()).map((s) => s.length)
// box.value is number
```

### Generic Constraints

1. **extends Keyword**

```typescript
interface HasLength {
  length: number
}

function logLength<T extends HasLength>(value: T): T {
  console.log(value.length)
  return value
}

// Works with strings
logLength('hello')

// Works with arrays
logLength([1, 2, 3])

// Error: number doesn't have length
logLength(123)
```

2. **Multiple Constraints**

```typescript
interface HasName {
  name: string
}

interface HasAge {
  age: number
}

function printPerson<T extends HasName & HasAge>(person: T) {
  console.log(`${person.name} is ${person.age} years old`)
  return person
}
```

### Advanced Generic Patterns

1. **Generic Type Inference with Multiple Types**

```typescript
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 }
}

const result = merge({ name: 'John' }, { age: 30 })
// result type: { name: string } & { age: number }
```

2. **Factory Pattern with Generics**

```typescript
interface Constructor<T> {
  new (...args: any[]): T
}

function withLogging<T>(Base: Constructor<T>) {
  return class extends Base {
    constructor(...args: any[]) {
      super(...args)
      console.log(`Created new instance of ${Base.name}`)
    }
  }
}

@withLogging
class User {
  constructor(public name: string) {}
}
```

3. **Generic Type Guards**

```typescript
function isArray<T>(value: T | T[]): value is T[] {
  return Array.isArray(value)
}

function processValue<T>(value: T | T[]) {
  if (isArray(value)) {
    // TypeScript knows value is T[]
    value.map((item) => console.log(item))
  } else {
    // TypeScript knows value is T
    console.log(value)
  }
}
```

4. **Mapped Types with Generics**

```typescript
type Optional<T> = {
  [P in keyof T]?: T[P]
}

type ReadOnly<T> = {
  readonly [P in keyof T]: T[P]
}

interface User {
  name: string
  age: number
}

// All properties are optional
type OptionalUser = Optional<User>

// All properties are readonly
type ReadOnlyUser = ReadOnly<User>
```

### Real-World Generic Patterns

1. **Type-Safe Event Emitter**

```typescript
type EventMap = {
  login: { user: string; time: Date }
  logout: { user: string }
  error: { code: number; message: string }
}

class TypedEventEmitter<T extends Record<string, any>> {
  private listeners = new Map<keyof T, Set<(data: any) => void>>()

  on<K extends keyof T>(event: K, callback: (data: T[K]) => void) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, new Set())
    }
    this.listeners.get(event)!.add(callback)
  }

  emit<K extends keyof T>(event: K, data: T[K]) {
    this.listeners.get(event)?.forEach((callback) => {
      callback(data)
    })
  }
}

// Usage
const emitter = new TypedEventEmitter<EventMap>()

emitter.on('login', ({ user, time }) => {
  console.log(`${user} logged in at ${time}`)
})

emitter.emit('login', {
  user: 'john',
  time: new Date(),
})
```

# Advanced Type Inference and Practical Applications

## Advanced Type Inference

### Conditional Types

Think of conditional types like type-level if statements:

```typescript
type IsString<T> = T extends string ? true : false

// Examples
type A = IsString<string> // true
type B = IsString<number> // false

// Real-world example: Extract return type
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never

function fetchUser() {
  return { id: 1, name: 'John' }
}

type UserData = ReturnType<typeof fetchUser>
// { id: number; name: string; }
```

### Inference with infer

The `infer` keyword lets us extract types from other types:

```typescript
// Extract array element type
type ArrayElement<T> = T extends Array<infer E> ? E : never

// Extract promise value type
type UnwrapPromise<T> = T extends Promise<infer U> ? U : T

// Extract function parameter types
type Parameters<T> = T extends (...args: infer P) => any ? P : never

// Practical example: API response type
type ApiResponse<T> = {
  data: T
  status: number
  timestamp: Date
}

type ExtractData<T> = T extends ApiResponse<infer D> ? D : never

// Usage
interface UserResponse extends ApiResponse<{ id: number; name: string }> {}
type UserData = ExtractData<UserResponse> // { id: number; name: string; }
```

### Template Literal Types

Combining string literals at the type level:

```typescript
type EventType = 'click' | 'change' | 'submit'
type EventHandler<T extends string> = `on${Capitalize<T>}`

// Results in: 'onClick' | 'onChange' | 'onSubmit'
type HandlerNames = EventHandler<EventType>

// Real-world example: API route builder
type HttpMethod = 'get' | 'post' | 'put' | 'delete'
type Route = 'users' | 'posts' | 'comments'
type ApiRoute = `/${Route}`
type ApiEndpoint = `${HttpMethod}:${ApiRoute}`

// Creates: 'get:/users' | 'post:/users' | 'get:/posts' | etc.
```

## Practical Type System Applications

### Type-Safe API Client

```typescript
interface ApiDefinition {
  'users/get': {
    params: { id: number }
    response: { name: string; email: string }
  }
  'users/create': {
    params: { name: string; email: string }
    response: { id: number }
  }
}

class ApiClient {
  async request<T extends keyof ApiDefinition>(
    endpoint: T,
    params: ApiDefinition[T]['params'],
  ): Promise<ApiDefinition[T]['response']> {
    const response = await fetch(`/api/${endpoint}`, {
      method: 'POST',
      body: JSON.stringify(params),
    })

    return response.json()
  }
}

// Usage
const api = new ApiClient()

// TypeScript knows the exact types!
const user = await api.request('users/get', { id: 1 })
// user is { name: string; email: string }
```

### Type-Safe Event System

```typescript
type EventDefinition = {
  userLoggedIn: { userId: string; timestamp: Date }
  userLoggedOut: { userId: string }
  error: { code: number; message: string }
}

class TypeSafeEventEmitter {
  private handlers = new Map<keyof EventDefinition, Set<(data: any) => void>>()

  on<E extends keyof EventDefinition>(
    event: E,
    handler: (data: EventDefinition[E]) => void,
  ) {
    if (!this.handlers.has(event)) {
      this.handlers.set(event, new Set())
    }
    this.handlers.get(event)!.add(handler)
  }

  emit<E extends keyof EventDefinition>(event: E, data: EventDefinition[E]) {
    this.handlers.get(event)?.forEach((handler) => {
      handler(data)
    })
  }
}
```

### Generic Container Types

```typescript
class Result<T, E = Error> {
  private constructor(
    private value: T | null,
    private error: E | null,
  ) {}

  static ok<T>(value: T): Result<T> {
    return new Result(value, null)
  }

  static err<E>(error: E): Result<never, E> {
    return new Result(null, error)
  }

  map<U>(fn: (value: T) => U): Result<U, E> {
    if (this.value === null) {
      return Result.err(this.error!)
    }
    return Result.ok(fn(this.value))
  }

  flatMap<U>(fn: (value: T) => Result<U, E>): Result<U, E> {
    if (this.value === null) {
      return Result.err(this.error!)
    }
    return fn(this.value)
  }

  match<U>(onOk: (value: T) => U, onErr: (error: E) => U): U {
    if (this.value === null) {
      return onErr(this.error!)
    }
    return onOk(this.value)
  }
}

// Usage example
function divide(a: number, b: number): Result<number> {
  if (b === 0) {
    return Result.err(new Error('Division by zero'))
  }
  return Result.ok(a / b)
}

// Type-safe error handling
const result = divide(10, 2)
  .map((result) => result * 2)
  .flatMap((result) =>
    result > 0 ? Result.ok(result) : Result.err(new Error('Negative')),
  )

result.match(
  (value) => console.log(`Success: ${value}`),
  (error) => console.error(`Error: ${error.message}`),
)
```

### Complex Type Inference

```typescript
// Deep partial type
type DeepPartial<T> = T extends object
  ? {
      [P in keyof T]?: DeepPartial<T[P]>
    }
  : T

// Deep readonly type
type DeepReadonly<T> = T extends object
  ? {
      readonly [P in keyof T]: DeepReadonly<T[P]>
    }
  : T

// Extract property paths
type PropertyPath<T> = T extends object
  ? {
      [K in keyof T]: K extends string
        ? T[K] extends object
          ? K | `${K}.${PropertyPath<T[K]>}`
          : K
        : never
    }[keyof T]
  : never

// Usage example
interface User {
  name: string
  settings: {
    theme: {
      dark: boolean
      fontSize: number
    }
    notifications: boolean
  }
}

type UserPaths = PropertyPath<User>
// "name" | "settings" | "settings.theme" | "settings.theme.dark" |
// "settings.theme.fontSize" | "settings.notifications"

// Type-safe object operations
function get<T, P extends PropertyPath<T>>(obj: T, path: P): any {
  return path.split('.').reduce((value, key) => value?.[key], obj as any)
}

// Usage
const user: User = {
  name: 'John',
  settings: {
    theme: {
      dark: true,
      fontSize: 14,
    },
    notifications: true,
  },
}

const fontSize = get(user, 'settings.theme.fontSize')
// TypeScript knows this is a number
```

These advanced patterns enable you to build robust, type-safe applications while leveraging TypeScript's powerful type system to catch errors at compile time and provide better developer experience.
