# Understanding Declaration Files

## The Mental Model

Think of declaration files (.d.ts) as "type contracts" or "type interfaces" for JavaScript code:

- They describe the shape of code without implementing it
- They act as documentation that TypeScript can understand
- They bridge the gap between JavaScript and TypeScript

### Purpose of Declaration Files

```typescript
// JavaScript library code (example.js)
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0)
}

// TypeScript declaration file (example.d.ts)
interface Item {
  price: number
  [key: string]: any // Allow other properties
}

declare function calculateTotal(items: Item[]): number
```

## Writing Declaration Files

### Basic Declarations

1. **Function Declarations**

```typescript
// Basic function
declare function greet(name: string): string

// Function with overloads
declare function createElement(tag: 'div'): HTMLDivElement
declare function createElement(tag: 'span'): HTMLSpanElement
declare function createElement(tag: string): HTMLElement

// Optional and rest parameters
declare function formatList(separator?: string, ...items: string[]): string
```

2. **Class Declarations**

```typescript
declare class HttpClient {
  constructor(baseUrl: string)

  // Instance methods
  get<T>(url: string): Promise<T>
  post<T>(url: string, data: unknown): Promise<T>

  // Properties
  readonly baseUrl: string

  // Optional properties
  timeout?: number

  // Static members
  static create(config: HttpClientConfig): HttpClient
}

interface HttpClientConfig {
  baseUrl: string
  timeout?: number
  headers?: Record<string, string>
}
```

3. **Variable and Constant Declarations**

```typescript
// Constants
declare const API_VERSION: string
declare const DEBUG: boolean

// Complex objects
declare const config: {
  readonly apiUrl: string
  readonly timeout: number
  features: {
    logging: boolean
    cache: boolean
  }
}

// Enums
declare enum LogLevel {
  DEBUG,
  INFO,
  WARN,
  ERROR,
}
```

## Module Declaration Patterns

### External Module Declarations

1. **ES Module Style**

```typescript
// types/my-library/index.d.ts
declare module 'my-library' {
  export interface Options {
    timeout?: number
    retries?: number
  }

  export class Client {
    constructor(options?: Options)
    connect(): Promise<void>
    query<T>(sql: string): Promise<T[]>
  }

  export function createClient(options?: Options): Client
}

// Usage
import { Client, createClient } from 'my-library'
```

2. **Namespace Style**

```typescript
// types/charting-library/index.d.ts
declare namespace ChartLibrary {
  interface ChartOptions {
    width: number
    height: number
    title?: string
  }

  interface Chart {
    render(): void
    update(data: unknown[]): void
    destroy(): void
  }

  function createChart(element: HTMLElement, options: ChartOptions): Chart
}

// Usage
/// <reference path="./types/charting-library/index.d.ts" />
const chart = ChartLibrary.createChart(element, {
  width: 600,
  height: 400,
})
```

### Module Augmentation

```typescript
// Existing library
declare module 'existing-library' {
  export interface BaseConfig {
    name: string
  }
}

// Augmentation
declare module 'existing-library' {
  export interface BaseConfig {
    // Add new property
    version?: string
  }

  // Add new export
  export function initialize(config: BaseConfig): void
}
```

## Type Definition Patterns

### Generic Type Definitions

```typescript
// Generic container
declare class Container<T> {
  constructor(initial?: T)

  getValue(): T
  setValue(value: T): void

  map<U>(fn: (value: T) => U): Container<U>

  // Generic method with constraints
  validate<K extends keyof T>(key: K): boolean
}

// Generic function
declare function transform<T, U>(items: T[], mapper: (item: T) => U): U[]

// Generic type with multiple parameters
declare class Result<T, E = Error> {
  static success<T>(value: T): Result<T, never>
  static failure<E>(error: E): Result<never, E>

  isSuccess(): this is Result<T, never>
  isFailure(): this is Result<never, E>
}
```

### Callback and Promise Patterns

```typescript
// Event callback pattern
declare function on<K extends keyof EventMap>(
  event: K,
  callback: (data: EventMap[K]) => void,
): void

// Promise with generics
declare function fetchData<T>(url: string, options?: RequestOptions): Promise<T>

// Async iterator
declare class AsyncQueue<T> {
  push(item: T): void
  [Symbol.asyncIterator](): AsyncIterator<T>
}
```

### Function Overloads

```typescript
declare function createElement(tag: string): HTMLElement
declare function createElement<K extends keyof HTMLElementTagNameMap>(
  tag: K,
): HTMLElementTagNameMap[K]
declare function createElement<T extends HTMLElement>(
  tag: string,
  options: ElementCreationOptions,
): T

// Complex overloads
interface StringValidator {
  isValid(str: string): boolean
}

interface NumberValidator {
  isValid(num: number): boolean
}

declare function validate(value: string): StringValidator
declare function validate(value: number): NumberValidator
declare function validate<T>(
  value: T,
  validator: (value: T) => boolean,
): boolean
```

# Advanced Declaration Patterns

## Module Augmentation Deep Dive

### Extending Existing Modules

```typescript
// Original library types
declare module 'express' {
  interface Request {
    // Original types
    params: Record<string, string>
  }
}

// Augmenting with custom properties
declare module 'express' {
  interface Request {
    // Add custom properties
    user?: {
      id: string
      roles: string[]
    }
    session?: {
      data: Record<string, any>
      touch(): void
    }
  }
}

// Usage
app.get('/', (req) => {
  // TypeScript knows about user and session
  if (req.user?.roles.includes('admin')) {
    req.session?.touch()
  }
})
```

### Global Augmentation

```typescript
// Extending global scope
declare global {
  interface Window {
    analytics: {
      track(event: string, properties?: object): void
      identify(userId: string, traits?: object): void
    }
  }

  interface Array<T> {
    toCSV(): string
    chunk(size: number): T[][]
  }

  // Add global utilities
  function isDevMode(): boolean
  function logger(message: string, level?: 'info' | 'error'): void
}

// Usage
window.analytics.track('Page View')
;[1, 2, 3].chunk(2) // [[1, 2], [3]]
```

## Advanced Type Definition Patterns

### Conditional Type Definitions

```typescript
// Library that handles different data types
declare module 'data-processor' {
  type ProcessorResult<T> =
    T extends Array<any>
      ? { items: T; total: number }
      : T extends object
        ? { data: T; timestamp: Date }
        : { value: T }

  export function process<T>(input: T): ProcessorResult<T>
}

// Usage
import { process } from 'data-processor'

const arrayResult = process([1, 2, 3])
// { items: number[]; total: number }

const objectResult = process({ id: 1 })
// { data: { id: number }; timestamp: Date }
```

### Mapped Type Definitions

```typescript
declare module 'form-builder' {
  type FormConfig<T> = {
    [K in keyof T]: {
      type: 'string' | 'number' | 'boolean'
      label?: string
      validate?: (value: T[K]) => boolean
      transform?: (value: string) => T[K]
    }
  }

  export class Form<T> {
    constructor(config: FormConfig<T>)
    getValue(): Partial<T>
    setValue(values: Partial<T>): void
    validate(): boolean
  }
}

// Usage
interface UserForm {
  name: string
  age: number
  subscribed: boolean
}

const form = new Form<UserForm>({
  name: {
    type: 'string',
    validate: (value) => value.length >= 2,
  },
  age: {
    type: 'number',
    transform: (value) => parseInt(value, 10),
  },
  subscribed: {
    type: 'boolean',
  },
})
```

## Declaration Merging

### Interface Merging

```typescript
// Multiple declarations merge
interface API {
  get<T>(url: string): Promise<T>
}

interface API {
  post<T>(url: string, data: unknown): Promise<T>
}

interface API {
  delete(url: string): Promise<void>
}

// Results in:
// interface API {
//     get<T>(url: string): Promise<T>;
//     post<T>(url: string, data: unknown): Promise<T>;
//     delete(url: string): Promise<void>;
// }

declare const api: API
```

### Namespace Merging

```typescript
// Merge namespace with interface
interface ValidatorConfig {
  rules: object
}

namespace ValidatorConfig {
  export function create(rules: object): ValidatorConfig {
    return { rules }
  }

  export const DEFAULT_RULES = {}
}

// Usage
const config = ValidatorConfig.create({})
```

### Class and Namespace Merging

```typescript
// Class definition
declare class Logger {
  log(message: string): void
  error(message: string): void
}

// Namespace with same name
namespace Logger {
  export interface LogEntry {
    message: string
    timestamp: Date
    level: 'info' | 'error'
  }

  export function createEntry(
    message: string,
    level: LogEntry['level'],
  ): LogEntry {
    return {
      message,
      timestamp: new Date(),
      level,
    }
  }
}

// Usage
const logger = new Logger()
const entry = Logger.createEntry('Error occurred', 'error')
logger.error(entry.message)
```

### Enum Merging

```typescript
// Enum definition
enum Direction {
  Up = 'UP',
  Down = 'DOWN',
}

// Namespace merging with enum
namespace Direction {
  export function isVertical(dir: Direction): boolean {
    return dir === Direction.Up || dir === Direction.Down
  }

  export function flip(dir: Direction): Direction {
    switch (dir) {
      case Direction.Up:
        return Direction.Down
      case Direction.Down:
        return Direction.Up
    }
  }
}

// Usage
const dir = Direction.Up
if (Direction.isVertical(dir)) {
  const flipped = Direction.flip(dir)
}
```

## Module Declaration with Configurations

```typescript
declare module 'config-manager' {
  // Configuration definition
  interface ConfigOptions<T> {
    initial?: T
    validate?: (value: T) => boolean
    transform?: (value: unknown) => T
  }

  // Type helpers
  type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]
  }

  // Main class
  export class Config<T extends object> {
    constructor(options?: ConfigOptions<T>)

    get<K extends keyof T>(key: K): T[K]
    set<K extends keyof T>(key: K, value: T[K]): void

    // Batch operations
    update(values: DeepPartial<T>): void

    // Event handling
    onChange<K extends keyof T>(
      key: K,
      callback: (value: T[K]) => void,
    ): () => void
  }

  // Utility types
  export type Validator<T> = (value: T) => boolean
  export type Transform<T> = (value: unknown) => T
}
```

# Practice Problems and Real-World Examples

## Problem 1: Building Library Type Definitions

### Creating Types for a UI Component Library

```typescript
// @types/awesome-ui/index.d.ts
declare module 'awesome-ui' {
  export interface ComponentProps {
    className?: string
    style?: React.CSSProperties
    id?: string
  }

  export interface ButtonProps extends ComponentProps {
    variant?: 'primary' | 'secondary' | 'outline'
    size?: 'small' | 'medium' | 'large'
    disabled?: boolean
    onClick?: (event: React.MouseEvent) => void
    loading?: boolean
  }

  export interface InputProps extends ComponentProps {
    value?: string
    onChange?: (value: string) => void
    type?: 'text' | 'password' | 'email' | 'number'
    placeholder?: string
    error?: string
    success?: boolean
  }

  export class Button extends React.Component<ButtonProps> {}
  export class Input extends React.Component<InputProps> {}

  // Theme system
  export interface ThemeConfig {
    colors: {
      primary: string
      secondary: string
      error: string
      success: string
      [key: string]: string
    }
    spacing: {
      small: number
      medium: number
      large: number
      [key: string]: number
    }
  }

  export function createTheme(config: Partial<ThemeConfig>): ThemeConfig
  export function ThemeProvider(props: {
    theme: ThemeConfig
    children: React.ReactNode
  }): JSX.Element
}
```

## Problem 2: API Client Library Definitions

```typescript
// @types/api-client/index.d.ts
declare module 'api-client' {
  export interface RequestConfig {
    baseURL?: string
    timeout?: number
    headers?: Record<string, string>
    retry?: {
      attempts: number
      delay: number
    }
  }

  export interface Response<T = any> {
    data: T
    status: number
    headers: Record<string, string>
    timestamp: Date
  }

  export interface ErrorResponse {
    code: string
    message: string
    details?: unknown
  }

  export class APIError extends Error {
    code: string
    status: number
    details?: unknown
    constructor(response: ErrorResponse, status: number)
  }

  export class Client {
    constructor(config?: RequestConfig)

    // Generic request methods
    request<T = any>(config: {
      method: string
      url: string
      data?: any
      params?: Record<string, string>
    }): Promise<Response<T>>

    // Convenience methods
    get<T = any>(url: string, params?: Record<string, string>): Promise<T>
    post<T = any>(url: string, data?: any): Promise<T>
    put<T = any>(url: string, data?: any): Promise<T>
    delete<T = any>(url: string): Promise<T>

    // Configuration
    setHeader(name: string, value: string): void
    setTimeout(timeout: number): void
    setBaseURL(url: string): void

    // Middleware
    use(middleware: (config: RequestConfig) => RequestConfig): void
    useResponse<T>(middleware: (response: Response<T>) => Response<T>): void
  }

  // Factory function
  export function createClient(config?: RequestConfig): Client
}
```

## Problem 3: State Management Library

```typescript
// @types/state-manager/index.d.ts
declare module 'state-manager' {
  // Core types
  export type Selector<T, R> = (state: T) => R
  export type ActionCreator<T = void> = T extends void
    ? () => Action
    : (payload: T) => Action<T>

  export interface Action<T = any> {
    type: string
    payload?: T
  }

  export interface Reducer<T> {
    (state: T, action: Action): T
  }

  // Store configuration
  export interface StoreConfig<T> {
    initialState: T
    reducers: {
      [K in keyof T]: Reducer<T[K]>
    }
    middleware?: Middleware[]
    devTools?: boolean
  }

  // Middleware system
  export interface MiddlewareAPI<T> {
    getState(): T
    dispatch(action: Action): void
  }

  export type Middleware = <T>(
    api: MiddlewareAPI<T>,
  ) => (next: (action: Action) => void) => (action: Action) => void

  // Store class
  export class Store<T> {
    constructor(config: StoreConfig<T>)

    // State management
    getState(): T
    setState(state: Partial<T>): void

    // Subscriptions
    subscribe<R>(
      selector: Selector<T, R>,
      callback: (value: R) => void,
    ): () => void

    // Actions
    dispatch(action: Action): void

    // Utilities
    reset(): void
    destroy(): void
  }

  // Decorator support
  export function connect<T, P>(
    mapState: (state: T) => Partial<P>,
  ): (target: any) => any

  // React integration
  export function useStore<T>(): Store<T>
  export function useSelector<T, R>(selector: Selector<T, R>): R
  export function useDispatch(): (action: Action) => void
}
```

## Problem 4: Testing Library Types

```typescript
// @types/test-utils/index.d.ts
declare module 'test-utils' {
  // Query types
  type QueryResult<T> = T | null
  type QueryAllResult<T> = T[]

  interface QueryOptions {
    timeout?: number
    interval?: number
    exact?: boolean
    selector?: string
  }

  // Event simulation
  interface EventOptions {
    bubbles?: boolean
    cancelable?: boolean
    composed?: boolean
  }

  interface KeyboardEventOptions extends EventOptions {
    key: string
    code: string
    ctrlKey?: boolean
    altKey?: boolean
    shiftKey?: boolean
    metaKey?: boolean
  }

  // Main utilities
  export interface TestUtils {
    // Queries
    getByText(text: string, options?: QueryOptions): QueryResult<HTMLElement>
    getAllByText(
      text: string,
      options?: QueryOptions,
    ): QueryAllResult<HTMLElement>
    getByTestId(id: string): QueryResult<HTMLElement>

    // Events
    click(element: HTMLElement): void
    type(
      element: HTMLElement,
      text: string,
      options?: KeyboardEventOptions,
    ): void
    hover(element: HTMLElement): void

    // Async utilities
    waitFor(
      callback: () => void | Promise<void>,
      options?: { timeout?: number; interval?: number },
    ): Promise<void>

    waitForElement(
      selector: string,
      options?: QueryOptions,
    ): Promise<HTMLElement>
  }

  // Custom matchers
  declare global {
    namespace jest {
      interface Matchers<R> {
        toBeVisible(): R
        toBeHidden(): R
        toHaveText(text: string): R
        toHaveValue(value: string | number): R
      }
    }
  }

  // Setup function
  export function setup(config?: {
    timeout?: number
    testId?: string
  }): TestUtils
}
```

These examples demonstrate:

1. How to write comprehensive type definitions for libraries
2. Different patterns for module declarations
3. Integration with existing types (React, Jest)
4. Complex type systems with generics
5. Declaration merging and module augmentation
