# Understanding Scope and Closures: Part 1 - Scope Fundamentals

## Building a Mental Model of Scope

### What is Scope?

Scope in JavaScript is like a set of rules that determines where variables are defined and where they can be accessed. Think of your code as a tall building where each room (scope) has its own variables, and there are specific rules about who can access what.

### The Building Analogy

Imagine a corporate building:

- The lobby (Global scope) - Everyone has access
- Department floors (Function scope) - Only department members have access
- Individual offices (Block scope) - Most restricted access

```javascript
// The Lobby (Global Scope)
const companyName = 'TechCorp'

function engineeringDepartment() {
  // A Department Floor
  const department = 'Engineering'

  function teamMeeting() {
    // An Individual Office
    const topic = 'Architecture'
    console.log(`${companyName}: ${department} discussing ${topic}`)
  }

  teamMeeting()
  console.log(topic) // ❌ Can't access variables from inner office
}

console.log(department) // ❌ Can't access variables from other floors
```

## Lexical Scope Deep Dive

### How JavaScript Resolves Variables

JavaScript uses lexical (or static) scoping. This means the structure of your code determines the scope, not how the code is called.

```javascript
const value = 'outer'

function first() {
  const value = 'middle'

  function second() {
    const value = 'inner'

    function third() {
      // JavaScript looks for 'value' in this order:
      // 1. Inside third() - not found
      // 2. Inside second() - found! Uses "inner"
      // 3. Inside first() - never reaches here
      // 4. Global scope - never reaches here
      console.log(value)
    }

    third()
  }

  second()
}

first() // Prints: "inner"
```

### Scope Chain in Detail

The scope chain is created when code is parsed, not when it's run:

```javascript
function outer() {
  // Scope chain is already established
  // Even before this function runs
  const name = 'outer'

  function helper() {
    // This function's scope chain includes:
    // 1. Its own scope
    // 2. outer()'s scope
    // 3. Global scope
    const helperVar = 'helper'

    function inner() {
      // This function's scope chain includes:
      // 1. Its own scope
      // 2. helper()'s scope
      // 3. outer()'s scope
      // 4. Global scope
      console.log(name) // Can access 'name' from outer()
      console.log(helperVar) // Can access from helper()
    }

    inner()
  }

  helper()
}
```

### Shadowing Variables

When the same variable name exists in multiple scopes:

```javascript
const value = 'global'

function example() {
  const value = 'local'

  if (true) {
    const value = 'block'
    console.log('Block:', value) // "block"
    ;(function () {
      const value = 'IIFE'
      console.log('IIFE:', value) // "IIFE"
    })()
  }

  console.log('Function:', value) // "local"
}

console.log('Global:', value) // "global"
example()
```

## Variable Types and Scope Behavior

### var vs let vs const

Each type of variable declaration behaves differently with scope:

```javascript
// 1. var - Function-scoped
function varExample() {
  var x = 1

  if (true) {
    var x = 2 // Same variable!
    console.log(x) // 2
  }

  console.log(x) // 2
}

// 2. let - Block-scoped
function letExample() {
  let x = 1

  if (true) {
    let x = 2 // Different variable
    console.log(x) // 2
  }

  console.log(x) // 1
}

// 3. const - Block-scoped and immutable binding
function constExample() {
  const x = { value: 1 }

  if (true) {
    const x = { value: 2 } // Different variable
    x.value = 3 // OK - mutating the object
    console.log(x.value) // 3
  }

  console.log(x.value) // 1
}
```

### Hoisting in Detail

Variable declarations are processed before code execution, but differently for each type:

```javascript
console.log(varVariable) // undefined
console.log(letVariable) // ❌ ReferenceError
console.log(constVariable) // ❌ ReferenceError

var varVariable = 'var'
let letVariable = 'let'
const constVariable = 'const'

// Function declarations are fully hoisted
console.log(add(1, 2)) // 3

function add(a, b) {
  return a + b
}

// Function expressions are not hoisted
console.log(subtract(1, 2)) // ❌ ReferenceError

const subtract = function (a, b) {
  return a - b
}
```

## Modern Block Scope

### Understanding Block Scope

Blocks create new scope for `let` and `const`:

```javascript
// 1. if blocks
if (true) {
  const message = 'Only visible here'
  console.log(message) // OK
}
console.log(message) // ❌ ReferenceError

// 2. loop blocks
for (let i = 0; i < 3; i++) {
  const value = i * 2
  console.log(value) // OK
}
console.log(value) // ❌ ReferenceError

// 3. switch blocks
switch (value) {
  case 1: {
    const result = 'one'
    console.log(result)
    break
  }
  case 2: {
    const result = 'two' // Different variable
    console.log(result)
    break
  }
}
```

### Temporal Dead Zone (TDZ)

The TDZ is the time between entering scope and variable declaration:

```javascript
{
  // TDZ starts here
  console.log(value) // ❌ ReferenceError

  // TDZ continues...

  let value = 'Hello' // TDZ ends

  console.log(value) // OK
}

// Real-world example of TDZ
class Example {
  static value = 'static'

  static {
    // TDZ for 'value'
    console.log(this.value) // OK - "static"
    console.log(value) // ❌ ReferenceError - TDZ
  }
}
```

### Blocks and Scope in Modern JavaScript

Modern JavaScript features introduce new scoping scenarios:

```javascript
// 1. try/catch blocks
try {
    throw new Error("Oops");
} catch (error) {
    console.log(error);  // Only available in catch block
}
console.log(error);  // ❌ ReferenceError

// 2. async/await blocks
async function example() {
    const response = await fetch('/api');
    {
        const data = await response.json();
        console.log(data);
    }
    console.log(data);  // ❌ ReferenceError
}

// 3. Module blocks (proposal)
let moduleBlock = {
    const privateValue = "hidden";
    export function getValue() {
        return privateValue;
    }
};
```

# Understanding Scope and Closures: Part 2 - Closures and Patterns

## Understanding Closures

### What are Closures?

A closure is formed when a function retains access to variables from its outer scope even after the outer scope has finished executing. Think of it like a function "backpack" that carries its surrounding variables wherever it goes.

```javascript
function createGreeting(greeting) {
  // greeting is packed in the closure
  return function (name) {
    // Inner function still has access to greeting
    return `${greeting}, ${name}!`
  }
}

const sayHello = createGreeting('Hello')
const sayHi = createGreeting('Hi')

console.log(sayHello('John')) // "Hello, John!"
console.log(sayHi('Sarah')) // "Hi, Sarah!"
```

### Closure Environment

Each closure maintains its own separate environment:

```javascript
function createCounter(initialValue, step) {
  let count = initialValue

  return {
    increment() {
      count += step
      return count
    },
    decrement() {
      count -= step
      return count
    },
    getValue() {
      return count
    },
  }
}

const counterByOne = createCounter(0, 1)
const counterByTwo = createCounter(10, 2)

console.log(counterByOne.increment()) // 1
console.log(counterByTwo.increment()) // 12
console.log(counterByOne.increment()) // 2
console.log(counterByTwo.increment()) // 14
```

## Advanced Closure Patterns

### Factory Pattern with Closures

Create specialized functions with shared behavior:

```javascript
function createValidator(validationRule) {
  return function (value) {
    const errors = []

    // Shared validation logic
    if (!value) {
      errors.push('Value is required')
    }

    // Specific validation rule
    const ruleErrors = validationRule(value)
    if (ruleErrors) {
      errors.push(...ruleErrors)
    }

    return {
      isValid: errors.length === 0,
      errors,
    }
  }
}

// Create specialized validators
const validateEmail = createValidator((value) => {
  const errors = []
  if (!/^\S+@\S+\.\S+$/.test(value)) {
    errors.push('Invalid email format')
  }
  return errors
})

const validatePassword = createValidator((value) => {
  const errors = []
  if (value.length < 8) {
    errors.push('Password must be at least 8 characters')
  }
  if (!/[A-Z]/.test(value)) {
    errors.push('Password must contain uppercase letter')
  }
  return errors
})

console.log(validateEmail('invalid')) // { isValid: false, errors: [...] }
console.log(validatePassword('weak')) // { isValid: false, errors: [...] }
```

### The Module Pattern

Create private state and methods:

```javascript
function createUserModule() {
  // Private variables
  const users = new Map()
  let nextId = 1

  // Private functions
  function generateId() {
    return `user_${nextId++}`
  }

  function validateUser(user) {
    if (!user.name || !user.email) {
      throw new Error('Invalid user data')
    }
  }

  // Public API
  return {
    addUser(userData) {
      validateUser(userData)
      const id = generateId()
      users.set(id, { ...userData, id })
      return id
    },

    getUser(id) {
      const user = users.get(id)
      if (!user) return null
      // Return copy to prevent mutation
      return { ...user }
    },

    updateUser(id, userData) {
      if (!users.has(id)) {
        throw new Error('User not found')
      }
      validateUser(userData)
      users.set(id, { ...userData, id })
    },

    getUserCount() {
      return users.size
    },
  }
}

const userModule = createUserModule()
const id = userModule.addUser({ name: 'John', email: 'john@example.com' })
console.log(userModule.getUser(id))
console.log(userModule.getUserCount())
```

### Memoization with Closures

Cache expensive function results:

```javascript
function memoize(fn, customKeyFn) {
  const cache = new Map()

  return function (...args) {
    const key = customKeyFn ? customKeyFn(...args) : JSON.stringify(args)

    if (cache.has(key)) {
      console.log('Cache hit')
      return cache.get(key)
    }

    console.log('Cache miss')
    const result = fn.apply(this, args)
    cache.set(key, result)
    return result
  }
}

// Example: Expensive calculation
const expensiveOperation = memoize((n) => {
  console.log('Calculating...')
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(n * 2)
    }, 1000)
  })
})

// Example: Complex object memoization
const processUser = memoize(
  async (user) => {
    // Expensive processing...
    return { ...user, processed: true }
  },
  // Custom key function for objects
  (user) => user.id,
)
```

### Event Handling with Closures

Manage event listeners and prevent memory leaks:

```javascript
function createEventManager() {
  const listeners = new WeakMap()

  function getOrCreateListeners(element) {
    if (!listeners.has(element)) {
      listeners.set(element, new Map())
    }
    return listeners.get(element)
  }

  return {
    addListener(element, event, callback, options = {}) {
      const elementListeners = getOrCreateListeners(element)

      if (!elementListeners.has(event)) {
        elementListeners.set(event, new Set())
      }

      const eventListeners = elementListeners.get(event)
      const wrappedCallback = options.once
        ? (...args) => {
            callback(...args)
            this.removeListener(element, event, callback)
          }
        : callback

      eventListeners.add(wrappedCallback)
      element.addEventListener(event, wrappedCallback, options)
    },

    removeListener(element, event, callback) {
      const elementListeners = listeners.get(element)
      if (!elementListeners) return

      const eventListeners = elementListeners.get(event)
      if (!eventListeners) return

      eventListeners.delete(callback)
      element.removeEventListener(event, callback)

      if (eventListeners.size === 0) {
        elementListeners.delete(event)
      }

      if (elementListeners.size === 0) {
        listeners.delete(element)
      }
    },

    once(element, event, callback) {
      this.addListener(element, event, callback, { once: true })
    },
  }
}

const eventManager = createEventManager()

// Usage example
const button = document.querySelector('button')
const handler = () => console.log('Clicked!')

eventManager.addListener(button, 'click', handler)
eventManager.once(button, 'click', () => console.log('Once!'))
```

# Understanding Scope and Closures: Part 3 - Async Patterns, Performance, and Architecture

## Asynchronous Patterns with Closures

### State Management in Async Operations

Managing state across async operations is one of the most powerful uses of closures:

```javascript
function createAsyncManager() {
  let isPending = false
  let queue = []

  async function processQueue() {
    if (isPending || queue.length === 0) return

    isPending = true
    const task = queue[0]

    try {
      const result = await task.operation()
      task.resolve(result)
    } catch (error) {
      task.reject(error)
    } finally {
      isPending = false
      queue.shift()
      processQueue()
    }
  }

  return {
    addTask(operation) {
      return new Promise((resolve, reject) => {
        queue.push({ operation, resolve, reject })
        processQueue()
      })
    },

    get pendingTasks() {
      return queue.length
    },

    get isProcessing() {
      return isPending
    },
  }
}

// Usage example
const asyncManager = createAsyncManager()

asyncManager
  .addTask(async () => {
    await new Promise((resolve) => setTimeout(resolve, 1000))
    return 'Task 1 Complete'
  })
  .then(console.log)

asyncManager
  .addTask(async () => {
    await new Promise((resolve) => setTimeout(resolve, 500))
    return 'Task 2 Complete'
  })
  .then(console.log)
```

### Cancellable Async Operations

Create async operations that can be cancelled:

```javascript
function createCancellableAsync() {
  const pendingOperations = new Map()

  function generateToken() {
    return Math.random().toString(36).slice(2)
  }

  return {
    async execute(asyncOperation) {
      const token = generateToken()
      let isCancelled = false

      const promise = new Promise(async (resolve, reject) => {
        pendingOperations.set(token, () => {
          isCancelled = true
          reject(new Error('Operation cancelled'))
        })

        try {
          const result = await asyncOperation(
            () => isCancelled, // Check if cancelled
          )
          if (!isCancelled) {
            resolve(result)
          }
        } catch (error) {
          if (!isCancelled) {
            reject(error)
          }
        } finally {
          pendingOperations.delete(token)
        }
      })

      return {
        token,
        promise,
      }
    },

    cancel(token) {
      const cancel = pendingOperations.get(token)
      if (cancel) {
        cancel()
        return true
      }
      return false
    },
  }
}

// Usage example
const asyncHandler = createCancellableAsync()

async function longRunningTask(isCancelled) {
  for (let i = 0; i < 5; i++) {
    if (isCancelled()) {
      throw new Error('Task cancelled')
    }
    await new Promise((resolve) => setTimeout(resolve, 1000))
    console.log(`Step ${i + 1}`)
  }
  return 'Complete'
}

const { token, promise } = asyncHandler.execute(longRunningTask)

// Cancel after 2.5 seconds
setTimeout(() => {
  asyncHandler.cancel(token)
}, 2500)
```

## Performance and Memory Management

### Smart Reference Management

Prevent memory leaks while maintaining functionality:

```javascript
function createSmartCache() {
  const cache = new WeakMap()
  const accessTimes = new WeakMap()
  const maxAge = 5 * 60 * 1000 // 5 minutes

  // Periodic cleanup
  setInterval(() => {
    const now = Date.now()
    accessTimes.forEach((time, key) => {
      if (now - time > maxAge) {
        cache.delete(key)
        accessTimes.delete(key)
      }
    })
  }, 60000) // Check every minute

  return {
    set(key, value) {
      if (typeof key !== 'object') {
        throw new Error('Key must be an object')
      }
      cache.set(key, value)
      accessTimes.set(key, Date.now())
    },

    get(key) {
      const value = cache.get(key)
      if (value) {
        accessTimes.set(key, Date.now())
      }
      return value
    },

    delete(key) {
      cache.delete(key)
      accessTimes.delete(key)
    },
  }
}
```

### Optimizing Closure Memory Usage

Techniques for efficient closure usage:

```javascript
// BAD: Capturing unnecessary variables
function createBadCounter() {
  const hugeArray = new Array(1000000)
  const unnecessary = "I'm not needed"

  return () => hugeArray.length
}

// GOOD: Minimal closure scope
function createGoodCounter() {
  let count = 0

  return () => ++count
}

// BETTER: Reusable closure with cleanup
function createCleanableCounter() {
  let count = 0
  let intervalId = null

  const counter = {
    start() {
      if (intervalId) return
      intervalId = setInterval(() => {
        console.log(++count)
      }, 1000)
    },

    stop() {
      if (intervalId) {
        clearInterval(intervalId)
        intervalId = null
      }
    },

    reset() {
      count = 0
    },

    cleanup() {
      this.stop()
      count = 0
      // Remove references
      Object.keys(this).forEach((key) => {
        this[key] = null
      })
    },
  }

  return counter
}
```

## Architectural Patterns Using Closures

### Observable Pattern Implementation

Create a robust observable system:

```javascript
function createObservable() {
  const observers = new Map()

  return {
    subscribe(event, callback, options = {}) {
      if (!observers.has(event)) {
        observers.set(event, new Set())
      }

      const subscribers = observers.get(event)
      const subscriber = {
        callback,
        options,
        unsubscribe: () => {
          subscribers.delete(subscriber)
          if (subscribers.size === 0) {
            observers.delete(event)
          }
        },
      }

      subscribers.add(subscriber)
      return subscriber
    },

    publish(event, data) {
      const subscribers = observers.get(event)
      if (!subscribers) return

      subscribers.forEach((subscriber) => {
        try {
          subscriber.callback(data)
          if (subscriber.options.once) {
            subscriber.unsubscribe()
          }
        } catch (error) {
          console.error('Error in subscriber:', error)
        }
      })
    },

    clear(event) {
      if (event) {
        observers.delete(event)
      } else {
        observers.clear()
      }
    },
  }
}

// Usage example
const store = createObservable()

// Subscribe to events
const userSubscription = store.subscribe('userUpdate', (user) =>
  console.log('User updated:', user),
)

// One-time subscription
store.subscribe('startup', () => console.log('Application started'), {
  once: true,
})

// Publish events
store.publish('userUpdate', { id: 1, name: 'John' })
```

### Service Locator Pattern

Manage dependencies using closures:

```javascript
function createServiceLocator() {
  const services = new Map()
  const singletons = new Map()

  return {
    register(name, factory, options = {}) {
      if (services.has(name)) {
        throw new Error(`Service ${name} already registered`)
      }

      services.set(name, {
        factory,
        singleton: options.singleton || false,
        dependencies: options.dependencies || [],
      })
    },

    get(name) {
      const service = services.get(name)
      if (!service) {
        throw new Error(`Service ${name} not found`)
      }

      if (service.singleton) {
        if (!singletons.has(name)) {
          singletons.set(name, this.createInstance(service))
        }
        return singletons.get(name)
      }

      return this.createInstance(service)
    },

    createInstance(service) {
      const dependencies = service.dependencies.map((dep) => this.get(dep))
      return service.factory(...dependencies)
    },
  }
}

// Usage example
const locator = createServiceLocator()

// Register services
locator.register(
  'config',
  () => ({
    apiUrl: 'https://api.example.com',
  }),
  { singleton: true },
)

locator.register(
  'api',
  (config) => ({
    fetch: () => fetch(config.apiUrl),
  }),
  {
    dependencies: ['config'],
  },
)

// Get services
const api = locator.get('api')
```

These patterns demonstrate the power of closures in creating robust, maintainable, and performant applications. They enable powerful architectural patterns while maintaining clean interfaces and proper encapsulation.

Remember to always consider the memory implications of closures and clean up references when they're no longer needed, especially in long-running applications or when dealing with event listeners and timers.
