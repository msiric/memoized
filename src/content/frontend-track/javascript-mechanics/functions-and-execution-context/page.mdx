# Understanding Functions & Execution Context

## The Mental Model

### Functions as Building Recipes

Think of JavaScript functions like cooking recipes:

1. **Recipe Book (Code File)**

   - Contains multiple recipes (function definitions)
   - Each recipe has ingredients (parameters) and steps (function body)
   - Recipes can be referenced by name (function declarations) or created on the spot (function expressions)

2. **Kitchen (Execution Context)**
   - Workspace where recipes are executed
   - Has access to local ingredients (local variables)
   - Can access pantry items (outer scope variables)
   - Follows specific preparation rules (hoisting, TDZ)

### The Kitchen Hierarchy

Every time you execute a function, JavaScript creates a new "kitchen" (execution context) with:

1. **Prep Station (Variable Environment)**

   - Local ingredients (variables)
   - Equipment (function declarations)
   - Recipe notes (parameters)

2. **Recipe Book Stand (Scope Chain)**
   - Access to current recipe
   - Access to outer kitchen's ingredients
   - Access to global pantry

## Function Types in JavaScript

### 1. Function Declarations

The classic, hoisted function definition:

```javascript
// This is available everywhere in its scope
function bakeChocolateCake(ingredients) {
  return `Cake made with ${ingredients.join(', ')}`
}
```

Key characteristics:

- Hoisted (available before declaration)
- Creates properties on window/global in non-strict mode
- Has their own `this` binding
- Can be named or anonymous

### 2. Function Expressions

Functions defined as part of an expression:

```javascript
// Only available after declaration
const bakeCake = function (ingredients) {
  return `Cake made with ${ingredients.join(', ')}`
}

// Named function expression
const bakeSpecialCake = function specialCake(ingredients) {
  // specialCake name only available inside the function
  return `Special cake with ${ingredients.join(', ')}`
}
```

Key characteristics:

- Not hoisted
- Can be named (useful for recursion and debugging)
- Has their own `this` binding
- More flexible than declarations (can be passed as values)

### 3. Arrow Functions

Modern, more concise function syntax:

```javascript
const bakeCake = (ingredients) => `Cake with ${ingredients.join(', ')}`

// Multiple parameters need parentheses
const bakeFancyCake = (ingredients, decorations) => {
  const cake = `Cake with ${ingredients.join(', ')}`
  return `${cake}, decorated with ${decorations}`
}
```

Key characteristics:

- No own `this` binding (inherits from parent scope)
- No `arguments` object
- Cannot be used as constructors
- Great for method callbacks where `this` should be preserved

## Understanding Execution Context

### The Creation Phase

When JavaScript prepares to run code, it sets up the execution context:

1. **Creation of Variable Environment**

```javascript
function prepareCake() {
  // During creation phase:
  // 1. Function declarations are hoisted
  // 2. Variables are declared (but not assigned)
  // 3. Arguments object is created

  console.log(mixer) // undefined (hoisted)
  console.log(recipe) // Reference Error (in TDZ)

  var mixer = 'KitchenAid'
  let recipe = 'Chocolate Cake'
}
```

2. **Scope Chain Establishment**

```javascript
const bakery = {
  ingredients: ['flour', 'sugar'],

  prepareCake() {
    // Scope chain established:
    // prepareCake → bakery → global

    function mix() {
      // Scope chain:
      // mix → prepareCake → bakery → global
      console.log(this.ingredients)
    }

    mix() // undefined (this is not inherited)
  },
}
```

### The Execution Phase

Code runs with the prepared context:

```javascript
function outer() {
  // Execution context 1
  const a = 1

  function inner() {
    // Execution context 2
    const b = 2
    console.log(a + b) // Can access 'a' via scope chain
  }

  inner() // Creates new execution context
}

outer() // Creates new execution context
```

### The Call Stack

JavaScript maintains a call stack of execution contexts:

```javascript
function first() {
  console.log('Starting first')
  second()
  console.log('Ending first')
}

function second() {
  console.log('Starting second')
  third()
  console.log('Ending second')
}

function third() {
  console.log('In third')
}

// Call stack progression:
// 1. Global context
// 2. first() added
// 3. second() added
// 4. third() added
// 5. third() removed
// 6. second() removed
// 7. first() removed
// 8. Only global remains

first()
```

### Variable Lifecycle

Understanding how variables live in the execution context:

```javascript
// 1. Hoisting Phase
console.log(hoisted) // undefined
console.log(notHoisted) // ReferenceError
console.log(alsoTDZ) // ReferenceError

var hoisted = 'I am hoisted'
let notHoisted = 'I am in TDZ'
const alsoTDZ = 'I am also in TDZ'

// 2. TDZ (Temporal Dead Zone)
{
  // TDZ starts for 'name'
  console.log(name) // ReferenceError

  let name = 'John' // TDZ ends
  console.log(name) // Works fine
}
```

# Advanced Function Patterns

## Higher-Order Functions

### Understanding Higher-Order Functions

A higher-order function either:

- Takes one or more functions as arguments
- Returns a function
- Or both

Think of higher-order functions like master chefs who can:

- Take other chefs' recipes as input
- Create and return new recipes
- Modify existing recipes to create new ones

### Common Higher-Order Function Patterns

1. **Function Decorator Pattern**

```javascript
function withLogging(fn) {
  return function (...args) {
    console.log(`Calling function with args:`, args)
    const result = fn.apply(this, args)
    console.log(`Function returned:`, result)
    return result
  }
}

// Usage example
const add = (a, b) => a + b
const loggedAdd = withLogging(add)

loggedAdd(2, 3)
// Logs:
// Calling function with args: [2, 3]
// Function returned: 5
```

2. **Partial Application**

```javascript
function partial(fn, ...presetArgs) {
  return function (...laterArgs) {
    return fn.apply(this, [...presetArgs, ...laterArgs])
  }
}

// Usage example
function greet(greeting, name) {
  return `${greeting}, ${name}!`
}

const sayHello = partial(greet, 'Hello')
console.log(sayHello('John')) // "Hello, John!"
```

## Function Composition

### The Composition Mental Model

Think of function composition like an assembly line:

- Each function is a station that processes input
- Output from one station becomes input for the next
- The final product is the result of all transformations

### Implementing Composition

1. **Basic Composition**

```javascript
function compose(...fns) {
  return function (initialValue) {
    return fns.reduceRight((value, fn) => fn(value), initialValue)
  }
}

// Usage example
const addOne = (x) => x + 1
const double = (x) => x * 2
const square = (x) => x * x

const compute = compose(square, double, addOne)
console.log(compute(2)) // ((2 + 1) * 2)² = 36
```

2. **Point-Free Style**

```javascript
const processUser = compose(
  displayUser,
  validateUser,
  normalizeUser,
  sanitizeInput,
)

// Instead of:
function processUser(input) {
  const sanitized = sanitizeInput(input)
  const normalized = normalizeUser(sanitized)
  const validated = validateUser(normalized)
  return displayUser(validated)
}
```

## Currying

### Understanding Currying

Currying transforms a function that takes multiple arguments into a series of functions that each take a single argument.

Think of it like preparing ingredients separately before combining them:

```javascript
// Regular function
function makeShake(fruit, liquid, sweetener) {
  return `${fruit} shake with ${liquid} and ${sweetener}`
}

// Curried version
const makeShakeCurried = (fruit) => (liquid) => (sweetener) =>
  `${fruit} shake with ${liquid} and ${sweetener}`
```

### Implementing Currying

1. **Basic Curry Implementation**

```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args)
    }

    return function (...moreArgs) {
      return curried.apply(this, [...args, ...moreArgs])
    }
  }
}

// Usage example
const add = curry((a, b, c) => a + b + c)

console.log(add(1)(2)(3)) // 6
console.log(add(1, 2)(3)) // 6
console.log(add(1)(2, 3)) // 6
```

2. **Advanced Curry with Placeholders**

```javascript
const _ = Symbol('placeholder')

function advancedCurry(fn) {
  return function curried(...args) {
    const hasPlaceholder = args.includes(_)

    if (args.length >= fn.length && !hasPlaceholder) {
      return fn.apply(this, args)
    }

    return function (...moreArgs) {
      const newArgs = args.map((arg) => (arg === _ ? moreArgs.shift() : arg))
      return curried.apply(this, [...newArgs, ...moreArgs])
    }
  }
}

// Usage example
const format = advancedCurry((a, b, c) => `${a}-${b}-${c}`)

console.log(format(1, _, 3)(2)) // "1-2-3"
console.log(format(_, 2, _)(1, 3)) // "1-2-3"
```

## Advanced Execution Context Patterns

### The Module Pattern

Creating private scope and encapsulation:

```javascript
const Counter = (function () {
  // Private variables
  let count = 0

  // Private functions
  function validate(n) {
    return typeof n === 'number' && n >= 0
  }

  // Public interface
  return {
    increment() {
      return ++count
    },

    decrement() {
      return --count
    },

    setCount(n) {
      if (validate(n)) {
        count = n
        return count
      }
      throw new Error('Invalid count value')
    },

    getCount() {
      return count
    },
  }
})()
```

### The Revealing Module Pattern

A cleaner variation of the module pattern:

```javascript
const UserManager = (function () {
  // Private state
  const users = new Map()

  // Private functions
  function validateUser(user) {
    return user && user.name && user.email
  }

  function createUser(user) {
    if (!validateUser(user)) {
      throw new Error('Invalid user data')
    }
    users.set(user.email, user)
    return user
  }

  function getUser(email) {
    return users.get(email)
  }

  function updateUser(email, updates) {
    const user = getUser(email)
    if (!user) throw new Error('User not found')

    Object.assign(user, updates)
    return user
  }

  // Reveal public interface
  return {
    createUser,
    getUser,
    updateUser,
  }
})()
```

### Function Memoization

Caching function results for performance:

```javascript
function memoize(fn) {
  const cache = new Map()

  return function (...args) {
    const key = JSON.stringify(args)

    if (cache.has(key)) {
      console.log('Cache hit')
      return cache.get(key)
    }

    console.log('Cache miss')
    const result = fn.apply(this, args)
    cache.set(key, result)
    return result
  }
}

// Usage example
const expensiveOperation = memoize((n) => {
  console.log('Computing...')
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(n * 2)
    }, 1000)
  })
})
```

# Practical Implementations and Real-World Applications

## Building a Function Utility Library

### Function Composition Utilities

1. **Enhanced Compose with Error Handling**

```javascript
function safeCompose(...fns) {
  return function (initialValue) {
    return fns.reduceRight((promise, fn) => {
      return Promise.resolve(promise).then((value) => {
        try {
          return fn(value)
        } catch (error) {
          error.functionName = fn.name
          throw error
        }
      })
    }, initialValue)
  }
}

// Usage example
const processUserData = safeCompose(
  displayUser,
  validateUserData,
  normalizeUserInput,
  parseUserData,
)

try {
  await processUserData(rawData)
} catch (error) {
  console.error(`Error in ${error.functionName}:`, error.message)
}
```

2. **Pipe for Left-to-Right Composition**

```javascript
function pipe(...fns) {
  return function (initialValue) {
    return fns.reduce((value, fn) => fn(value), initialValue)
  }
}

// Enhanced version with types and error boundaries
function typeSafePipe(...fns) {
  return function (initialValue) {
    return fns.reduce((value, fn) => {
      // Type checking
      if (typeof fn !== 'function') {
        throw new TypeError(`Expected function, got ${typeof fn}`)
      }

      try {
        return fn(value)
      } catch (error) {
        error.inputValue = value
        error.transformer = fn.name
        throw error
      }
    }, initialValue)
  }
}
```

### Function Decorators for Common Use Cases

1. **Retry Decorator**

```javascript
function withRetry(fn, { retries = 3, delay = 1000 } = {}) {
  return async function (...args) {
    let lastError

    for (let attempt = 0; attempt < retries; attempt++) {
      try {
        return await fn.apply(this, args)
      } catch (error) {
        lastError = error

        if (attempt < retries - 1) {
          await new Promise((resolve) => setTimeout(resolve, delay))
        }
      }
    }

    throw new Error(`Failed after ${retries} attempts: ${lastError}`)
  }
}

// Usage example
const fetchWithRetry = withRetry(fetch, {
  retries: 3,
  delay: 1000,
})
```

2. **Throttle and Debounce**

```javascript
function throttle(fn, limit) {
  let inThrottle

  return function (...args) {
    if (!inThrottle) {
      fn.apply(this, args)
      inThrottle = true
      setTimeout(() => (inThrottle = false), limit)
    }
  }
}

function debounce(fn, wait) {
  let timeout

  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      fn.apply(this, args)
    }

    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// Usage example
const resizeHandler = throttle(() => {
  // Handle resize
}, 250)

const searchHandler = debounce((query) => {
  // Perform search
}, 300)
```

## Real-World Implementation Patterns

### State Management Pattern

```javascript
function createStore(reducer, initialState = {}) {
  let state = initialState
  const listeners = new Set()

  return {
    getState() {
      return state
    },

    dispatch(action) {
      state = reducer(state, action)
      listeners.forEach((listener) => listener(state))
    },

    subscribe(listener) {
      listeners.add(listener)
      return () => listeners.delete(listener)
    },
  }
}

// Usage example
const todosReducer = (state = [], action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return [...state, action.payload]
    case 'REMOVE_TODO':
      return state.filter((todo) => todo.id !== action.payload)
    default:
      return state
  }
}

const store = createStore(todosReducer, [])
```

### Event Emitter Pattern

```javascript
class EventEmitter {
  constructor() {
    this.events = new Map()
  }

  on(event, callback) {
    if (!this.events.has(event)) {
      this.events.set(event, new Set())
    }

    const handlers = this.events.get(event)
    handlers.add(callback)

    return () => {
      handlers.delete(callback)
      if (handlers.size === 0) {
        this.events.delete(event)
      }
    }
  }

  emit(event, ...args) {
    const handlers = this.events.get(event)
    if (handlers) {
      handlers.forEach((handler) => {
        try {
          handler.apply(this, args)
        } catch (error) {
          console.error(`Error in event handler for ${event}:`, error)
        }
      })
    }
  }

  once(event, callback) {
    const unsubscribe = this.on(event, (...args) => {
      unsubscribe()
      callback.apply(this, args)
    })
    return unsubscribe
  }
}
```

### Middleware Pattern

```javascript
function createMiddleware() {
  const middleware = []

  return {
    use(fn) {
      middleware.push(fn)
      return this
    },

    execute(context) {
      let index = -1

      function dispatch(i) {
        if (i <= index) {
          return Promise.reject(new Error('next() called multiple times'))
        }

        index = i
        const fn = middleware[i]

        if (!fn) {
          return Promise.resolve()
        }

        try {
          return Promise.resolve(fn(context, () => dispatch(i + 1)))
        } catch (error) {
          return Promise.reject(error)
        }
      }

      return dispatch(0)
    },
  }
}

// Usage example
const app = createMiddleware()

app.use(async (ctx, next) => {
  console.log('Start')
  await next()
  console.log('End')
})

app.use(async (ctx, next) => {
  ctx.data = await fetchData()
  await next()
})

app.execute({ req: {}, res: {} })
```

### Observable Pattern

```javascript
class Observable {
  constructor(subscribe) {
    this._subscribe = subscribe
  }

  subscribe(next, error, complete) {
    const observer =
      typeof next === 'function' ? { next, error, complete } : next

    return this._subscribe(observer)
  }

  map(fn) {
    return new Observable((observer) => {
      return this.subscribe({
        next: (value) => observer.next(fn(value)),
        error: (err) => observer.error(err),
        complete: () => observer.complete(),
      })
    })
  }

  filter(predicate) {
    return new Observable((observer) => {
      return this.subscribe({
        next: (value) => {
          if (predicate(value)) {
            observer.next(value)
          }
        },
        error: (err) => observer.error(err),
        complete: () => observer.complete(),
      })
    })
  }
}

// Usage example
const numbers = new Observable((observer) => {
  let count = 0
  const id = setInterval(() => {
    observer.next(count++)
    if (count > 10) {
      clearInterval(id)
      observer.complete()
    }
  }, 1000)

  return () => clearInterval(id)
})

const subscription = numbers
  .filter((n) => n % 2 === 0)
  .map((n) => n * 2)
  .subscribe({
    next: (value) => console.log(value),
    complete: () => console.log('Done'),
  })
```

These patterns demonstrate how to use functions and execution contexts to create robust, maintainable applications. They provide solutions to common problems while maintaining clean, functional code organization.
