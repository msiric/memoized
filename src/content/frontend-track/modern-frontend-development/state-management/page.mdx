# Understanding State Management

## Mental Model of State

Think of state management like organizing a library:

- Local state is like personal bookshelves (component-specific)
- Global state is like the central catalog (application-wide)
- State updates are like librarians updating records
- State synchronization is like keeping multiple branches in sync

### State Categories

1. **UI State**

```typescript
// Component-level UI state
function Accordion() {
    const [isOpen, setIsOpen] = useState(false);

    return (
        <div>
            <button onClick={() => setIsOpen(!isOpen)}>
                {isOpen ? 'Close' : 'Open'}
            </button>
            {isOpen && <div>Content</div>}
        </div>
    );
}
```

2. **Application State**

```typescript
// Shared business logic state
interface User {
  id: string
  name: string
  preferences: UserPreferences
}

interface UserPreferences {
  theme: 'light' | 'dark'
  notifications: boolean
}

function useUserState() {
  const [user, setUser] = useState<User | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<Error | null>(null)

  // State updates with error handling
  const updatePreferences = async (preferences: Partial<UserPreferences>) => {
    try {
      setLoading(true)
      const updated = await updateUserPreferences(preferences)
      setUser((prev) =>
        prev
          ? {
              ...prev,
              preferences: updated,
            }
          : null,
      )
    } catch (err) {
      setError(err as Error)
    } finally {
      setLoading(false)
    }
  }

  return {
    user,
    loading,
    error,
    updatePreferences,
  }
}
```

## Local vs Global State

### Local State Patterns

1. **Component State**

```typescript
interface FormState {
    values: Record<string, string>;
    touched: Set<string>;
    errors: Record<string, string>;
}

function Form() {
    const [state, setState] = useState<FormState>({
        values: {},
        touched: new Set(),
        errors: {}
    });

    const updateField = (name: string, value: string) => {
        setState(prev => ({
            ...prev,
            values: {
                ...prev.values,
                [name]: value
            },
            touched: new Set([...prev.touched, name])
        }));
    };

    return (
        <form>
            <input
                onChange={e => updateField('name', e.target.value)}
                value={state.values.name || ''}
            />
        </form>
    );
}
```

2. **Derived State**

```typescript
interface TodoItem {
    id: string;
    text: string;
    completed: boolean;
}

function TodoList() {
    const [items, setItems] = useState<TodoItem[]>([]);

    // Derived state
    const completedCount = useMemo(() =>
        items.filter(item => item.completed).length,
        [items]
    );

    const incompleteCount = useMemo(() =>
        items.length - completedCount,
        [items, completedCount]
    );

    const progress = useMemo(() =>
        items.length ? (completedCount / items.length) * 100 : 0,
        [items.length, completedCount]
    );

    return (
        <div>
            <ProgressBar value={progress} />
            <div>Remaining: {incompleteCount}</div>
            <div>Completed: {completedCount}</div>
        </div>
    );
}
```

### Global State Considerations

1. **State Location Assessment**

```typescript
// Questions to ask when deciding state location:
// 1. How many components need this state?
// 2. How often does the state change?
// 3. What's the performance impact of state updates?

// Local state example (used by single component)
function Counter() {
    const [count, setCount] = useState(0);
    return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}

// Lifted state example (shared by sibling components)
function ParentComponent() {
    const [selectedId, setSelectedId] = useState<string | null>(null);

    return (
        <>
            <Sidebar selectedId={selectedId} onSelect={setSelectedId} />
            <Content selectedId={selectedId} />
        </>
    );
}

// Global state example (used across the application)
interface AuthState {
    user: User | null;
    isAuthenticated: boolean;
    loading: boolean;
}

const AuthContext = createContext<AuthState | undefined>(undefined);

function AuthProvider({ children }: { children: React.ReactNode }) {
    const [state, setState] = useState<AuthState>({
        user: null,
        isAuthenticated: false,
        loading: true
    });

    // ... authentication logic

    return (
        <AuthContext.Provider value={state}>
            {children}
        </AuthContext.Provider>
    );
}
```

2. **State Granularity**

```typescript
// Too coarse-grained
interface GlobalState {
  entireApplicationState: {
    user: User
    settings: Settings
    posts: Post[]
    comments: Comment[]
  }
}

// Better: Split into domains
interface UserState {
  user: User | null
  settings: UserSettings
}

interface ContentState {
  posts: Post[]
  selectedPostId: string | null
}

interface UIState {
  theme: Theme
  sidebar: {
    isOpen: boolean
    width: number
  }
}
```

### State Update Patterns

1. **Immutable Updates**

```typescript
interface Todo {
  id: string
  text: string
  completed: boolean
  tags: string[]
}

// Bad: Mutating state directly
function badUpdateTodo(todos: Todo[], id: string) {
  const todo = todos.find((t) => t.id === id)
  if (todo) {
    todo.completed = !todo.completed // Mutation!
  }
  return todos
}

// Good: Immutable updates
function goodUpdateTodo(todos: Todo[], id: string) {
  return todos.map((todo) =>
    todo.id === id ? { ...todo, completed: !todo.completed } : todo,
  )
}

// Complex nested updates
function updateTodoTag(
  todos: Todo[],
  todoId: string,
  tagIndex: number,
  newTag: string,
) {
  return todos.map((todo) =>
    todo.id === todoId
      ? {
          ...todo,
          tags: [
            ...todo.tags.slice(0, tagIndex),
            newTag,
            ...todo.tags.slice(tagIndex + 1),
          ],
        }
      : todo,
  )
}
```

# Building State Management Solutions

## Creating a Custom State Manager

### Basic Store Implementation

```typescript
type Listener<T> = (state: T) => void

class Store<T> {
  private state: T
  private listeners: Set<Listener<T>> = new Set()

  constructor(initialState: T) {
    this.state = initialState
  }

  getState(): T {
    return this.state
  }

  setState(newState: Partial<T> | ((prevState: T) => Partial<T>)) {
    const nextState = {
      ...this.state,
      ...(typeof newState === 'function' ? newState(this.state) : newState),
    }

    this.state = nextState
    this.notify()
  }

  subscribe(listener: Listener<T>): () => void {
    this.listeners.add(listener)
    return () => {
      this.listeners.delete(listener)
    }
  }

  private notify() {
    this.listeners.forEach((listener) => listener(this.state))
  }
}

// React Hook for the Store
function useStore<T>(store: Store<T>): T {
  const [state, setState] = useState(store.getState())

  useEffect(() => {
    return store.subscribe(setState)
  }, [store])

  return state
}
```

### Advanced Store Features

```typescript
type ActionCreator<T> = (...args: any[]) => Partial<T>
type Selector<T, R> = (state: T) => R

class AdvancedStore<T> extends Store<T> {
  private selectors: Map<Selector<T, any>, Set<Listener<any>>> = new Map()

  // Memoized selectors
  select<R>(selector: Selector<T, R>, listener: Listener<R>): () => void {
    if (!this.selectors.has(selector)) {
      this.selectors.set(selector, new Set())
    }

    const listeners = this.selectors.get(selector)!
    listeners.add(listener)

    // Initial call
    listener(selector(this.getState()))

    return () => {
      listeners.delete(listener)
      if (listeners.size === 0) {
        this.selectors.delete(selector)
      }
    }
  }

  // Action creators
  action<A extends ActionCreator<T>>(
    creator: A,
  ): (...args: Parameters<A>) => void {
    return (...args: Parameters<A>) => {
      this.setState(creator(...args))
    }
  }

  protected notify() {
    super.notify()

    // Notify selector listeners
    this.selectors.forEach((listeners, selector) => {
      const value = selector(this.getState())
      listeners.forEach((listener) => listener(value))
    })
  }
}

// Usage with React
interface AppState {
  user: User | null
  theme: 'light' | 'dark'
  notifications: Notification[]
}

const store = new AdvancedStore<AppState>({
  user: null,
  theme: 'light',
  notifications: [],
})

// Custom hook for selecting state
function useSelector<R>(selector: Selector<AppState, R>): R {
  const [value, setValue] = useState(() => selector(store.getState()))

  useEffect(() => {
    return store.select(selector, setValue)
  }, [selector])

  return value
}
```

## State Synchronization Patterns

### Client-Server Synchronization

```typescript
interface SyncOptions<T> {
  onSync?: (state: T) => void
  onError?: (error: Error) => void
  debounceMs?: number
}

class SynchronizedStore<T> extends AdvancedStore<T> {
  private syncTimeout: NodeJS.Timeout | null = null
  private syncInProgress = false

  constructor(
    initialState: T,
    private syncFn: (state: T) => Promise<void>,
    private options: SyncOptions<T> = {},
  ) {
    super(initialState)
  }

  setState(newState: Partial<T> | ((prevState: T) => Partial<T>)) {
    super.setState(newState)
    this.scheduleSync()
  }

  private async sync() {
    if (this.syncInProgress) return

    try {
      this.syncInProgress = true
      await this.syncFn(this.getState())
      this.options.onSync?.(this.getState())
    } catch (error) {
      this.options.onError?.(error as Error)
    } finally {
      this.syncInProgress = false
    }
  }

  private scheduleSync() {
    if (this.syncTimeout) {
      clearTimeout(this.syncTimeout)
    }

    this.syncTimeout = setTimeout(
      () => this.sync(),
      this.options.debounceMs || 1000,
    )
  }
}

// Usage example
interface UserSettings {
  theme: 'light' | 'dark'
  notifications: boolean
  fontSize: number
}

const settingsStore = new SynchronizedStore<UserSettings>(
  {
    theme: 'light',
    notifications: true,
    fontSize: 14,
  },
  async (state) => {
    await fetch('/api/settings', {
      method: 'PUT',
      body: JSON.stringify(state),
    })
  },
  {
    debounceMs: 500,
    onError: (error) => {
      console.error('Failed to sync settings:', error)
    },
  },
)
```

### Real-Time Synchronization

```typescript
class RealtimeStore<T> extends AdvancedStore<T> {
    private socket: WebSocket;
    private pendingUpdates: Set<Promise<void>> = new Set();

    constructor(
        initialState: T,
        websocketUrl: string
    ) {
        super(initialState);
        this.socket = new WebSocket(websocketUrl);
        this.setupWebSocket();
    }

    private setupWebSocket() {
        this.socket.onmessage = (event) => {
            const update = JSON.parse(event.data);
            // Prevent circular updates
            this.suppressNotifications(() => {
                this.setState(update);
            });
        };

        this.socket.onclose = () => {
            // Reconnection logic
            setTimeout(() => this.setupWebSocket(), 1000);
        };
    }

    async setState(
        newState: Partial<T> | ((prevState: T) => Partial<T>)
    ) {
        super.setState(newState);

        // Broadcast change to other clients
        const updatePromise = this.broadcast(this.getState())
            .finally(() => {
                this.pendingUpdates.delete(updatePromise);
            });

        this.pendingUpdates.add(updatePromise);
    }

    private async broadcast(state: T): Promise<void> {
        if (this.socket.readyState === WebSocket.OPEN) {
            return new Promise((resolve, reject) => {
                this.socket.send(JSON.stringify({
                    type: 'STATE_UPDATE',
                    payload: state
                }));
                resolve();
            });
        }
    }

    // Wait for all pending updates to complete
    async flush(): Promise<void> {
        await Promise.all(this.pendingUpdates);
    }

    private suppressNotifications(fn: () => void) {
        const notify = this.notify;
        this.notify = () => {};
        fn();
        this.notify = notify;
    }
}

// Usage with React
const collaborativeStore = new RealtimeStore(
    initialState,
    'wss://api.example.com/realtime'
);

function CollaborativeEditor() {
    const state = useStore(collaborativeStore);

    return (
        <Editor
            value={state.content}
            onChange={(content) => {
                collaborativeStore.setState({ content });
            }}
        />
    );
}
```

# Practice Problems and Real-World Applications

## Problem 1: Building a Shopping Cart State Manager

```typescript
interface Product {
    id: string;
    name: string;
    price: number;
}

interface CartItem extends Product {
    quantity: number;
}

interface CartState {
    items: CartItem[];
    total: number;
    loading: boolean;
    error: Error | null;
}

class CartStore extends Store<CartState> {
    constructor() {
        super({
            items: [],
            total: 0,
            loading: false,
            error: null
        });
    }

    addItem = async (product: Product, quantity: number = 1) => {
        try {
            this.setState({ loading: true, error: null });

            // Simulate API call
            await new Promise(resolve => setTimeout(resolve, 500));

            this.setState(state => {
                const existingItem = state.items.find(
                    item => item.id === product.id
                );

                const items = existingItem
                    ? state.items.map(item =>
                        item.id === product.id
                            ? { ...item, quantity: item.quantity + quantity }
                            : item
                    )
                    : [...state.items, { ...product, quantity }];

                return {
                    items,
                    total: this.calculateTotal(items),
                    loading: false
                };
            });
        } catch (error) {
            this.setState({
                error: error as Error,
                loading: false
            });
        }
    };

    removeItem = (productId: string) => {
        this.setState(state => {
            const items = state.items.filter(
                item => item.id !== productId
            );
            return {
                items,
                total: this.calculateTotal(items)
            };
        });
    };

    updateQuantity = (productId: string, quantity: number) => {
        if (quantity < 0) return;

        this.setState(state => {
            const items = state.items.map(item =>
                item.id === productId
                    ? { ...item, quantity }
                    : item
            );
            return {
                items,
                total: this.calculateTotal(items)
            };
        });
    };

    private calculateTotal(items: CartItem[]): number {
        return items.reduce(
            (sum, item) => sum + item.price * item.quantity,
            0
        );
    }
}

// React components
function Cart() {
    const cart = useStore(cartStore);

    if (cart.loading) return <Spinner />;
    if (cart.error) return <ErrorMessage error={cart.error} />;

    return (
        <div>
            {cart.items.map(item => (
                <CartItem
                    key={item.id}
                    item={item}
                    onUpdateQuantity={cartStore.updateQuantity}
                    onRemove={cartStore.removeItem}
                />
            ))}
            <div>Total: ${cart.total.toFixed(2)}</div>
        </div>
    );
}
```

## Problem 2: Complex Form State Management

```typescript
interface FormField<T> {
    value: T;
    touched: boolean;
    error?: string;
    validators: ((value: T) => string | undefined)[];
}

type FormFields<T> = {
    [K in keyof T]: FormField<T[K]>;
};

class FormStore<T extends Record<string, any>> {
    private store: Store<FormFields<T>>;

    constructor(initialValues: T) {
        this.store = new Store(
            this.initializeFields(initialValues)
        );
    }

    private initializeFields(values: T): FormFields<T> {
        return Object.entries(values).reduce(
            (acc, [key, value]) => ({
                ...acc,
                [key]: {
                    value,
                    touched: false,
                    validators: []
                }
            }),
            {} as FormFields<T>
        );
    }

    setField<K extends keyof T>(
        field: K,
        value: T[K]
    ) {
        this.store.setState(state => ({
            [field]: {
                ...state[field],
                value,
                touched: true,
                error: this.validate(field, value)
            }
        }));
    }

    setValidators<K extends keyof T>(
        field: K,
        validators: ((value: T[K]) => string | undefined)[]
    ) {
        this.store.setState(state => ({
            [field]: {
                ...state[field],
                validators,
                error: this.validate(field, state[field].value)
            }
        }));
    }

    private validate<K extends keyof T>(
        field: K,
        value: T[K]
    ): string | undefined {
        const fieldState = this.store.getState()[field];
        return fieldState.validators.reduce(
            (error, validator) => error || validator(value),
            undefined as string | undefined
        );
    }

    validateAll(): boolean {
        const state = this.store.getState();
        let isValid = true;

        const newState = Object.entries(state).reduce(
            (acc, [key, field]) => {
                const error = this.validate(
                    key as keyof T,
                    field.value
                );
                isValid = isValid && !error;
                return {
                    ...acc,
                    [key]: {
                        ...field,
                        error,
                        touched: true
                    }
                };
            },
            {} as FormFields<T>
        );

        this.store.setState(newState);
        return isValid;
    }

    getValues(): T {
        const state = this.store.getState();
        return Object.entries(state).reduce(
            (acc, [key, field]) => ({
                ...acc,
                [key]: field.value
            }),
            {} as T
        );
    }

    reset(values?: Partial<T>) {
        const currentState = this.store.getState();
        const newState = Object.entries(currentState).reduce(
            (acc, [key, field]) => ({
                ...acc,
                [key]: {
                    ...field,
                    value: values?.[key] ?? field.value,
                    touched: false,
                    error: undefined
                }
            }),
            {} as FormFields<T>
        );

        this.store.setState(newState);
    }

    useField<K extends keyof T>(field: K) {
        return useSelector(this.store, state => state[field]);
    }
}

// Usage example
interface UserForm {
    email: string;
    password: string;
    confirmPassword: string;
}

const formStore = new FormStore<UserForm>({
    email: '',
    password: '',
    confirmPassword: ''
});

// Set up validators
formStore.setValidators('email', [
    email => !email ? 'Email is required' : undefined,
    email => !email.includes('@') ? 'Invalid email' : undefined
]);

formStore.setValidators('password', [
    password => !password ? 'Password is required' : undefined,
    password => password.length < 8
        ? 'Password must be at least 8 characters'
        : undefined
]);

formStore.setValidators('confirmPassword', [
    confirm => confirm !== formStore.getValues().password
        ? 'Passwords must match'
        : undefined
]);

function RegistrationForm() {
    const email = formStore.useField('email');
    const password = formStore.useField('password');
    const confirmPassword = formStore.useField('confirmPassword');

    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        if (formStore.validateAll()) {
            const values = formStore.getValues();
            // Submit values
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <FormField
                label="Email"
                value={email.value}
                error={email.error}
                onChange={value => formStore.setField('email', value)}
            />
            {/* Other fields */}
        </form>
    );
}
```

## Problem 3: Real-Time Collaboration State

```typescript
interface CollaborationState {
  document: {
    content: string
    version: number
  }
  cursors: {
    [userId: string]: {
      position: number
      selection: [number, number]
    }
  }
  users: {
    [userId: string]: {
      name: string
      color: string
      active: boolean
    }
  }
}

class CollaborationStore extends RealtimeStore<CollaborationState> {
  private userId: string
  private debounceTimeout: NodeJS.Timeout | null = null

  constructor(userId: string, documentId: string) {
    super(
      {
        document: {
          content: '',
          version: 0,
        },
        cursors: {},
        users: {},
      },
      `wss://api.example.com/docs/${documentId}`,
    )
    this.userId = userId
  }

  updateContent(content: string) {
    if (this.debounceTimeout) {
      clearTimeout(this.debounceTimeout)
    }

    this.debounceTimeout = setTimeout(() => {
      this.setState((state) => ({
        document: {
          content,
          version: state.document.version + 1,
        },
      }))
    }, 500)
  }

  updateCursor(position: number, selection: [number, number]) {
    this.setState((state) => ({
      cursors: {
        ...state.cursors,
        [this.userId]: {
          position,
          selection,
        },
      },
    }))
  }

  setUserActive(active: boolean) {
    this.setState((state) => ({
      users: {
        ...state.users,
        [this.userId]: {
          ...state.users[this.userId],
          active,
        },
      },
    }))
  }
}
```

These examples demonstrate:

1. Complex state management patterns
2. Real-world application architecture
3. Type-safe state updates
4. Performance considerations
5. Proper error handling
