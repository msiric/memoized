# Understanding Component Composition

## Mental Model: Building Blocks

Think of React components like LEGO pieces:

- Each piece has a specific purpose
- Pieces can be combined in different ways
- Small pieces make up larger structures
- Pieces communicate through well-defined connections

### Design Principles

1. **Single Responsibility**

   - Each component should do one thing well
   - Complex features should be broken down into smaller pieces
   - Easier to maintain, test, and reuse

2. **Composability**
   - Components should work well together
   - Clear interfaces between components
   - Flexible enough to handle different use cases

## Basic Composition Patterns

### 1. Container/Presentational Pattern

```typescript
// Presentational Component
interface UserProfileProps {
    name: string;
    email: string;
    avatar: string;
    onEdit: () => void;
}

const UserProfile: React.FC<UserProfileProps> = ({
    name,
    email,
    avatar,
    onEdit
}) => (
    <div className="user-profile">
        <img src={avatar} alt={name} />
        <h2>{name}</h2>
        <p>{email}</p>
        <button onClick={onEdit}>Edit Profile</button>
    </div>
);

// Container Component
const UserProfileContainer: React.FC = () => {
    const [user, setUser] = useState<User | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);

    useEffect(() => {
        fetchUser()
            .then(data => setUser(data))
            .catch(err => setError(err))
            .finally(() => setLoading(false));
    }, []);

    if (loading) return <Spinner />;
    if (error) return <ErrorMessage error={error} />;
    if (!user) return null;

    return (
        <UserProfile
            name={user.name}
            email={user.email}
            avatar={user.avatar}
            onEdit={() => {/* handle edit */}}
        />
    );
};
```

### 2. Compound Components

```typescript
interface TabsContext {
    activeTab: string;
    setActiveTab: (id: string) => void;
}

const TabsContext = React.createContext<TabsContext | undefined>(undefined);

interface TabsProps {
    defaultTab?: string;
    children: React.ReactNode;
    onChange?: (tabId: string) => void;
}

const Tabs: React.FC<TabsProps> & {
    Tab: typeof Tab;
    Panel: typeof Panel;
} = ({ defaultTab, children, onChange }) => {
    const [activeTab, setActiveTab] = useState(defaultTab);

    const handleTabChange = (tabId: string) => {
        setActiveTab(tabId);
        onChange?.(tabId);
    };

    return (
        <TabsContext.Provider
            value={{
                activeTab: activeTab!,
                setActiveTab: handleTabChange
            }}
        >
            <div className="tabs">{children}</div>
        </TabsContext.Provider>
    );
};

interface TabProps {
    id: string;
    children: React.ReactNode;
}

const Tab: React.FC<TabProps> = ({ id, children }) => {
    const context = useContext(TabsContext);
    if (!context) throw new Error('Tab must be used within Tabs');

    const { activeTab, setActiveTab } = context;

    return (
        <button
            className={`tab ${activeTab === id ? 'active' : ''}`}
            onClick={() => setActiveTab(id)}
        >
            {children}
        </button>
    );
};

interface PanelProps {
    id: string;
    children: React.ReactNode;
}

const Panel: React.FC<PanelProps> = ({ id, children }) => {
    const context = useContext(TabsContext);
    if (!context) throw new Error('Panel must be used within Tabs');

    const { activeTab } = context;

    if (activeTab !== id) return null;
    return <div className="tab-panel">{children}</div>;
};

// Attach child components
Tabs.Tab = Tab;
Tabs.Panel = Panel;

// Usage
const TabExample = () => (
    <Tabs defaultTab="tab1">
        <div className="tab-list">
            <Tabs.Tab id="tab1">Profile</Tabs.Tab>
            <Tabs.Tab id="tab2">Settings</Tabs.Tab>
        </div>
        <div className="tab-panels">
            <Tabs.Panel id="tab1">
                <UserProfile />
            </Tabs.Panel>
            <Tabs.Panel id="tab2">
                <UserSettings />
            </Tabs.Panel>
        </div>
    </Tabs>
);
```

### 3. Composition through Props

```typescript
interface CardProps {
    header?: React.ReactNode;
    footer?: React.ReactNode;
    children: React.ReactNode;
    className?: string;
}

const Card: React.FC<CardProps> = ({
    header,
    footer,
    children,
    className
}) => (
    <div className={`card ${className || ''}`}>
        {header && <div className="card-header">{header}</div>}
        <div className="card-body">{children}</div>
        {footer && <div className="card-footer">{footer}</div>}
    </div>
);

// More specialized cards
interface DataCardProps<T> {
    data: T;
    isLoading?: boolean;
    error?: Error | null;
    renderItem: (item: T) => React.ReactNode;
    renderError?: (error: Error) => React.ReactNode;
    renderLoading?: () => React.ReactNode;
}

function DataCard<T>({
    data,
    isLoading,
    error,
    renderItem,
    renderError = (err) => <div>Error: {err.message}</div>,
    renderLoading = () => <Spinner />
}: DataCardProps<T>) {
    return (
        <Card>
            {isLoading && renderLoading()}
            {error && renderError(error)}
            {!isLoading && !error && renderItem(data)}
        </Card>
    );
}

// Usage
const UserCard = () => (
    <DataCard
        data={userData}
        isLoading={loading}
        error={error}
        renderItem={(user) => (
            <>
                <h2>{user.name}</h2>
                <p>{user.email}</p>
            </>
        )}
    />
);
```

# Higher-Order Components (HOCs)

## Understanding HOCs

A Higher-Order Component is a function that takes a component and returns a new enhanced component. Think of them like component factories that add extra capabilities to existing components.

### Basic HOC Structure

```typescript
interface WithLoadingProps {
    loading?: boolean;
}

function withLoading<P extends object>(
    WrappedComponent: React.ComponentType<P>
) {
    return function WithLoadingComponent(
        props: P & WithLoadingProps
    ) {
        const { loading, ...componentProps } = props;

        if (loading) {
            return <div>Loading...</div>;
        }

        return <WrappedComponent {...(componentProps as P)} />;
    };
}

// Usage
interface UserListProps {
    users: User[];
    onUserSelect: (user: User) => void;
}

const UserList: React.FC<UserListProps> = ({ users, onUserSelect }) => (
    <ul>
        {users.map(user => (
            <li key={user.id} onClick={() => onUserSelect(user)}>
                {user.name}
            </li>
        ))}
    </ul>
);

const UserListWithLoading = withLoading(UserList);

// Now we can use it like this:
<UserListWithLoading
    loading={isLoading}
    users={users}
    onUserSelect={handleSelect}
/>
```

## Advanced HOC Patterns

### 1. Data Fetching HOC

```typescript
interface WithDataProps<T> {
    data?: T;
    loading?: boolean;
    error?: Error;
    refetch?: () => void;
}

function withData<T, P extends WithDataProps<T>>(
    WrappedComponent: React.ComponentType<P>,
    fetchData: () => Promise<T>
) {
    return function WithDataComponent(
        props: Omit<P, keyof WithDataProps<T>>
    ) {
        const [data, setData] = useState<T | undefined>();
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState<Error>();

        const fetch = useCallback(async () => {
            try {
                setLoading(true);
                const result = await fetchData();
                setData(result);
                setError(undefined);
            } catch (e) {
                setError(e as Error);
            } finally {
                setLoading(false);
            }
        }, []);

        useEffect(() => {
            fetch();
        }, [fetch]);

        const componentProps = {
            ...props,
            data,
            loading,
            error,
            refetch: fetch,
        } as P;

        return <WrappedComponent {...componentProps} />;
    };
}

// Usage
interface User {
    id: number;
    name: string;
}

interface UserProfileProps extends WithDataProps<User> {
    onEdit?: (user: User) => void;
}

const UserProfile: React.FC<UserProfileProps> = ({
    data: user,
    loading,
    error,
    refetch,
    onEdit
}) => {
    if (loading) return <div>Loading...</div>;
    if (error) return <div>Error: {error.message}</div>;
    if (!user) return null;

    return (
        <div>
            <h2>{user.name}</h2>
            <button onClick={() => onEdit?.(user)}>Edit</button>
            <button onClick={refetch}>Refresh</button>
        </div>
    );
};

const UserProfileWithData = withData(
    UserProfile,
    () => fetch('/api/user').then(r => r.json())
);
```

### 2. Authentication HOC

```typescript
interface WithAuthProps {
    user?: User;
    isAuthenticated: boolean;
}

function withAuth<P extends WithAuthProps>(
    WrappedComponent: React.ComponentType<P>,
    options: {
        redirectUrl?: string;
        requireAuth?: boolean;
    } = {}
) {
    return function WithAuthComponent(
        props: Omit<P, keyof WithAuthProps>
    ) {
        const { user, isAuthenticated } = useAuth(); // Your auth hook
        const navigate = useNavigate();  // React Router hook

        useEffect(() => {
            if (options.requireAuth && !isAuthenticated) {
                navigate(options.redirectUrl || '/login');
            }
        }, [isAuthenticated, navigate]);

        if (options.requireAuth && !isAuthenticated) {
            return null;
        }

        const componentProps = {
            ...props,
            user,
            isAuthenticated
        } as P;

        return <WrappedComponent {...componentProps} />;
    };
}

// Usage
interface DashboardProps extends WithAuthProps {
    onLogout: () => void;
}

const Dashboard: React.FC<DashboardProps> = ({
    user,
    isAuthenticated,
    onLogout
}) => (
    <div>
        <h1>Welcome, {user?.name}</h1>
        <button onClick={onLogout}>Logout</button>
    </div>
);

const AuthenticatedDashboard = withAuth(Dashboard, {
    requireAuth: true,
    redirectUrl: '/login'
});
```

### 3. Performance Optimization HOC

```typescript
interface WithMemoProps {
    memoKeys?: any[];
}

function withMemo<P extends object>(
    WrappedComponent: React.ComponentType<P>,
    areEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean
) {
    return React.memo(
        function WithMemoComponent(props: P & WithMemoProps) {
            const { memoKeys, ...componentProps } = props;
            return <WrappedComponent {...(componentProps as P)} />;
        },
        areEqual || ((prev, next) => {
            const { memoKeys: prevKeys, ...prevProps } = prev;
            const { memoKeys: nextKeys, ...nextProps } = next;

            if (!prevKeys || !nextKeys) {
                return false;
            }

            return prevKeys.every((key, index) =>
                key === nextKeys[index]
            );
        })
    );
}

// Usage
interface ExpensiveComponentProps {
    data: any[];
    onProcess: (data: any[]) => void;
}

const ExpensiveComponent: React.FC<ExpensiveComponentProps> = ({
    data,
    onProcess
}) => {
    // Expensive rendering logic here
    return (
        <div>
            {/* Complex UI */}
        </div>
    );
};

const MemoizedExpensiveComponent = withMemo(ExpensiveComponent);

// Now we can use it with memo keys
<MemoizedExpensiveComponent
    data={data}
    onProcess={processData}
    memoKeys={[data.length]}
/>
```

### Best Practices and Common Pitfalls

1. **Naming Convention**

```typescript
// Good: Clear naming that shows enhancement
const withAuth = <P extends object>(Component: ComponentType<P>) => {
  // Implementation
}

// Better: More descriptive of what it does
const withAuthProtection = <P extends object>(Component: ComponentType<P>) => {
  // Implementation
}
```

2. **Props Passthrough**

```typescript
// Bad: Props get lost
const withLoading = <P extends object>(Component: ComponentType<P>) => {
    return (props: P) => {
        // props are not properly typed or passed
        return <Component />;
    };
};

// Good: Proper props handling with type safety
const withLoading = <P extends object>(Component: ComponentType<P>) => {
    return (props: P & WithLoadingProps) => {
        const { loading, ...componentProps } = props;
        return <Component {...(componentProps as P)} />;
    };
};
```

# Render Props and Custom Hooks

## Render Props Pattern

### Understanding Render Props

A render prop is a function prop that a component uses to know what to render. This pattern enables great component reuse by separating behavior from rendering.

```typescript
interface DataSourceProps<T> {
    render: (data: {
        data: T | null;
        loading: boolean;
        error: Error | null;
        refetch: () => void;
    }) => React.ReactNode;
    fetchData: () => Promise<T>;
}

function DataSource<T>({ render, fetchData }: DataSourceProps<T>) {
    const [data, setData] = useState<T | null>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<Error | null>(null);

    const load = useCallback(async () => {
        try {
            setLoading(true);
            const result = await fetchData();
            setData(result);
            setError(null);
        } catch (e) {
            setError(e as Error);
        } finally {
            setLoading(false);
        }
    }, [fetchData]);

    useEffect(() => {
        load();
    }, [load]);

    return <>{render({ data, loading, error, refetch: load })}</>;
}

// Usage
interface User {
    id: number;
    name: string;
    email: string;
}

const UserProfile = () => (
    <DataSource<User>
        fetchData={() => fetch('/api/user').then(r => r.json())}
        render={({ data: user, loading, error, refetch }) => {
            if (loading) return <div>Loading...</div>;
            if (error) return <div>Error: {error.message}</div>;
            if (!user) return null;

            return (
                <div>
                    <h1>{user.name}</h1>
                    <p>{user.email}</p>
                    <button onClick={refetch}>Refresh</button>
                </div>
            );
        }}
    />
);
```

### Advanced Render Props

```typescript
interface MouseTrackerProps {
    render: (position: {
        x: number;
        y: number;
        isInside: boolean;
    }) => React.ReactNode;
    onPositionChange?: (x: number, y: number) => void;
}

const MouseTracker: React.FC<MouseTrackerProps> = ({
    render,
    onPositionChange
}) => {
    const [position, setPosition] = useState({ x: 0, y: 0, isInside: false });
    const ref = useRef<HTMLDivElement>(null);

    useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
            const element = ref.current;
            if (!element) return;

            const rect = element.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const isInside = x >= 0 && x <= rect.width &&
                           y >= 0 && y <= rect.height;

            setPosition({ x, y, isInside });
            onPositionChange?.(x, y);
        };

        window.addEventListener('mousemove', handleMouseMove);
        return () => window.removeEventListener('mousemove', handleMouseMove);
    }, [onPositionChange]);

    return (
        <div ref={ref} style={{ position: 'relative' }}>
            {render(position)}
        </div>
    );
};

// Usage
const InteractiveComponent = () => (
    <MouseTracker
        render={({ x, y, isInside }) => (
            <div style={{
                transform: `translate(${x}px, ${y}px)`,
                opacity: isInside ? 1 : 0.5
            }}>
                {`x: ${x}, y: ${y}`}
            </div>
        )}
    />
);
```

## Custom Hooks

### Building Reusable Hooks

```typescript
// Data fetching hook
function useDataFetching<T>(
  fetchFn: () => Promise<T>,
  dependencies: any[] = [],
) {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<Error | null>(null)

  const fetch = useCallback(async () => {
    try {
      setLoading(true)
      const result = await fetchFn()
      setData(result)
      setError(null)
    } catch (e) {
      setError(e as Error)
    } finally {
      setLoading(false)
    }
  }, dependencies)

  useEffect(() => {
    fetch()
  }, [fetch])

  return { data, loading, error, refetch: fetch }
}

// Form handling hook
interface FormConfig<T> {
  initialValues: T
  validate?: (values: T) => Partial<Record<keyof T, string>>
  onSubmit: (values: T) => void | Promise<void>
}

function useForm<T extends Record<string, any>>({
  initialValues,
  validate,
  onSubmit,
}: FormConfig<T>) {
  const [values, setValues] = useState<T>(initialValues)
  const [errors, setErrors] = useState<Partial<Record<keyof T, string>>>({})
  const [submitting, setSubmitting] = useState(false)

  const handleChange = useCallback(
    (name: keyof T, value: T[keyof T]) => {
      setValues((prev) => ({ ...prev, [name]: value }))
      if (validate) {
        const validationErrors = validate({ ...values, [name]: value })
        setErrors(validationErrors)
      }
    },
    [values, validate],
  )

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (validate) {
      const validationErrors = validate(values)
      setErrors(validationErrors)

      if (Object.keys(validationErrors).length > 0) {
        return
      }
    }

    setSubmitting(true)
    try {
      await onSubmit(values)
    } finally {
      setSubmitting(false)
    }
  }

  return {
    values,
    errors,
    submitting,
    handleChange,
    handleSubmit,
    setValues,
    setErrors,
  }
}

// State persistence hook
function useLocalStorage<T>(
  key: string,
  initialValue: T,
): [T, (value: T | ((prev: T) => T)) => void] {
  const [storedValue, setStoredValue] = useState<T>(() => {
    try {
      const item = window.localStorage.getItem(key)
      return item ? JSON.parse(item) : initialValue
    } catch (error) {
      console.error(error)
      return initialValue
    }
  })

  const setValue = (value: T | ((prev: T) => T)) => {
    try {
      const valueToStore =
        value instanceof Function ? value(storedValue) : value
      setStoredValue(valueToStore)
      window.localStorage.setItem(key, JSON.stringify(valueToStore))
    } catch (error) {
      console.error(error)
    }
  }

  return [storedValue, setValue]
}

// Usage examples
const UserComponent = () => {
  const {
    data: user,
    loading,
    error,
  } = useDataFetching<User>(() => fetch('/api/user').then((r) => r.json()), [])

  const { values, handleSubmit, handleChange } = useForm({
    initialValues: { name: '', email: '' },
    validate: (values) => {
      const errors: Record<string, string> = {}
      if (!values.name) errors.name = 'Required'
      if (!values.email) errors.email = 'Required'
      return errors
    },
    onSubmit: async (values) => {
      await fetch('/api/user', {
        method: 'POST',
        body: JSON.stringify(values),
      })
    },
  })

  const [settings, setSettings] = useLocalStorage('userSettings', {
    theme: 'light',
    notifications: true,
  })

  // Component implementation
}
```

### Combining Hooks and Components

```typescript
interface AsyncButtonProps {
    onClick: () => Promise<void>;
    children: React.ReactNode;
}

const useAsyncButton = (onClick: () => Promise<void>) => {
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState<Error | null>(null);

    const handleClick = async () => {
        try {
            setLoading(true);
            setError(null);
            await onClick();
        } catch (e) {
            setError(e as Error);
        } finally {
            setLoading(false);
        }
    };

    return { loading, error, handleClick };
};

const AsyncButton: React.FC<AsyncButtonProps> = ({
    onClick,
    children
}) => {
    const { loading, error, handleClick } = useAsyncButton(onClick);

    return (
        <div>
            <button
                onClick={handleClick}
                disabled={loading}
            >
                {loading ? 'Loading...' : children}
            </button>
            {error && (
                <div className="error">{error.message}</div>
            )}
        </div>
    );
};

// Usage
const SubmitButton = () => (
    <AsyncButton
        onClick={async () => {
            await submitForm();
        }}
    >
        Submit
    </AsyncButton>
);
```
