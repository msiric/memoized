# Understanding React's Rendering Process

## The Mental Model

Think of React's rendering process like a newspaper printing system:

- A change occurs (the news)
- React prepares a new version (typesetting)
- React compares versions (proofreading)
- Only necessary updates go to the DOM (printing only changed pages)

## Component Rendering Lifecycle

### 1. Identifying Render Triggers

```typescript
interface Product {
    id: string;
    name: string;
    price: number;
}

// BAD: Unnecessary renders
function ProductCard({ product }: { product: Product }) {
    const [discount, setDiscount] = useState(0);

    // This causes re-render on every parent update
    const finalPrice = calculatePrice(product.price, discount);

    return (
        <div>
            <h2>{product.name}</h2>
            <p>${finalPrice}</p>
            <button onClick={() => setDiscount(10)}>
                Apply Discount
            </button>
        </div>
    );
}

// GOOD: Optimized rendering
function ProductCard({ product }: { product: Product }) {
    const [discount, setDiscount] = useState(0);

    // Memoized calculation
    const finalPrice = useMemo(
        () => calculatePrice(product.price, discount),
        [product.price, discount]
    );

    return (
        <div>
            <h2>{product.name}</h2>
            <p>${finalPrice}</p>
            <button onClick={() => setDiscount(10)}>
                Apply Discount
            </button>
        </div>
    );
}
```

### 2. Render Phases

```typescript
interface ListProps<T> {
    items: T[];
    renderItem: (item: T) => React.ReactNode;
}

// Understanding commit phases
function VirtualList<T>({ items, renderItem }: ListProps<T>) {
    const [visibleRange, setVisibleRange] = useState({ start: 0, end: 10 });
    const containerRef = useRef<HTMLDivElement>(null);

    // Layout effect runs synchronously after DOM mutations
    useLayoutEffect(() => {
        if (!containerRef.current) return;

        // Measure DOM and update visible range
        const { height, top } = containerRef.current.getBoundingClientRect();
        const visibleItems = Math.ceil(height / ITEM_HEIGHT);
        setVisibleRange({
            start: Math.floor(Math.max(0, top) / ITEM_HEIGHT),
            end: Math.min(items.length, visibleItems)
        });
    }, [items.length]);

    // Effect runs after browser paint
    useEffect(() => {
        // Non-critical updates
        analytics.logVisibleItems(visibleRange);
    }, [visibleRange]);

    return (
        <div ref={containerRef} style={{ overflow: 'auto', height: '100%' }}>
            {items.slice(visibleRange.start, visibleRange.end).map(renderItem)}
        </div>
    );
}
```

## Optimizing Re-renders

### 1. Component Memoization

```typescript
interface UserListProps {
    users: User[];
    onSelect: (user: User) => void;
    filter: string;
}

// Memoized component
const UserList = memo(function UserList({
    users,
    onSelect,
    filter
}: UserListProps) {
    // Memoize filtered users
    const filteredUsers = useMemo(() =>
        users.filter(user =>
            user.name.toLowerCase().includes(filter.toLowerCase())
        ),
        [users, filter]
    );

    return (
        <ul>
            {filteredUsers.map(user => (
                <UserListItem
                    key={user.id}
                    user={user}
                    onSelect={onSelect}
                />
            ))}
        </ul>
    );
}, (prevProps, nextProps) => {
    // Custom comparison function
    return (
        prevProps.filter === nextProps.filter &&
        prevProps.onSelect === nextProps.onSelect &&
        areUsersEqual(prevProps.users, nextProps.users)
    );
});

// Memoized child component
const UserListItem = memo(function UserListItem({
    user,
    onSelect
}: {
    user: User;
    onSelect: (user: User) => void;
}) {
    // Memoize callback
    const handleClick = useCallback(() => {
        onSelect(user);
    }, [user, onSelect]);

    return (
        <li onClick={handleClick}>
            <Avatar user={user} />
            <span>{user.name}</span>
        </li>
    );
});
```

### 2. State Updates Optimization

```typescript
interface TableState {
  data: Record<string, any>[]
  sorting: {
    column: string
    direction: 'asc' | 'desc'
  }
  pagination: {
    page: number
    pageSize: number
  }
  selection: Set<string>
}

function DataTable() {
  const [state, setState] = useState<TableState>({
    data: [],
    sorting: { column: 'id', direction: 'asc' },
    pagination: { page: 1, pageSize: 10 },
    selection: new Set(),
  })

  // BAD: Multiple state updates
  const handleSort = (column: string) => {
    setState((prev) => ({
      ...prev,
      sorting: {
        column,
        direction: prev.sorting.direction === 'asc' ? 'desc' : 'asc',
      },
    }))
    setState((prev) => ({
      ...prev,
      pagination: { ...prev.pagination, page: 1 },
    }))
  }

  // GOOD: Batched state update
  const handleSortOptimized = (column: string) => {
    setState((prev) => ({
      ...prev,
      sorting: {
        column,
        direction: prev.sorting.direction === 'asc' ? 'desc' : 'asc',
      },
      pagination: { ...prev.pagination, page: 1 },
    }))
  }

  // BETTER: State updates with selector
  const updateState = useCallback(
    (selector: (prev: TableState) => Partial<TableState>) => {
      setState((prev) => ({
        ...prev,
        ...selector(prev),
      }))
    },
    [],
  )
}
```

### 3. Context Optimization

```typescript
interface ThemeContext {
    theme: 'light' | 'dark';
    toggleTheme: () => void;
}

interface UserContext {
    user: User | null;
    updateUser: (user: User) => void;
}

// BAD: Single large context
const AppContext = createContext<ThemeContext & UserContext>(null!);

// GOOD: Split contexts
const ThemeContext = createContext<ThemeContext>(null!);
const UserContext = createContext<UserContext>(null!);

function App() {
    const [theme, setTheme] = useState<'light' | 'dark'>('light');
    const [user, setUser] = useState<User | null>(null);

    const themeContext = useMemo(() => ({
        theme,
        toggleTheme: () => setTheme(t => t === 'light' ? 'dark' : 'light')
    }), [theme]);

    const userContext = useMemo(() => ({
        user,
        updateUser: setUser
    }), [user]);

    return (
        <ThemeContext.Provider value={themeContext}>
            <UserContext.Provider value={userContext}>
                <AppContent />
            </UserContext.Provider>
        </ThemeContext.Provider>
    );
}
```

### 4. Performance Measurement

```typescript
const useRenderCount = (componentName: string) => {
    const renderCount = useRef(0);

    useEffect(() => {
        renderCount.current++;
        console.log(`${componentName} rendered ${renderCount.current} times`);
    });
};

function withPerformanceTracking<P extends object>(
    WrappedComponent: React.ComponentType<P>,
    componentName: string
) {
    return function PerformanceTrackedComponent(props: P) {
        const startTime = useRef(performance.now());

        useEffect(() => {
            const endTime = performance.now();
            console.log(
                `${componentName} took ${endTime - startTime.current}ms to render`
            );
            startTime.current = performance.now();
        });

        return <WrappedComponent {...props} />;
    };
}

// Usage
const TrackedUserList = withPerformanceTracking(UserList, 'UserList');
```

# Code Splitting and Lazy Loading

## Dynamic Imports

### Basic Code Splitting

```typescript
// Before: Everything bundled together
import HeavyComponent from './HeavyComponent';
import { heavyCalculation } from './utils';

// After: Dynamic imports
const HeavyComponent = lazy(() => import('./HeavyComponent'));
const heavyCalculation = () => import('./utils').then(m => m.heavyCalculation);

// Implementation
interface AsyncComponentProps {
    onLoad?: () => void;
    fallback?: React.ReactNode;
}

function withAsyncLoading<P extends object>(
    importFn: () => Promise<{ default: React.ComponentType<P> }>,
    options: AsyncComponentProps = {}
) {
    const LazyComponent = lazy(importFn);

    return function AsyncComponent(props: P) {
        useEffect(() => {
            importFn().then(() => options.onLoad?.());
        }, []);

        return (
            <Suspense fallback={options.fallback || <Spinner />}>
                <LazyComponent {...props} />
            </Suspense>
        );
    };
}

// Usage
const Charts = withAsyncLoading(
    () => import('./Charts'),
    {
        fallback: <ChartPlaceholder />,
        onLoad: () => console.log('Charts loaded')
    }
);
```

### Route-Based Code Splitting

```typescript
interface RouteConfig {
    path: string;
    component: () => Promise<{ default: React.ComponentType }>;
    preload?: () => Promise<void>;
}

const routes: RouteConfig[] = [
    {
        path: '/dashboard',
        component: () => import('./pages/Dashboard'),
        preload: () => import('./stores/DashboardStore')
    },
    {
        path: '/profile',
        component: () => import('./pages/Profile')
    }
];

function Router() {
    return (
        <Suspense fallback={<PageLoader />}>
            <Switch>
                {routes.map(route => (
                    <Route
                        key={route.path}
                        path={route.path}
                        component={lazy(route.component)}
                    />
                ))}
            </Switch>
        </Suspense>
    );
}

// Preloading implementation
function usePreloadRoute() {
    const preloadRoute = useCallback((path: string) => {
        const route = routes.find(r => r.path === path);
        if (route) {
            // Preload component
            route.component();
            // Preload additional resources
            route.preload?.();
        }
    }, []);

    return preloadRoute;
}

function NavLink({ to, children }: { to: string; children: React.ReactNode }) {
    const preloadRoute = usePreloadRoute();

    return (
        <Link
            to={to}
            onMouseEnter={() => preloadRoute(to)}
            onFocus={() => preloadRoute(to)}
        >
            {children}
        </Link>
    );
}
```

### Component-Based Code Splitting

```typescript
interface SplitComponentConfig<P> {
    load: () => Promise<{ default: React.ComponentType<P> }>;
    minDelay?: number;
    maxDelay?: number;
    onError?: (error: Error) => void;
}

function createSplitComponent<P extends object>({
    load,
    minDelay = 300,
    maxDelay = 3000,
    onError
}: SplitComponentConfig<P>) {
    const LoadingComponent = ({ pastDelay }: { pastDelay: boolean }) => (
        pastDelay ? <Spinner /> : null
    );

    const ErrorComponent = ({ error }: { error: Error }) => (
        <ErrorBoundary error={error} onRetry={retry} />
    );

    let loadPromise: Promise<{ default: React.ComponentType<P> }> | null = null;
    let Component: React.ComponentType<P> | null = null;

    function retry() {
        loadPromise = null;
        Component = null;
    }

    return function SplitComponent(props: P) {
        const [loading, setLoading] = useState(true);
        const [error, setError] = useState<Error | null>(null);
        const [pastDelay, setPastDelay] = useState(false);

        useEffect(() => {
            const minTimer = setTimeout(() => {
                setPastDelay(true);
            }, minDelay);

            const maxTimer = setTimeout(() => {
                if (loading) {
                    setError(new Error('Loading timeout'));
                }
            }, maxDelay);

            if (!loadPromise) {
                loadPromise = load()
                    .then(module => {
                        Component = module.default;
                        setLoading(false);
                    })
                    .catch(err => {
                        setError(err);
                        onError?.(err);
                    });
            }

            return () => {
                clearTimeout(minTimer);
                clearTimeout(maxTimer);
            };
        }, []);

        if (error) {
            return <ErrorComponent error={error} />;
        }

        if (loading) {
            return <LoadingComponent pastDelay={pastDelay} />;
        }

        if (!Component) {
            return null;
        }

        return <Component {...props} />;
    };
}

// Usage
const HeavyChart = createSplitComponent({
    load: () => import('./HeavyChart'),
    minDelay: 500,
    maxDelay: 5000,
    onError: (error) => {
        analytics.trackError('chart_load_failed', error);
    }
});
```

### Bundle Analysis and Optimization

```typescript
// Bundle size monitoring
const useBundleSize = (
    componentName: string,
    importFn: () => Promise<any>
) => {
    useEffect(() => {
        if (process.env.NODE_ENV === 'development') {
            performance.mark(`${componentName}-start`);

            importFn().then(() => {
                performance.mark(`${componentName}-end`);
                performance.measure(
                    `${componentName}-load`,
                    `${componentName}-start`,
                    `${componentName}-end`
                );

                const measurements = performance.getEntriesByName(
                    `${componentName}-load`
                );
                console.log(
                    `${componentName} bundle loaded in ${
                        measurements[0].duration
                    }ms`
                );
            });
        }
    }, [componentName]);
};

// Module dependency tracking
const createModuleTracker = () => {
    const dependencies = new Map<string, Set<string>>();

    return {
        trackImport: (
            moduleId: string,
            dependencyId: string
        ) => {
            if (!dependencies.has(moduleId)) {
                dependencies.set(moduleId, new Set());
            }
            dependencies.get(moduleId)!.add(dependencyId);
        },

        getDependencies: (moduleId: string) =>
            Array.from(dependencies.get(moduleId) || []),

        getModuleStats: () => {
            return Array.from(dependencies.entries()).map(([moduleId, deps]) => ({
                moduleId,
                dependencyCount: deps.size,
                dependencies: Array.from(deps)
            }));
        }
    };
};

// Usage in development
if (process.env.NODE_ENV === 'development') {
    const moduleTracker = createModuleTracker();

    // Track module dependencies
    const withTracking = <P extends object>(
        Component: React.ComponentType<P>,
        moduleId: string
    ) => {
        return function TrackedComponent(props: P) {
            useEffect(() => {
                const imports = (window as any).__TRACKED_IMPORTS__ || {};
                Object.keys(imports).forEach(dep => {
                    moduleTracker.trackImport(moduleId, dep);
                });
            }, []);

            return <Component {...props} />;
        };
    };
}
```

# Advanced Optimization Techniques

## Memoization Patterns

### Complex Memoization Strategies

```typescript
// Advanced useMemo implementation
function useDeepMemo<T>(
    factory: () => T,
    dependencies: any[],
    isEqual: (prev: any[], next: any[]) => boolean = deepEqual
) {
    const ref = useRef<{ deps: any[]; value: T }>();

    if (!ref.current || !isEqual(dependencies, ref.current.deps)) {
        ref.current = { deps: dependencies, value: factory() };
    }

    return ref.current.value;
}

// Memoizing expensive calculations with cache
function useMemoWithCache<T>(
    calculator: () => T,
    dependencies: any[],
    options: {
        cacheSize?: number;
        ttl?: number;
    } = {}
) {
    const cache = useRef(new Map<string, { value: T; timestamp: number }>());
    const { cacheSize = 100, ttl = 5000 } = options;

    // Clean expired entries
    useEffect(() => {
        const interval = setInterval(() => {
            const now = Date.now();
            for (const [key, entry] of cache.current.entries()) {
                if (now - entry.timestamp > ttl) {
                    cache.current.delete(key);
                }
            }
        }, ttl);

        return () => clearInterval(interval);
    }, [ttl]);

    return useMemo(() => {
        const key = JSON.stringify(dependencies);
        const cached = cache.current.get(key);

        if (cached && Date.now() - cached.timestamp < ttl) {
            return cached.value;
        }

        const value = calculator();

        // Manage cache size
        if (cache.current.size >= cacheSize) {
            const oldestKey = cache.current.keys().next().value;
            cache.current.delete(oldestKey);
        }

        cache.current.set(key, {
            value,
            timestamp: Date.now()
        });

        return value;
    }, dependencies);
}

// Usage example
function DataGrid({ data, filters, sorting }: DataGridProps) {
    const processedData = useMemoWithCache(
        () => processData(data, filters, sorting),
        [data, filters, sorting],
        { cacheSize: 20, ttl: 10000 }
    );

    return <Table data={processedData} />;
}
```

### Performance-Optimized Event Handlers

```typescript
interface EventHandlerOptions {
    throttle?: number;
    debounce?: number;
    maxExecutions?: number;
}

function useOptimizedCallback<T extends (...args: any[]) => any>(
    callback: T,
    dependencies: any[],
    options: EventHandlerOptions = {}
) {
    const { throttle, debounce, maxExecutions } = options;
    const executionCount = useRef(0);
    const timeoutRef = useRef<NodeJS.Timeout>();
    const lastExecutionRef = useRef<number>(0);

    const optimizedCallback = useCallback((...args: Parameters<T>) => {
        const now = Date.now();

        // Check max executions
        if (maxExecutions && executionCount.current >= maxExecutions) {
            return;
        }

        // Handle throttling
        if (throttle && now - lastExecutionRef.current < throttle) {
            return;
        }

        // Handle debouncing
        if (debounce) {
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }

            timeoutRef.current = setTimeout(() => {
                callback(...args);
                executionCount.current++;
                lastExecutionRef.current = now;
            }, debounce);
            return;
        }

        // Normal execution
        callback(...args);
        executionCount.current++;
        lastExecutionRef.current = now;
    }, dependencies);

    // Cleanup
    useEffect(() => {
        return () => {
            if (timeoutRef.current) {
                clearTimeout(timeoutRef.current);
            }
        };
    }, []);

    return optimizedCallback;
}

// Usage
function SearchInput() {
    const handleSearch = useOptimizedCallback(
        (query: string) => {
            // Expensive search operation
            performSearch(query);
        },
        [],
        { debounce: 300 }
    );

    return <input onChange={e => handleSearch(e.target.value)} />;
}
```

## Memory Management

### Memory Leak Prevention

```typescript
interface MemoryMonitor {
    trackMemory: () => void;
    getMemoryUsage: () => number;
    clearTracking: () => void;
}

function createMemoryMonitor(): MemoryMonitor {
    const memoryEntries = new Map<string, WeakRef<object>>();
    const registry = new FinalizationRegistry((key: string) => {
        memoryEntries.delete(key);
    });

    return {
        trackMemory: () => {
            if (process.env.NODE_ENV === 'development') {
                const snapshot = new Map<string, number>();

                // Track component instances
                snapshot.set('components', memoryEntries.size);

                // Track event listeners
                const listeners = (window as any).__EVENT_LISTENERS__ || new Set();
                snapshot.set('eventListeners', listeners.size);

                console.table(Object.fromEntries(snapshot));
            }
        },

        getMemoryUsage: () => {
            return performance.memory?.usedJSHeapSize || 0;
        },

        clearTracking: () => {
            memoryEntries.clear();
        }
    };
}

// HOC for memory tracking
function withMemoryTracking<P extends object>(
    WrappedComponent: React.ComponentType<P>,
    componentName: string
) {
    return function MemoryTrackedComponent(props: P) {
        useEffect(() => {
            const monitor = createMemoryMonitor();
            monitor.trackMemory();

            return () => {
                monitor.clearTracking();
            };
        }, []);

        return <WrappedComponent {...props} />;
    };
}
```

### Resource Cleanup

```typescript
interface ResourceManager<T> {
    acquire: () => T;
    release: (resource: T) => void;
}

function createResourceManager<T>(
    factory: () => T,
    cleanup: (resource: T) => void
): ResourceManager<T> {
    const pool = new Set<T>();
    const inUse = new WeakSet<T>();

    return {
        acquire: () => {
            let resource: T;

            if (pool.size > 0) {
                resource = pool.values().next().value;
                pool.delete(resource);
            } else {
                resource = factory();
            }

            inUse.add(resource);
            return resource;
        },

        release: (resource: T) => {
            if (inUse.has(resource)) {
                cleanup(resource);
                inUse.delete(resource);
                pool.add(resource);
            }
        }
    };
}

// Usage with canvas resources
const canvasManager = createResourceManager(
    () => document.createElement('canvas'),
    (canvas) => {
        const ctx = canvas.getContext('2d');
        ctx?.clearRect(0, 0, canvas.width, canvas.height);
    }
);

function CanvasComponent() {
    const canvasRef = useRef<HTMLCanvasElement | null>(null);

    useEffect(() => {
        const canvas = canvasManager.acquire();
        canvasRef.current = canvas;

        return () => {
            if (canvasRef.current) {
                canvasManager.release(canvasRef.current);
                canvasRef.current = null;
            }
        };
    }, []);

    return <div ref={ref => ref?.appendChild(canvasRef.current!)} />;
}
```

### Performance Monitoring

```typescript
interface PerformanceMetrics {
    renderTime: number;
    memoryUsage: number;
    componentCount: number;
    eventListenerCount: number;
}

class PerformanceMonitor {
    private metrics: PerformanceMetrics[] = [];
    private observer: PerformanceObserver;

    constructor() {
        this.observer = new PerformanceObserver((list) => {
            const entries = list.getEntries();
            this.processEntries(entries);
        });

        this.observer.observe({
            entryTypes: ['measure', 'resource']
        });
    }

    private processEntries(entries: PerformanceEntry[]) {
        entries.forEach(entry => {
            if (entry.entryType === 'measure') {
                this.metrics.push({
                    renderTime: entry.duration,
                    memoryUsage: performance.memory?.usedJSHeapSize || 0,
                    componentCount: this.getComponentCount(),
                    eventListenerCount: this.getEventListenerCount()
                });
            }
        });

        // Alert if performance degrades
        this.checkPerformance();
    }

    private checkPerformance() {
        const recentMetrics = this.metrics.slice(-5);
        const avgRenderTime = recentMetrics.reduce(
            (sum, m) => sum + m.renderTime,
            0
        ) / recentMetrics.length;

        if (avgRenderTime > 16) { // 60fps threshold
            console.warn('Performance degradation detected');
            this.generateReport();
        }
    }

    private generateReport() {
        return {
            metrics: this.metrics,
            summary: {
                averageRenderTime: this.calculateAverage('renderTime'),
                memoryTrend: this.calculateTrend('memoryUsage'),
                componentGrowth: this.calculateTrend('componentCount')
            },
            recommendations: this.generateRecommendations()
        };
    }

    private calculateAverage(metric: keyof PerformanceMetrics): number {
        return this.metrics.reduce(
            (sum, m) => sum + m[metric] as number,
            0
        ) / this.metrics.length;
    }

    private calculateTrend(metric: keyof PerformanceMetrics): 'increasing' | 'stable' | 'decreasing' {
        // Trend analysis implementation
        return 'stable';
    }

    private generateRecommendations(): string[] {
        const recommendations: string[] = [];
        const latest = this.metrics[this.metrics.length - 1];

        if (latest.renderTime > 16) {
            recommendations.push('Consider implementing React.memo() for heavy components');
        }

        if (this.calculateTrend('memoryUsage') === 'increasing') {
            recommendations.push('Possible memory leak detected - check component cleanup');
        }

        return recommendations;
    }

    private getComponentCount(): number {
        return document.querySelectorAll('[data-reactroot]').length;
    }

    private getEventListenerCount(): number {
        // Implementation depends on browser devtools API
        return 0;
    }
}

// Usage
const monitor = new PerformanceMonitor();

// HOC for monitoring
function withPerformanceMonitoring<P extends object>(
    WrappedComponent: React.ComponentType<P>
) {
    return function MonitoredComponent(props: P) {
        useEffect(() => {
            performance.mark('component-mount-start');

            return () => {
                performance.mark('component-mount-end');
                performance.measure(
                    'component-lifecycle',
                    'component-mount-start',
                    'component-mount-end'
                );
            };
        }, []);

        return <WrappedComponent {...props} />;
    };
}
```
