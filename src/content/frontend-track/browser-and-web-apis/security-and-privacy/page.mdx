# Security & Privacy in Modern Web Applications - Part 1: Core Concepts

## Building the Mental Model

### The Castle Defense Analogy

Think of web application security like protecting a medieval castle:

1. **Perimeter Defense (Network Security)**

   - Moat (Firewalls)
   - Castle Walls (HTTPS)
   - Guard Posts (Access Control)

2. **Internal Security (Application Security)**

   - Guard Patrols (Monitoring)
   - Secure Rooms (Sandboxing)
   - Secret Passages (Encryption)

3. **Access Control (Authentication/Authorization)**

   - Drawbridge (Authentication)
   - Guard Checks (Authorization)
   - Secret Handshakes (Tokens)

4. **Asset Protection (Data Security)**
   - Treasury (Sensitive Data)
   - Vault Keys (Encryption Keys)
   - Secure Transport (Data in Transit)

## Understanding Web Security Fundamentals

### The Same-Origin Policy (SOP)

Think of SOP like international borders:

1. **Origin Definition**

```
https://  example.com  :443   /path
   ↓         ↓         ↓       ↓
Protocol   Domain    Port    Path
```

2. **Origin Matching Rules**

```javascript
function isSameOrigin(url1, url2) {
  const parser = new URL(url1)
  const parser2 = new URL(url2)

  return (
    parser.protocol === parser2.protocol &&
    parser.hostname === parser2.hostname &&
    parser.port === parser2.port
  )
}
```

3. **SOP Exceptions**
   - CORS Headers
   - document.domain relaxation
   - Window.postMessage

### Cross-Origin Resource Sharing (CORS)

Think of CORS like a diplomatic visa system:

1. **Simple Requests**

```http
GET /api/data HTTP/1.1
Host: api.example.com
Origin: https://app.example.com
```

2. **Preflight Requests**

```http
OPTIONS /api/data HTTP/1.1
Host: api.example.com
Origin: https://app.example.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: Content-Type
```

3. **Server Responses**

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://app.example.com
Access-Control-Allow-Methods: GET, POST, OPTIONS
Access-Control-Allow-Headers: Content-Type
Access-Control-Max-Age: 86400
```

## Authentication Architecture

### The Key and Lock Analogy

Think of authentication like a sophisticated key system:

1. **Authentication Types**

   - Something you know (password)
   - Something you have (device)
   - Something you are (biometrics)

2. **Token-Based Authentication**

```
User → Login → Token Generation → Token Storage → Protected Resources
```

3. **JWT Structure**

```
Header.Payload.Signature

Header = {
  "alg": "HS256",
  "typ": "JWT"
}

Payload = {
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}

Signature = HMAC(base64(header) + "." + base64(payload), secret)
```

### Session Management

1. **Session Lifecycle**

```
Login → Session Creation → Session Usage → Session Termination
```

2. **Session Storage Options**

```javascript
// Client-side options
localStorage // Persistent, vulnerable to XSS
sessionStorage // Session-only
cookies // Configurable, secure when properly set
```

3. **Secure Cookie Configuration**

```http
Set-Cookie: sessionId=abc123;
  Secure;
  HttpOnly;
  SameSite=Strict;
  Domain=example.com;
  Path=/;
  Max-Age=3600
```

## Understanding Common Attack Vectors

### Cross-Site Scripting (XSS)

Think of XSS like poison in a water supply:

1. **Types of XSS**

   - Reflected XSS (from URL)
   - Stored XSS (from database)
   - DOM-based XSS (from client-side)

2. **Attack Vectors**

```html
<!-- Reflected XSS -->
<script>
  alert(document.cookie)
</script>

<!-- Stored XSS -->
<img src="x" onerror="steal()" />

<!-- DOM XSS -->
<div id="output"></div>
<script>
  // Vulnerable
  output.innerHTML = location.hash.slice(1)
</script>
```

### Cross-Site Request Forgery (CSRF)

Think of CSRF like forged bank checks:

1. **Attack Pattern**

```html
<!-- Malicious Site -->
<img src="http://bank.com/transfer?to=attacker&amount=1000" />

<!-- Malicious Form -->
<form action="http://bank.com/transfer" method="POST">
  <input type="hidden" name="to" value="attacker" />
  <input type="hidden" name="amount" value="1000" />
</form>
<script>
  document.forms[0].submit()
</script>
```

2. **Prevention Pattern**

```http
// Server generates token
Set-Cookie: csrfToken=abc123

// Client includes token
POST /api/transfer
X-CSRF-Token: abc123
```

## Privacy Considerations

### Data Collection and Storage

1. **Personal Data Categories**

```javascript
const personalData = {
  directIdentifiers: ['name', 'email', 'phone', 'address'],
  indirectIdentifiers: ['age', 'postcode', 'profession'],
  sensitiveData: ['health', 'finance', 'religion'],
}
```

2. **Data Minimization**

```javascript
class UserProfile {
  constructor(userData) {
    // Only collect necessary data
    this.email = userData.email
    this.displayName = this.anonymizeDisplayName(userData.name)
  }

  anonymizeDisplayName(name) {
    return name.charAt(0) + '***' + name.charAt(name.length - 1)
  }
}
```

### User Consent Management

1. **Consent Types**

```javascript
const consentTypes = {
  necessary: {
    required: true,
    description: 'Essential for site functionality',
  },
  analytics: {
    required: false,
    description: 'Help us improve our service',
  },
  marketing: {
    required: false,
    description: 'Personalized advertisements',
  },
}
```

2. **Consent Storage**

```javascript
class ConsentManager {
  constructor() {
    this.consentStore = new Map()
  }

  setConsent(type, granted) {
    this.consentStore.set(type, {
      granted,
      timestamp: new Date().toISOString(),
      source: 'user_action',
    })
  }

  hasConsent(type) {
    return this.consentStore.get(type)?.granted ?? false
  }

  export() {
    return Array.from(this.consentStore.entries()).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [key]: value,
      }),
      {},
    )
  }
}
```

# Security & Privacy in Modern Web Applications - Part 2: Implementation Patterns

## Security Implementation Patterns

### Content Security Policy (CSP)

1. **CSP Configuration**

```http
Content-Security-Policy:
  default-src 'self';
  script-src 'self' https://trusted.com;
  style-src 'self' 'unsafe-inline';
  img-src 'self' data: https:;
  connect-src 'self' https://api.example.com;
  frame-ancestors 'none';
  form-action 'self';
  base-uri 'self';
```

2. **CSP Implementation**

```javascript
class SecurityHeaders {
  static getHeaders() {
    return {
      'Content-Security-Policy': this.getCSP(),
      'X-Content-Type-Options': 'nosniff',
      'X-Frame-Options': 'DENY',
      'X-XSS-Protection': '1; mode=block',
      'Referrer-Policy': 'strict-origin-when-cross-origin',
      'Permissions-Policy': this.getPermissionsPolicy(),
    }
  }

  static getCSP() {
    const directives = {
      'default-src': ["'self'"],
      'script-src': ["'self'", 'https://trusted.com'],
      'style-src': ["'self'", "'unsafe-inline'"],
      'img-src': ["'self'", 'data:', 'https:'],
      'connect-src': ["'self'", 'https://api.example.com'],
      'frame-ancestors': ["'none'"],
      'form-action': ["'self'"],
      'base-uri': ["'self'"],
    }

    return Object.entries(directives)
      .map(([key, values]) => `${key} ${values.join(' ')}`)
      .join('; ')
  }

  static getPermissionsPolicy() {
    const features = {
      geolocation: ['self'],
      microphone: ['none'],
      camera: ['none'],
      payment: ['https://payment.example.com'],
    }

    return Object.entries(features)
      .map(([feature, allowlist]) => `${feature}=(${allowlist.join(' ')})`)
      .join(', ')
  }
}
```

### XSS Prevention

1. **Input Sanitization**

```javascript
class InputSanitizer {
  static sanitize(input) {
    return input
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;')
  }

  static sanitizeHTML(html) {
    const template = document.createElement('template')
    template.innerHTML = html.trim()

    // Remove dangerous attributes
    template.content.querySelectorAll('*').forEach((element) => {
      Array.from(element.attributes).forEach((attr) => {
        if (attr.name.startsWith('on') || attr.value.includes('javascript:')) {
          element.removeAttribute(attr.name)
        }
      })
    })

    return template.innerHTML
  }
}
```

2. **Safe DOM Manipulation**

```javascript
class SafeDOM {
  static setText(element, text) {
    element.textContent = text
  }

  static setHTML(element, html) {
    const sanitized = DOMPurify.sanitize(html, {
      ALLOWED_TAGS: ['b', 'i', 'em', 'strong', 'a'],
      ALLOWED_ATTR: ['href'],
    })
    element.innerHTML = sanitized
  }

  static createURL(base, params) {
    const url = new URL(base)
    Object.entries(params).forEach(([key, value]) => {
      url.searchParams.append(key, value)
    })
    return url.toString()
  }
}
```

### CSRF Protection

1. **Token Management**

```javascript
class CSRFProtection {
  constructor() {
    this.token = this.generateToken()
  }

  generateToken() {
    const buffer = new Uint8Array(32)
    crypto.getRandomValues(buffer)
    return Array.from(buffer)
      .map((b) => b.toString(16).padStart(2, '0'))
      .join('')
  }

  applyToHeaders(headers) {
    return {
      ...headers,
      'X-CSRF-Token': this.token,
    }
  }

  validateToken(receivedToken) {
    return this.token === receivedToken
  }

  applyToForms() {
    document.querySelectorAll('form').forEach((form) => {
      const input = document.createElement('input')
      input.type = 'hidden'
      input.name = '_csrf'
      input.value = this.token
      form.appendChild(input)
    })
  }
}
```

2. **Request Interceptor**

```javascript
class SecureHttpClient {
  constructor(csrfProtection) {
    this.csrfProtection = csrfProtection
  }

  async fetch(url, options = {}) {
    const secureOptions = {
      ...options,
      credentials: 'include',
      headers: this.csrfProtection.applyToHeaders(options.headers || {}),
    }

    try {
      const response = await fetch(url, secureOptions)
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      return response
    } catch (error) {
      // Handle network errors
      console.error('Request failed:', error)
      throw error
    }
  }
}
```

### Authentication Implementation

1. **Token Management**

```javascript
class TokenManager {
  constructor() {
    this.tokenKey = 'auth_token'
    this.refreshTokenKey = 'refresh_token'
  }

  setTokens(accessToken, refreshToken) {
    sessionStorage.setItem(this.tokenKey, accessToken)
    localStorage.setItem(this.refreshTokenKey, refreshToken)
  }

  getAccessToken() {
    return sessionStorage.getItem(this.tokenKey)
  }

  getRefreshToken() {
    return localStorage.getItem(this.refreshTokenKey)
  }

  clearTokens() {
    sessionStorage.removeItem(this.tokenKey)
    localStorage.removeItem(this.refreshTokenKey)
  }

  async refreshAccessToken() {
    const refreshToken = this.getRefreshToken()
    if (!refreshToken) throw new Error('No refresh token')

    try {
      const response = await fetch('/api/refresh', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${refreshToken}`,
        },
      })

      if (!response.ok) throw new Error('Refresh failed')

      const { accessToken, newRefreshToken } = await response.json()
      this.setTokens(accessToken, newRefreshToken)
      return accessToken
    } catch (error) {
      this.clearTokens()
      throw error
    }
  }
}
```

2. **Authentication Service**

```javascript
class AuthenticationService {
  constructor(tokenManager) {
    this.tokenManager = tokenManager
    this.authListeners = new Set()
  }

  async login(credentials) {
    try {
      const response = await fetch('/api/login', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(credentials),
      })

      if (!response.ok) throw new Error('Login failed')

      const { accessToken, refreshToken } = await response.json()
      this.tokenManager.setTokens(accessToken, refreshToken)
      this.notifyAuthChange(true)

      return true
    } catch (error) {
      console.error('Login failed:', error)
      throw error
    }
  }

  async logout() {
    try {
      await fetch('/api/logout', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${this.tokenManager.getAccessToken()}`,
        },
      })
    } finally {
      this.tokenManager.clearTokens()
      this.notifyAuthChange(false)
    }
  }

  addAuthListener(listener) {
    this.authListeners.add(listener)
    return () => this.authListeners.delete(listener)
  }

  notifyAuthChange(isAuthenticated) {
    this.authListeners.forEach((listener) => listener(isAuthenticated))
  }

  async refreshAuthStatus() {
    try {
      await this.tokenManager.refreshAccessToken()
      this.notifyAuthChange(true)
    } catch (error) {
      this.notifyAuthChange(false)
    }
  }
}
```

### Privacy Implementation Patterns

1. **Data Masking Service**

```javascript
class DataMaskingService {
  static maskPatterns = {
    email: /^(.{3}).*(@.*)$/,
    phone: /^(\+\d{1,3}|\d{1,4})(.*)(\d{4})$/,
    creditCard: /^(\d{4}).*(\d{4})$/,
  }

  static mask(value, type) {
    if (!value) return value

    switch (type) {
      case 'email':
        return value.replace(this.maskPatterns.email, '$1***$2')

      case 'phone':
        return value.replace(this.maskPatterns.phone, '$1*****$3')

      case 'creditCard':
        return value.replace(this.maskPatterns.creditCard, '$1 **** **** $2')

      default:
        return value
    }
  }

  static maskObject(obj, fieldsToMask) {
    return Object.entries(obj).reduce(
      (acc, [key, value]) => ({
        ...acc,
        [key]: fieldsToMask.includes(key)
          ? this.mask(value, fieldsToMask[key])
          : value,
      }),
      {},
    )
  }
}
```

2. **Privacy Consent Manager**

```javascript
class PrivacyConsentManager {
  constructor() {
    this.consentStore = new Map();
    this.listeners = new Set();
    this.loadStoredConsent();
  }

  loadStoredConsent() {
    try {
      const stored = localStorage.getItem('privacy_consent');
      if (stored) {
        const parsed = JSON.parse(stored);
        Object.entries(parsed).forEach(([key, value]) => {
          this.consentStore.set(key, value);
        });
      }
    } catch (error) {
      console.error('Failed to load stored consent:', error);
    }
  }

  setConsent(category, granted) {
    const consentData = {
      granted,
      timestamp: new Date().toISOString(),
      version: '1.0'
    };

    this.consentStore.set(category, consentData);
    this.saveConsent();
    this.notifyListeners(category, granted);
  }

  hasConsent(category) {
    return this.consentStore.get(category)?.granted ?? false;
  }

  addConsentListener(listener) {
    this.listeners.add(listener);
    return () => this.listeners.delete(listener);
  }

  private notifyListeners(category, granted) {
    this.listeners.forEach(listener =>
      listener(category, granted)
    );
  }

  private saveConsent() {
    try {
      const consentData = Object.fromEntries(this.consentStore);
      localStorage.setItem(
        'privacy_consent',
        JSON.stringify(consentData)
      );
    } catch (error) {
      console.error('Failed to save consent:', error);
    }
  }
}
```

### Secure Storage Patterns

1. **Encrypted Storage Service**

```javascript
class SecureStorageService {
  constructor() {
    this.encoder = new TextEncoder()
    this.decoder = new TextDecoder()
  }

  async generateKey() {
    return await crypto.subtle.generateKey(
      {
        name: 'AES-GCM',
        length: 256,
      },
      true,
      ['encrypt', 'decrypt'],
    )
  }

  async encrypt(data, key) {
    const iv = crypto.getRandomValues(new Uint8Array(12))
    const encoded = this.encoder.encode(JSON.stringify(data))

    const encrypted = await crypto.subtle.encrypt(
      {
        name: 'AES-GCM',
        iv,
      },
      key,
      encoded,
    )

    return {
      iv: Array.from(iv),
      data: Array.from(new Uint8Array(encrypted)),
    }
  }

  async decrypt(encryptedData, key) {
    const { iv, data } = encryptedData

    const decrypted = await crypto.subtle.decrypt(
      {
        name: 'AES-GCM',
        iv: new Uint8Array(iv),
      },
      key,
      new Uint8Array(data),
    )

    return JSON.parse(this.decoder.decode(decrypted))
  }

  async secureStore(key, data) {
    const cryptoKey = await this.generateKey()
    const encrypted = await this.encrypt(data, cryptoKey)

    // Store the encrypted data
    sessionStorage.setItem(key, JSON.stringify(encrypted))

    // Store the key securely
    return await crypto.subtle.exportKey('jwk', cryptoKey)
  }

  async secureRetrieve(key, cryptoKey) {
    const stored = sessionStorage.getItem(key)
    if (!stored) return null

    const encrypted = JSON.parse(stored)
    const importedKey = await crypto.subtle.importKey(
      'jwk',
      cryptoKey,
      'AES-GCM',
      true,
      ['decrypt'],
    )

    return await this.decrypt(encrypted, importedKey)
  }
}
```

### Security Monitoring Patterns

1. **Security Event Monitor**

```javascript
class SecurityMonitor {
  constructor() {
    this.events = []
    this.suspiciousPatterns = new Set([
      /script/i,
      /javascript:/i,
      /data:/i,
      /alert\(/i,
    ])
  }

  logEvent(event) {
    const eventData = {
      timestamp: new Date().toISOString(),
      type: event.type,
      data: event.data,
      severity: this.assessSeverity(event),
      userAgent: navigator.userAgent,
      url: window.location.href,
    }

    this.events.push(eventData)
    this.analyzeEvent(eventData)
  }

  assessSeverity(event) {
    if (this.isSuspiciousInput(event.data)) {
      return 'high'
    }

    if (event.type === 'auth_failure') {
      return 'medium'
    }

    return 'low'
  }

  isSuspiciousInput(input) {
    if (typeof input !== 'string') return false

    return Array.from(this.suspiciousPatterns).some((pattern) =>
      pattern.test(input),
    )
  }

  analyzeEvent(event) {
    if (event.severity === 'high') {
      this.notifySecurityTeam(event)
    }

    // Rate limiting check
    const recentEvents = this.events.filter(
      (e) =>
        e.type === event.type &&
        Date.now() - new Date(e.timestamp).getTime() < 60000,
    )

    if (recentEvents.length > 10) {
      this.handlePotentialAttack(event.type)
    }
  }

  notifySecurityTeam(event) {
    // Implementation depends on notification system
    console.error('Security Event:', event)
  }

  handlePotentialAttack(type) {
    // Implement defense mechanisms
    console.error(`Potential attack detected: ${type}`)
  }
}
```

Remember: Security is an ongoing process, not a one-time implementation. Regularly review and update security measures, monitor for new threats, and maintain compliance with evolving privacy regulations.
