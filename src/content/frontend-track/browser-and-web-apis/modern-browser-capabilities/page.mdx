# Modern Browser Capabilities - Part 1: Core Concepts

## Building the Mental Model

### The Modern Building Analogy

Think of modern browser capabilities like a sophisticated building system:

1. **Web Components (Modular Units)**

   - Like prefabricated rooms
   - Self-contained and reusable
   - Can be customized but maintain integrity

2. **Shadow DOM (Private Spaces)**

   - Like one-way mirrors
   - Internal structure hidden
   - External appearance controlled

3. **Browser Extensions (Add-on Buildings)**

   - Like attaching new structures
   - Access to building infrastructure
   - Separate but integrated

4. **Progressive Web Apps (Smart Buildings)**
   - Like buildings that work online and offline
   - Adapt to available resources
   - Provide consistent experience

## Web Components Deep Dive

### The Component Model

Think of Web Components like LEGO blocks:

1. **Custom Elements**

   - Define new HTML elements
   - Encapsulate functionality
   - Lifecycle management

2. **Shadow DOM**

   - Style encapsulation
   - DOM isolation
   - Scoped functionality

3. **HTML Templates**
   - Reusable markup
   - Inert until activated
   - Cloneable content

```javascript
// Basic Web Component Structure
class MyComponent extends HTMLElement {
  // Element created
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  // Element added to DOM
  connectedCallback() {
    this.render()
  }

  // Element removed from DOM
  disconnectedCallback() {
    this.cleanup()
  }

  // Attribute changed
  attributeChangedCallback(name, oldValue, newValue) {
    this.update(name, oldValue, newValue)
  }

  // Observed attributes
  static get observedAttributes() {
    return ['color', 'size']
  }
}
```

### Shadow DOM Architecture

Think of Shadow DOM like a one-way mirror in an interrogation room:

1. **Boundary Model**

```
Light DOM (Outside World)
     ↓
Shadow Boundary (One-way Mirror)
     ↓
Shadow DOM (Private Space)
```

2. **Encapsulation Levels**

```javascript
// Open Shadow DOM (Debuggable)
element.attachShadow({ mode: 'open' })

// Closed Shadow DOM (Private)
element.attachShadow({ mode: 'closed' })
```

3. **Style Isolation**

```css
/* Styles don't leak in or out */
:host {
  /* Styles for the component itself */
  display: block;
  padding: 20px;
}

::slotted(*) {
  /* Styles for slotted content */
  margin: 10px;
}

:host-context(.theme-dark) {
  /* Contextual styling */
  background: #333;
}
```

## Browser Extension Architecture

### The Plugin Model

Think of browser extensions like specialized tools that augment the browser:

1. **Extension Architecture**

```
manifest.json (Blueprint)
    ↓
Background Script (Brain)
    ↓
Content Scripts (Hands)
    ↓
Popup/Options (Interface)
```

2. **Communication Model**

```
Background Script ←→ Content Script
         ↕
    Extension UI
         ↕
  Browser APIs
```

3. **Security Model**

```json
{
  "manifest_version": 2,
  "permissions": ["tabs", "storage", "http://*/*", "https://*/*"],
  "content_security_policy": "script-src 'self'; object-src 'self'"
}
```

### Extension Components

1. **Background Script (Service Worker)**

```javascript
// Long-living event handler
chrome.runtime.onInstalled.addListener(() => {
  // Initialize extension
  chrome.storage.local.set({
    config: defaultConfig,
  })
})

// Message handling
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.type === 'getData') {
    // Handle request
    sendResponse({ data: 'response' })
  }
  return true // Keep message channel open
})
```

2. **Content Scripts**

```javascript
// Inject into web page
document.addEventListener('DOMContentLoaded', () => {
  // Modify page content
  const elements = document.querySelectorAll('.target')
  elements.forEach((el) => {
    // Apply extension modifications
  })
})

// Communicate with background
chrome.runtime.sendMessage(
  { type: 'pageData', data: extractedData },
  (response) => {
    // Handle response
  },
)
```

## Progressive Web Apps

### The PWA Mental Model

Think of PWAs like chameleon applications that adapt to their environment:

1. **Core Characteristics**

```
Web App
   ↓
Progressive Enhancement
   ↓
App-like Experience
   ↓
Offline Capability
```

2. **Technical Requirements**

```javascript
// Service Worker Registration
if ('serviceWorker' in navigator) {
  navigator.serviceWorker
    .register('/sw.js')
    .then((registration) => {
      console.log('SW registered:', registration)
    })
    .catch((error) => {
      console.log('SW registration failed:', error)
    })
}
```

3. **Manifest Structure**

```json
{
  "name": "My PWA",
  "short_name": "PWA",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#000000",
  "icons": [
    {
      "src": "/icon-192x192.png",
      "sizes": "192x192",
      "type": "image/png"
    }
  ]
}
```

### Service Worker Lifecycle

Think of Service Workers like loyal butlers for your web app:

1. **Registration & Installation**

```javascript
// Service Worker Installation
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('v1').then((cache) => {
      return cache.addAll(['/', '/styles/main.css', '/scripts/app.js'])
    }),
  )
})
```

2. **Activation**

```javascript
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((keys) => {
      return Promise.all(
        keys.filter((key) => key !== 'v1').map((key) => caches.delete(key)),
      )
    }),
  )
})
```

3. **Fetch Handling**

```javascript
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      // Return cached response or fetch
      return response || fetch(event.request)
    }),
  )
})
```

## Modern Web APIs Overview

### API Categories

1. **Performance APIs**

   - Performance Observer
   - Resource Timing
   - User Timing

2. **Device APIs**

   - Battery Status
   - Network Information
   - Geolocation

3. **Storage APIs**

   - Cache API
   - IndexedDB
   - Storage Manager

4. **Interaction APIs**
   - Pointer Events
   - Intersection Observer
   - ResizeObserver

# Modern Browser Capabilities - Part 2: Implementation Patterns

## Web Components Implementation Patterns

### Creating Reusable Components

1. **Basic Component Template**

```javascript
class CustomCard extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  static get template() {
    return `
      <style>
        :host {
          display: block;
          border: 1px solid #ddd;
          border-radius: 4px;
          padding: 16px;
        }
        
        .card-content {
          margin: 8px 0;
        }
        
        ::slotted(h2) {
          margin: 0;
          color: #333;
        }
      </style>
      
      <div class="card">
        <slot name="header"></slot>
        <div class="card-content">
          <slot></slot>
        </div>
        <slot name="footer"></slot>
      </div>
    `
  }

  connectedCallback() {
    this.render()
  }

  render() {
    this.shadowRoot.innerHTML = CustomCard.template
  }
}

customElements.define('custom-card', CustomCard)
```

2. **Component with State Management**

```javascript
class StatefulComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
    this._state = new Proxy(
      {},
      {
        set: (target, property, value) => {
          target[property] = value
          this.render()
          return true
        },
      },
    )
  }

  setState(newState) {
    Object.assign(this._state, newState)
  }

  get state() {
    return this._state
  }

  render() {
    // Implement render logic
  }
}
```

### Advanced Shadow DOM Patterns

1. **Style Composition**

```javascript
class ThemeableComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  static get styles() {
    return `
      /* Base styles */
      :host {
        --primary-color: #007bff;
        --secondary-color: #6c757d;
      }

      /* Theme variations */
      :host([theme="dark"]) {
        --primary-color: #0056b3;
        --secondary-color: #545b62;
      }

      /* Component styles */
      .component {
        color: var(--primary-color);
        background: var(--secondary-color);
      }
    `
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <style>${ThemeableComponent.styles}</style>
      <div class="component">
        <slot></slot>
      </div>
    `
  }
}
```

2. **Event Handling**

```javascript
class InteractiveComponent extends HTMLElement {
  constructor() {
    super()
    this.attachShadow({ mode: 'open' })
  }

  connectedCallback() {
    this.shadowRoot.innerHTML = `
      <div class="container">
        <button id="internal">Internal</button>
        <slot name="external"></slot>
      </div>
    `

    // Internal event handling
    this.shadowRoot
      .getElementById('internal')
      .addEventListener('click', this.handleInternalClick.bind(this))

    // External event handling
    this.addEventListener('external-event', this.handleExternalEvent)
  }

  handleInternalClick(event) {
    // Handle internal event
    this.dispatchEvent(
      new CustomEvent('internal-event', {
        bubbles: true,
        composed: true,
        detail: { source: 'internal' },
      }),
    )
  }

  handleExternalEvent(event) {
    // Handle external event
    console.log('External event:', event.detail)
  }
}
```

## Browser Extension Patterns

### State Management

1. **Centralized State**

```javascript
// background.js
class ExtensionState {
  constructor() {
    this.state = {}
    this.listeners = new Set()
  }

  setState(newState) {
    this.state = { ...this.state, ...newState }
    this.notifyListeners()

    // Persist to storage
    chrome.storage.local.set({ state: this.state })
  }

  subscribe(listener) {
    this.listeners.add(listener)
    return () => this.listeners.delete(listener)
  }

  notifyListeners() {
    this.listeners.forEach((listener) => listener(this.state))
  }
}

const state = new ExtensionState()

// Handle messages
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.type === 'STATE_UPDATE') {
    state.setState(message.payload)
  }
  return true
})
```

2. **Content Script Patterns**

```javascript
// content-script.js
class PageManager {
  constructor() {
    this.observer = new MutationObserver(this.handleDOMChanges.bind(this))
  }

  initialize() {
    // Observe DOM changes
    this.observer.observe(document.body, {
      childList: true,
      subtree: true,
    })

    // Initial setup
    this.setupPageModifications()
  }

  handleDOMChanges(mutations) {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE) {
          this.processNewElement(node)
        }
      })
    })
  }

  processNewElement(element) {
    // Apply extension modifications
    if (element.matches('.target-class')) {
      this.modifyElement(element)
    }
  }

  cleanup() {
    this.observer.disconnect()
  }
}

const manager = new PageManager()
manager.initialize()
```

## PWA Implementation Patterns

### Offline First Strategy

1. **Cache Management**

```javascript
// sw.js
class CacheManager {
  constructor(cacheName) {
    this.cacheName = cacheName
  }

  async cacheResources(resources) {
    const cache = await caches.open(this.cacheName)
    await cache.addAll(resources)
  }

  async respondToRequest(request) {
    // Try cache first
    const cachedResponse = await caches.match(request)
    if (cachedResponse) return cachedResponse

    try {
      // Fetch and cache
      const response = await fetch(request)
      if (response.ok) {
        const cache = await caches.open(this.cacheName)
        await cache.put(request, response.clone())
      }
      return response
    } catch (error) {
      // Handle offline
      return this.getOfflineFallback(request)
    }
  }

  async getOfflineFallback(request) {
    if (request.headers.get('accept').includes('text/html')) {
      return caches.match('/offline.html')
    }
    return new Response('Offline')
  }
}

const cacheManager = new CacheManager('v1')

self.addEventListener('fetch', (event) => {
  event.respondWith(cacheManager.respondToRequest(event.request))
})
```

2. **Background Sync**

```javascript
class SyncManager {
  constructor() {
    this.dbName = 'syncQueue'
    this.storeName = 'pendingRequests'
  }

  async queueRequest(request) {
    const db = await this.openDB()
    const tx = db.transaction(this.storeName, 'readwrite')
    await tx.store.add({
      url: request.url,
      method: request.method,
      headers: Array.from(request.headers.entries()),
      body: await request.clone().text(),
      timestamp: Date.now(),
    })
  }

  async processQueue() {
    const db = await this.openDB()
    const tx = db.transaction(this.storeName, 'readwrite')
    const requests = await tx.store.getAll()

    for (const request of requests) {
      try {
        await fetch(
          new Request(request.url, {
            method: request.method,
            headers: new Headers(request.headers),
            body: request.body,
          }),
        )

        // Remove successful request from queue
        await tx.store.delete(request.id)
      } catch (error) {
        console.error('Sync failed:', error)
        // Keep in queue for next sync attempt
      }
    }
  }

  async openDB() {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1)

      request.onerror = () => reject(request.error)
      request.onsuccess = () => resolve(request.result)

      request.onupgradeneeded = (event) => {
        const db = event.target.result
        db.createObjectStore(this.storeName, {
          keyPath: 'id',
          autoIncrement: true,
        })
      }
    })
  }
}

// Usage in Service Worker
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-requests') {
    event.waitUntil(new SyncManager().processQueue())
  }
})
```

### App Shell Architecture

```javascript
class AppShell {
  constructor() {
    this.shellResources = [
      '/',
      '/styles/shell.css',
      '/scripts/shell.js',
      '/images/logo.png',
    ]
  }

  async install() {
    const cache = await caches.open('app-shell-v1')
    await cache.addAll(this.shellResources)
  }

  async serve(request) {
    // Check if request is for shell resource
    if (this.isShellResource(request.url)) {
      const cache = await caches.open('app-shell-v1')
      const cached = await cache.match(request)
      if (cached) return cached
    }

    // Dynamic content handling
    return this.handleDynamicContent(request)
  }

  isShellResource(url) {
    return this.shellResources.some((resource) => url.endsWith(resource))
  }

  async handleDynamicContent(request) {
    try {
      // Attempt network first for dynamic content
      const response = await fetch(request)
      if (response.ok) {
        // Cache successful responses
        const cache = await caches.open('dynamic-v1')
        await cache.put(request, response.clone())
        return response
      }
    } catch (error) {
      // Network failure, try cache
      const cached = await caches.match(request)
      if (cached) return cached
    }

    // Fallback response
    return this.getOfflineResponse()
  }
}
```

## Modern Web APIs Implementation Patterns

### Performance Monitoring

```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map()
    this.observers = new Map()
  }

  observe(metricType, callback) {
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries()
      this.metrics.set(metricType, entries)
      callback(entries)
    })

    observer.observe({ entryTypes: [metricType] })
    this.observers.set(metricType, observer)
  }

  startMeasure(name) {
    performance.mark(`${name}-start`)
  }

  endMeasure(name) {
    performance.mark(`${name}-end`)
    performance.measure(name, `${name}-start`, `${name}-end`)
  }

  getMetrics() {
    const metrics = {}
    this.metrics.forEach((value, key) => {
      metrics[key] = value
    })
    return metrics
  }

  disconnect() {
    this.observers.forEach((observer) => observer.disconnect())
    this.observers.clear()
    this.metrics.clear()
  }
}

// Usage
const monitor = new PerformanceMonitor()

// Observe LCP
monitor.observe('largest-contentful-paint', (entries) => {
  const lcp = entries[entries.length - 1]
  console.log('LCP:', lcp.startTime)
})

// Custom measurements
monitor.startMeasure('critical-operation')
// ... perform operation
monitor.endMeasure('critical-operation')
```

### Intersection Observer Patterns

```javascript
class ViewportObserver {
  constructor(options = {}) {
    this.options = {
      root: options.root || null,
      rootMargin: options.rootMargin || '0px',
      threshold: options.threshold || 0.1,
    }

    this.observers = new Map()
  }

  observe(element, callbacks) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          callbacks.onEnter?.(entry)
        } else {
          callbacks.onExit?.(entry)
        }
      })
    }, this.options)

    observer.observe(element)
    this.observers.set(element, observer)

    return () => this.unobserve(element)
  }

  unobserve(element) {
    const observer = this.observers.get(element)
    if (observer) {
      observer.unobserve(element)
      this.observers.delete(element)
    }
  }

  disconnect() {
    this.observers.forEach((observer) => observer.disconnect())
    this.observers.clear()
  }
}

// Example: Infinite Scroll
class InfiniteScroll {
  constructor(container, loadMore) {
    this.container = container
    this.loadMore = loadMore
    this.loading = false
    this.observer = new ViewportObserver({
      rootMargin: '100px',
    })
  }

  initialize() {
    // Create sentinel element
    this.sentinel = document.createElement('div')
    this.container.appendChild(this.sentinel)

    // Observe sentinel
    this.observer.observe(this.sentinel, {
      onEnter: () => this.handleIntersection(),
    })
  }

  async handleIntersection() {
    if (this.loading) return

    this.loading = true
    try {
      await this.loadMore()
    } finally {
      this.loading = false
    }
  }
}
```

### Storage API Patterns

```javascript
class StorageManager {
  constructor() {
    this.quotaLimit = null
  }

  async initialize() {
    if ('storage' in navigator) {
      const estimate = await navigator.storage.estimate()
      this.quotaLimit = estimate.quota
      return {
        usage: estimate.usage,
        quota: estimate.quota,
        available: estimate.quota - estimate.usage,
      }
    }
    throw new Error('Storage API not supported')
  }

  async requestPersistence() {
    if ('persist' in navigator.storage) {
      const isPersisted = await navigator.storage.persist()
      return isPersisted
    }
    return false
  }

  async clearUnusedSpace() {
    if ('storage' in navigator) {
      try {
        await navigator.storage.estimate()
        const caches = await window.caches.keys()
        await Promise.all(caches.map((name) => this.trimCache(name)))
      } catch (error) {
        console.error('Storage cleanup failed:', error)
      }
    }
  }

  async trimCache(cacheName, maxItems = 100) {
    const cache = await caches.open(cacheName)
    const keys = await cache.keys()

    if (keys.length > maxItems) {
      const itemsToDelete = keys.slice(0, keys.length - maxItems)
      await Promise.all(itemsToDelete.map((key) => cache.delete(key)))
    }
  }
}
```

Remember: Modern browser capabilities provide powerful tools, but always implement with progressive enhancement in mind and provide fallbacks for older browsers or when APIs are unavailable.
