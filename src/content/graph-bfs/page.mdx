export const metadata = {
  title: 'Comprehensive Guide to Graph BFS in JavaScript',
  description: 'Traverse graphs using Breadth-First Search. Understand graph BFS, performance considerations, and practical examples.',
}

# **Graph BFS (Breadth-First Search)**

The Breadth-First Search (BFS) technique is a fundamental algorithm for traversing or searching graph data structures. BFS operates by exploring vertices level by level, starting from a source vertex and moving to the next level vertices.

## **Concept and Use Cases**

**Definition:** 
BFS is an algorithm for traversing or searching graph data structures. It starts at a source vertex and explores all the neighbor vertices at the present depth prior to moving on to vertices at the next depth level.

**Common Use Cases:**
- Finding the shortest path in an unweighted graph.
- Checking connectivity in a graph.
- Solving puzzles and games (e.g., finding the shortest path in a maze).

## **When to Use**
- When you need to find the shortest path in an unweighted graph.
- When checking if a graph is connected.
- When you need to traverse or explore vertices level by level.

## **Time and Space Complexity**

**Time Complexity:** 
- O(V + E), where V is the number of vertices and E is the number of edges. Each vertex and edge is explored once.

**Space Complexity:**
- O(V), due to the space required to store the queue and the visited set.

## **Graph BFS for Finding Shortest Path**

**Problem:** Given a graph and a source vertex, return the shortest path from the source to all other vertices.

**Step-by-Step Solution:**
1. Use a queue to keep track of vertices to explore.
2. Initialize the queue with the source vertex.
3. While the queue is not empty, process each vertex and add its unvisited neighbors to the queue.
4. Keep track of distances from the source to each vertex.

**Code Example:**
```javascript
function bfsShortestPath(graph, start) {
    let distances = {};
    let queue = [start];
    distances[start] = 0;

    while (queue.length > 0) {
        let vertex = queue.shift();

        for (let neighbor of graph[vertex]) {
            if (!(neighbor in distances)) {
                distances[neighbor] = distances[vertex] + 1;
                queue.push(neighbor);
            }
        }
    }

    return distances;
}

// Example usage:
const graph = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E']
};
console.log(bfsShortestPath(graph, 'A'));  // Output: { A: 0, B: 1, C: 1, D: 2, E: 2, F: 2 }
```

**Tips and Tricks:**
- Use a queue to keep track of vertices to explore.
- Keep track of distances from the source to each vertex.
- Ensure to process all neighbors of the current vertex before moving to the next level.

**Frequent Gotchas:**
- Forgetting to check if a vertex has already been visited.
- Not updating the distances correctly, leading to incorrect results.
- Handling disconnected graphs, where not all vertices are reachable from the source.

## **Finding Connected Components in an Undirected Graph**

**Problem:** Given an undirected graph, find all its connected components.

**Step-by-Step Solution:**
1. Use a queue to keep track of vertices to explore.
2. Initialize the queue with an unvisited vertex.
3. While the queue is not empty, process each vertex and add its unvisited neighbors to the queue.
4. Track visited vertices to ensure all connected components are found.

**Code Example:**
```javascript
function findConnectedComponents(graph) {
    let visited = new Set();
    let components = [];

    for (let vertex in graph) {
        if (!visited.has(vertex)) {
            let component = [];
            let queue = [vertex];

            while (queue.length > 0) {
                let v = queue.shift();
                if (!visited.has(v)) {
                    visited.add(v);
                    component.push(v);

                    for (let neighbor of graph[v]) {
                        if (!visited.has(neighbor)) {
                            queue.push(neighbor);
                        }
                    }
                }
            }

            components.push(component);
        }
    }

    return components;
}

// Example usage:
const graph = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E'],
    G: ['H'],
    H: ['G']
};
console.log(findConnectedComponents(graph));  // Output: [ [ 'A', 'B', 'C', 'D', 'E', 'F' ], [ 'G', 'H' ] ]
```

**Tips and Tricks:**
- Use a queue to explore vertices level by level.
- Track visited vertices to avoid revisiting and to identify all components.
- Ensure to explore all vertices in the graph.

**Frequent Gotchas:**
- Forgetting to check for already visited vertices.
- Not handling disconnected graphs correctly, leading to incomplete components.
- Ensuring all vertices, even isolated ones, are processed.

## **Detecting Cycles in an Undirected Graph**

**Problem:** Given an undirected graph, determine if it contains any cycles.

**Step-by-Step Solution:**
1. Use a queue to keep track of vertices to explore and their parents.
2. Initialize the queue with an unvisited vertex.
3. While the queue is not empty, process each vertex and add its unvisited neighbors to the queue.
4. Check if a vertex is revisited through a different path.

**Code Example:**
```javascript
function containsCycle(graph) {
    let visited = new Set();

    for (let vertex in graph) {
        if (!visited.has(vertex)) {
            let queue = [{ vertex, parent: null }];

            while (queue.length > 0) {
                let { vertex: v, parent } = queue.shift();
                if (!visited.has(v)) {
                    visited.add(v);

                    for (let neighbor of graph[v]) {
                        if (!visited.has(neighbor)) {
                            queue.push({ vertex: neighbor, parent: v });
                        } else if (neighbor !== parent) {
                            return true;  // Cycle detected
                        }
                    }
                }
            }
        }
    }

    return false;  // No cycle detected
}

// Example usage:
const graph = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E']
};
console.log(containsCycle(graph));  // Output: true
```

**Tips and Tricks:**
- Use a queue to explore vertices and track their parents.
- Check if a vertex is revisited through a different path to detect cycles.
- Ensure to explore all vertices to cover the entire graph.

**Frequent Gotchas:**
- Forgetting to check for already visited vertices.
- Not tracking the parent vertices correctly, leading to false positives.
- Handling disconnected graphs and isolated cycles.

## **Finding the Shortest Path in an Unweighted Graph**

**Problem:** Given an unweighted graph and a source vertex, find the shortest path from the source to all other vertices.

**Step-by-Step Solution:**
1. Use a queue to keep track of vertices to explore.
2. Initialize the queue with the source vertex.
3. While the queue is not empty, process each vertex and add its unvisited neighbors to the queue.
4. Keep track of distances from the source to each vertex.

**Code Example:**
```javascript
function bfsShortestPath(graph, start) {
    let distances = {};
    let queue = [start];
    distances[start] = 0;

    while (queue.length > 0) {
        let vertex = queue.shift();

        for (let neighbor of graph[vertex]) {
            if (!(neighbor in distances)) {
                distances[neighbor] = distances[vertex] + 1;
                queue.push(neighbor);
            }
        }
    }

    return distances;
}

// Example usage:
const graph = {
    A: ['B', 'C'],
    B: ['A', 'D', 'E'],
    C: ['A', 'F'],
    D: ['B'],
    E: ['B', 'F'],
    F: ['C', 'E']
};
console.log(bfsShortestPath(graph, 'A'));  // Output: { A: 0, B: 1, C: 1, D: 2, E: 2, F: 2 }
```

**Tips and Tricks:**
- Use a queue to keep track of vertices to explore.
- Keep track of distances from the source to each vertex.
- Ensure to process all neighbors of the current vertex before moving to the next level.

**Frequent Gotchas:**
- Forgetting to check if a vertex has already been visited.
- Not updating the distances correctly, leading to incorrect results.
- Handling disconnected graphs, where not all vertices are reachable from the source.

By mastering the Graph BFS (Breadth-First Search) technique, you can efficiently solve a variety of problems involving shortest paths, connectivity, and cycle detection in graphs. This technique is essential for optimizing time complexity and handling graph-related data structures effectively in both technical interviews and real-world applications.

## **Practice Problems**

1. [Number of Islands](https://leetcode.com/problems/number-of-islands/)
2. [Clone Graph](https://leetcode.com/problems/clone-graph/)
3. [Word Ladder](https://leetcode.com/problems/word-ladder/)
4. [Course Schedule](https://leetcode.com/problems/course-schedule/)
5. [Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/)