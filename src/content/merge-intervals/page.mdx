export const metadata = {
  title: 'Comprehensive Guide to Merge Intervals Technique in JavaScript',
  description: 'Combine overlapping intervals efficiently. Understand the merge intervals technique, performance considerations, and practical examples.',
}

# **Merge Intervals Technique**

The Merge Intervals pattern is an efficient technique to deal with overlapping intervals. It is often used in problems where you need to merge overlapping intervals, insert new intervals, or find the intersections of intervals.

## **Concept and Use Cases**

**Definition:** 
The Merge Intervals pattern involves sorting intervals and then merging them if they overlap. It is particularly useful in scenarios where you have a list of intervals and need to condense them into a non-overlapping set of intervals.

**Common Use Cases:**
- Merging overlapping intervals.
- Inserting an interval into a list of intervals.
- Finding the intersection of intervals.
- Scheduling problems, such as finding free time slots.

## **When to Use**
- When dealing with a list of intervals and needing to consolidate or find relationships between them.
- When inserting new intervals into a sorted list of intervals.
- When intervals need to be merged based on their overlap.

## **Time and Space Complexity**

**Time Complexity:** 
- O(n log n) for sorting the intervals, where n is the number of intervals.
- O(n) for merging the intervals after sorting.

**Space Complexity:**
- O(n) for storing the merged intervals.

## **Merging Overlapping Intervals**

**Problem:** Given a list of intervals, merge all overlapping intervals.

**Step-by-Step Solution:**
1. Sort the intervals based on the start time.
2. Initialize a result array with the first interval.
3. Iterate through the intervals and merge them if they overlap.

**Code Example:**
```javascript
function mergeIntervals(intervals) {
    if (intervals.length < 2) {
        return intervals;
    }

    // Sort intervals by start time
    intervals.sort((a, b) => a[0] - b[0]);

    const merged = [];
    let currentInterval = intervals[0];
    merged.push(currentInterval);

    for (let i = 1; i < intervals.length; i++) {
        const [currentStart, currentEnd] = currentInterval;
        const [nextStart, nextEnd] = intervals[i];

        if (currentEnd >= nextStart) {
            // Overlapping intervals, merge them
            currentInterval[1] = Math.max(currentEnd, nextEnd);
        } else {
            // No overlap, add the current interval to merged and move to the next
            currentInterval = intervals[i];
            merged.push(currentInterval);
        }
    }

    return merged;
}

// Example usage:
const intervals = [[1, 3], [2, 6], [8, 10], [15, 18]];
console.log(mergeIntervals(intervals));  // Output: [[1, 6], [8, 10], [15, 18]]
```

**Tips and Tricks:**
- Always sort the intervals before attempting to merge them to ensure they are in a consistent order.
- Use a two-pointer approach to compare the current interval with the next one to check for overlaps.
- Keep track of the maximum end time when merging overlapping intervals.

**Frequent Gotchas:**
- Forgetting to sort the intervals before merging, leading to incorrect results.
- Incorrectly updating the current interval, causing missed merges or incorrect intervals.
- Handling edge cases, such as intervals with the same start or end times.

## **Inserting an Interval**

**Problem:** Given a list of non-overlapping intervals sorted by their start time, insert a new interval into the list and merge if necessary.

**Step-by-Step Solution:**
1. Iterate through the list of intervals and add all intervals that come before the new interval.
2. Merge all overlapping intervals with the new interval.
3. Add all remaining intervals after the new interval.

**Code Example:**
```javascript
function insertInterval(intervals, newInterval) {
    const merged = [];
    let i = 0;

    // Add all intervals before the new interval
    while (i < intervals.length && intervals[i][1] < newInterval[0]) {
        merged.push(intervals[i]);
        i++;
    }

    // Merge all overlapping intervals with the new interval
    while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
        newInterval[0] = Math.min(newInterval[0], intervals[i][0]);
        newInterval[1] = Math.max(newInterval[1], intervals[i][1]);
        i++;
    }
    merged.push(newInterval);

    // Add all remaining intervals after the new interval
    while (i < intervals.length) {
        merged.push(intervals[i]);
        i++;
    }

    return merged;
}

// Example usage:
const intervals = [[1, 3], [6, 9]];
const newInterval = [2, 5];
console.log(insertInterval(intervals, newInterval));  // Output: [[1, 5], [6, 9]]
```

**Tips and Tricks:**
- Use a three-step approach: add intervals before, merge overlapping, and add intervals after.
- Update the new interval's start and end times while merging overlapping intervals.
- Consider edge cases where the new interval does not overlap with any existing intervals.

**Frequent Gotchas:**
- Forgetting to add intervals that come before the new interval.
- Incorrectly updating the new interval during the merge process.
- Handling edge cases, such as the new interval starting or ending exactly at the same time as existing intervals.

## **Finding the Intersection of Intervals**

**Problem:** Given two lists of intervals, find the intersection of these two interval lists. Each list is pairwise disjoint and in sorted order.

**Step-by-Step Solution:**
1. Use two pointers to iterate through both lists of intervals.
2. Compare intervals from both lists and find the intersection.
3. Move the pointer with the interval that ends first to continue finding intersections.

**Code Example:**
```javascript
function intervalIntersection(A, B) {
    const intersections = [];
    let i = 0, j = 0;

    while (i < A.length && j < B.length) {
        const [startA, endA] = A[i];
        const [startB, endB] = B[j];

        const start = Math.max(startA, startB);
        const end = Math.min(endA, endB);

        if (start <= end) {
            intersections.push([start, end]);
        }

        if (endA < endB) {
            i++;
        } else {
            j++;
        }
    }

    return intersections;
}

// Example usage:
const A = [[0, 2], [5, 10], [13, 23], [24, 25]];
const B = [[1, 5], [8, 12], [15, 24], [25, 26]];
console.log(intervalIntersection(A, B));  // Output: [[1, 2], [5, 5], [8, 10], [15, 23], [24, 24], [25, 25]]
```

**Tips and Tricks:**
- Use the two-pointer technique to efficiently find intersections.
- Compare the start and end times of intervals to determine the intersection.
- Move the pointer with the interval that ends first to continue finding intersections.

**Frequent Gotchas:**
- Incorrectly comparing interval start and end times, leading to missed intersections.
- Handling edge cases, such as intervals with no overlap.
- Ensuring the lists are in sorted order before finding intersections.

By mastering the Merge Intervals technique, you can efficiently solve a variety of problems involving overlapping intervals, scheduling, and more. This technique is essential for optimizing time complexity and handling interval-related data structures effectively in both technical interviews and real-world applications.

 