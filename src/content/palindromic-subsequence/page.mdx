# **Palindromic Subsequence**

The Palindromic Subsequence technique involves finding the longest subsequence within a string that reads the same backward as forward. This technique is often solved using dynamic programming and is a common problem in technical interviews due to its complexity and applications.

## **Concept and Use Cases**

**Definition:**
A palindromic subsequence is a sequence of characters in a string that forms a palindrome when read both forwards and backwards. The characters of the subsequence do not need to be contiguous in the original string, but they must appear in the same order.

**Common Use Cases:**
- Finding the longest palindromic subsequence in a given string.
- Applications in bioinformatics for DNA sequence analysis.
- Solving problems related to string manipulations and optimizations.

## **When to Use**
- When you need to find the longest subsequence in a string that forms a palindrome.
- When dealing with problems involving string comparisons and optimizations.
- When solving dynamic programming problems related to subsequences and substrings.

## **Time and Space Complexity**

**Time Complexity:**
- O(n^2), where n is the length of the string. This is due to the need to check all pairs of substrings.

**Space Complexity:**
- O(n^2) for the dynamic programming table used to store intermediate results.

## **Common Problems**

1. **Longest Palindromic Subsequence:**
   - **Problem:** Find the length of the longest palindromic subsequence in a given string.
   - **Approach:** Use dynamic programming to fill a table of subproblem solutions.

2. **Minimum Deletions to Make a String Palindromic:**
   - **Problem:** Given a string, find the minimum number of deletions required to make it a palindrome.
   - **Approach:** Calculate the length of the longest palindromic subsequence and subtract it from the total length of the string.

3. **Longest Palindromic Substring:**
   - **Problem:** Find the longest palindromic substring in a given string.
   - **Approach:** Use dynamic programming or expand around center technique to identify the longest palindromic substring.

## **Longest Palindromic Subsequence**

**Problem:** Given a string, find the length of the longest palindromic subsequence.

**Step-by-Step Solution:**
1. Create a 2D array `dp` where `dp[i][j]` represents the length of the longest palindromic subsequence in the substring `s[i...j]`.
2. Initialize the table such that `dp[i][i] = 1` for all `i`, since a single character is always a palindrome of length 1.
3. Fill the table in a bottom-up manner. For each substring length `cl` from 2 to n:
   - For each starting index `i` from 0 to n - cl:
     - Set the ending index `j` as `i + cl - 1`.
     - If `s[i] == s[j]` and the length is 2, set `dp[i][j] = 2`.
     - If `s[i] == s[j]` and the length is greater than 2, set `dp[i][j] = dp[i + 1][j - 1] + 2`.
     - If `s[i] != s[j]`, set `dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])`.
4. The result is stored in `dp[0][n - 1]`.

**Code Example:**
```javascript
function longestPalindromicSubsequence(s) {
    const n = s.length;
    const dp = Array.from({ length: n }, () => Array(n).fill(0));

    // Base case: single letters are palindromes of length 1
    for (let i = 0; i < n; i++) {
        dp[i][i] = 1;
    }

    // Fill the table
    for (let cl = 2; cl <= n; cl++) {
        for (let i = 0; i < n - cl + 1; i++) {
            const j = i + cl - 1;
            if (s[i] === s[j] && cl === 2) {
                dp[i][j] = 2;
            } else if (s[i] === s[j]) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            } else {
                dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }

    return dp[0][n - 1];
}

// Example usage:
const s = "bbbab";
console.log(longestPalindromicSubsequence(s));  // Output: 4 ("bbbb")
```

**Tips and Tricks:**
- Use a bottom-up dynamic programming approach to fill the table.
- Carefully handle the indices to avoid out-of-bounds errors.

**Frequent Gotchas:**
- Forgetting to initialize the base cases correctly.
- Incorrectly updating the table for matching characters.
- Handling edge cases where the string is empty or contains all unique characters.

## **Minimum Deletions to Make a String Palindromic**

**Problem:** Given a string, find the minimum number of deletions required to make it a palindrome.

**Step-by-Step Solution:**
1. Calculate the length of the longest palindromic subsequence using the previously described method.
2. Subtract the length of the longest palindromic subsequence from the total length of the string.
3. The result is the minimum number of deletions required.

**Code Example:**
```javascript
function minDeletionsToMakePalindrome(s) {
    const n = s.length;

    function longestPalindromicSubsequence(s) {
        const dp = Array.from({ length: n }, () => Array(n).fill(0));

        for (let i = 0; i < n; i++) {
            dp[i][i] = 1;
        }

        for (let cl = 2; cl <= n; cl++) {
            for (let i = 0; i < n - cl + 1; i++) {
                const j = i + cl - 1;
                if (s[i] === s[j] && cl === 2) {
                    dp[i][j] = 2;
                } else if (s[i] === s[j]) {
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }

        return dp[0][n - 1];
    }

    const lpsLength = longestPalindromicSubsequence(s);
    return n - lpsLength;
}

// Example usage:
const s = "abcbad";
console.log(minDeletionsToMakePalindrome(s));  // Output: 2 ("bcb" is the LPS, so remove 'a' and 'd')
```

**Tips and Tricks:**
- Use the length of the longest palindromic subsequence to determine the minimum deletions.
- Leverage the dynamic programming table to solve related problems efficiently.

**Frequent Gotchas:**
- Forgetting to consider both ends of the string when calculating the longest palindromic subsequence.
- Incorrectly initializing or updating the dynamic programming table.

By mastering the Palindromic Subsequence technique, you can efficiently solve a variety of problems involving palindromes, subsequences, and dynamic programming. This technique is essential for optimizing time complexity and handling string-related problems effectively in both technical interviews and real-world applications.

 