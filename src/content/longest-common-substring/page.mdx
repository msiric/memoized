export const metadata = {
  title: 'Comprehensive Guide to Longest Common Substring in JavaScript',
  description: 'Find the longest substring common to two strings. Understand longest common substring algorithms, performance considerations, and practical examples.',
}

# **Longest Common Substring**

The Longest Common Substring technique involves finding the longest substring that is common to two or more strings. This is a classic problem in computer science and has applications in bioinformatics, text processing, and data comparison. The problem is commonly solved using dynamic programming due to its overlapping subproblems and optimal substructure properties.

## **Concept and Use Cases**

**Definition:**
A common substring is a sequence of characters that appears in the same order in both strings. The longest common substring is the longest sequence that appears in both strings.

**Common Use Cases:**
- Finding the longest common substring in bioinformatics for DNA sequence analysis.
- Text processing for plagiarism detection.
- Data comparison in version control systems.

## **When to Use**
- When you need to find the longest sequence of characters that appears in two strings.
- When solving problems involving string matching and comparisons.
- When dealing with dynamic programming problems related to substrings.

## **Time and Space Complexity**

**Time Complexity:**
- O(m * n), where m and n are the lengths of the two strings. This is due to the need to compare all pairs of substrings.

**Space Complexity:**
- O(m * n) for the dynamic programming table used to store intermediate results.

## **Common Problems**

1. **Longest Common Substring:**
   - **Problem:** Find the length of the longest common substring in two given strings.
   - **Approach:** Use dynamic programming to fill a table of subproblem solutions.

2. **Finding the Longest Common Substring Itself:**
   - **Problem:** Find the actual longest common substring in two given strings.
   - **Approach:** Use dynamic programming and backtracking to reconstruct the longest common substring.

## **Longest Common Substring**

**Problem:** Given two strings, find the length of the longest common substring.

**Step-by-Step Solution:**
1. Create a 2D array `dp` where `dp[i][j]` represents the length of the longest common substring ending at `s1[i-1]` and `s2[j-1]`.
2. Initialize the table with zeros.
3. Iterate through both strings, and for each pair of characters `(s1[i-1], s2[j-1])`:
   - If the characters match, set `dp[i][j] = dp[i-1][j-1] + 1`.
   - If the characters do not match, set `dp[i][j] = 0`.
4. Keep track of the maximum value in the `dp` table, which represents the length of the longest common substring.

**Code Example:**
```javascript
function longestCommonSubstring(s1, s2) {
    const m = s1.length;
    const n = s2.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    let maxLength = 0;

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s1[i - 1] === s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                maxLength = Math.max(maxLength, dp[i][j]);
            } else {
                dp[i][j] = 0;
            }
        }
    }

    return maxLength;
}

// Example usage:
const s1 = "abcdxyz";
const s2 = "xyzabcd";
console.log(longestCommonSubstring(s1, s2));  // Output: 4 ("abcd")
```

**Tips and Tricks:**
- Use a dynamic programming table to store the lengths of common substrings ending at each pair of indices.
- Initialize the table with zeros to handle base cases.
- Keep track of the maximum value in the table to get the length of the longest common substring.

**Frequent Gotchas:**
- Forgetting to initialize the table with zeros.
- Incorrectly updating the table for matching characters.
- Handling edge cases where one or both strings are empty.

## **Finding the Longest Common Substring Itself**

**Problem:** Given two strings, find the actual longest common substring.

**Step-by-Step Solution:**
1. Create a 2D array `dp` where `dp[i][j]` represents the length of the longest common substring ending at `s1[i-1]` and `s2[j-1]`.
2. Initialize the table with zeros.
3. Iterate through both strings, and for each pair of characters `(s1[i-1], s2[j-1])`:
   - If the characters match, set `dp[i][j] = dp[i-1][j-1] + 1`.
   - If the characters do not match, set `dp[i][j] = 0`.
4. Keep track of the maximum value in the `dp` table and its corresponding index.
5. Use the index to reconstruct the longest common substring.

**Code Example:**
```javascript
function findLongestCommonSubstring(s1, s2) {
    const m = s1.length;
    const n = s2.length;
    const dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));
    let maxLength = 0;
    let endIndex = 0;

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s1[i - 1] === s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
                if (dp[i][j] > maxLength) {
                    maxLength = dp[i][j];
                    endIndex = i - 1;
                }
            } else {
                dp[i][j] = 0;
            }
        }
    }

    const longestCommonSubstring = s1.slice(endIndex - maxLength + 1, endIndex + 1);
    return longestCommonSubstring;
}

// Example usage:
const s1 = "abcdxyz";
const s2 = "xyzabcd";
console.log(findLongestCommonSubstring(s1, s2));  // Output: "abcd"
```

**Tips and Tricks:**
- Use the `dp` table to keep track of the lengths of common substrings ending at each pair of indices.
- Keep track of the maximum value and its corresponding index to reconstruct the longest common substring.

**Frequent Gotchas:**
- Forgetting to initialize the table with zeros.
- Incorrectly updating the table for matching characters.
- Handling edge cases where one or both strings are empty.

By mastering the Longest Common Substring technique, you can efficiently solve a variety of problems involving string comparisons, substrings, and dynamic programming. This technique is essential for optimizing time complexity and handling string-related problems effectively in both technical interviews and real-world applications.

 