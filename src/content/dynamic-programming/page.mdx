export const metadata = {
  title: 'Comprehensive Guide to Dynamic Programming in JavaScript',
  description: 'Solve complex problems by breaking them into simpler subproblems. Understand dynamic programming, performance considerations, and practical examples.',
}

# **Dynamic Programming**

Dynamic Programming (DP) is a powerful technique for solving problems by breaking them down into simpler subproblems and storing the results of these subproblems to avoid redundant computations. It is particularly useful for optimization problems.

## **Concept and Use Cases**

**Definition:**
Dynamic Programming is a method for solving complex problems by breaking them down into simpler subproblems. It involves two key ideas: overlapping subproblems and optimal substructure.

**Common Use Cases:**
- Optimization problems (e.g., shortest paths, knapsack problem).
- Sequence alignment in bioinformatics.
- Substring and subsequence problems.

### **Visual Representation:**
Consider the problem of finding the number of ways to climb a staircase with `n` steps, where you can take either 1 or 2 steps at a time. The subproblems and their overlap can be visualized as follows:

```
ways(5)
|
|-- ways(4)
|   |
|   |-- ways(3)
|   |   |
|   |   |-- ways(2)
|   |   |   |
|   |   |   |-- ways(1) = 1
|   |   |   |-- ways(0) = 1
|   |   |
|   |   |-- ways(1) = 1
|   |
|   |-- ways(2)
|       |
|       |-- ways(1) = 1
|       |-- ways(0) = 1
|
|-- ways(3)
    |
    |-- ways(2)
    |   |
    |   |-- ways(1) = 1
    |   |-- ways(0) = 1
    |
    |-- ways(1) = 1
```
In this tree, you can see that `ways(2)`, `ways(1)`, and `ways(0)` are calculated multiple times. By using DP, we store these results to avoid redundant calculations.

## **Key Concepts**

1. **Overlapping Subproblems:**
   - The problem can be broken down into subproblems, which are reused several times.
   
2. **Optimal Substructure:**
   - The optimal solution of the problem can be constructed from the optimal solutions of its subproblems.

## **Techniques**

1. **Memoization (Top-Down):**
   - Solve the problem recursively and store the results of subproblems in a table (usually a dictionary or array) to avoid redundant computations.
   
2. **Tabulation (Bottom-Up):**
   - Solve the problem iteratively by filling up a table in a bottom-up manner, starting from the base cases.

## **Time and Space Complexity**

**Time Complexity:**
- Typically O(n) for problems where n is the size of the input (e.g., length of a sequence), but it can vary based on the specific problem.

**Space Complexity:**
- Depends on the problem; typically O(n) for the memoization table.

## **Dynamic Programming Operations and Methods**

### **Climbing Stairs**

**Problem:**
You are climbing a staircase. It takes `n` steps to reach the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Memoization Approach:**

**Example:**
```javascript
function climbStairs(n, memo = {}) {
    if (n <= 2) return n;
    if (memo[n]) return memo[n];
    memo[n] = climbStairs(n - 1, memo) + climbStairs(n - 2, memo);
    return memo[n];
}

console.log(climbStairs(5));  // Output: 8
```

**Tabulation Approach:**

**Example:**
```javascript
function climbStairs(n) {
    if (n <= 2) return n;
    let dp = [0, 1, 2];
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}

console.log(climbStairs(5));  // Output: 8
```

### **Longest Common Subsequence**

**Problem:**
Find the length of the longest common subsequence between two strings.

**Example:**
```javascript
function longestCommonSubsequence(s1, s2) {
    let m = s1.length, n = s2.length;
    let dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

    for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
            if (s1[i - 1] === s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1;
            } else {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[m][n];
}

console.log(longestCommonSubsequence('abcde', 'ace'));  // Output: 3
```

### **Knapsack Problem**

**Problem:**
Given weights and values of n items, put these items in a knapsack of capacity W to get the maximum total value in the knapsack.

**Example:**
```javascript
function knapsack(values, weights, W) {
    let n = values.length;
    let dp = Array.from({ length: n + 1 }, () => Array(W + 1).fill(0));

    for (let i = 1; i <= n; i++) {
        for (let w = 0; w <= W; w++) {
            if (weights[i - 1] <= w) {
                dp[i][w] = Math.max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]);
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }
    return dp[n][W];
}

let values = [60, 100, 120];
let weights = [10, 20, 30];
let W = 50;

console.log(knapsack(values, weights, W));  // Output: 220
```

### **Edit Distance**

**Problem:**
Compute the minimum number of operations (insertions, deletions, or substitutions) required to transform one string into another.

**Example:**
```javascript
function editDistance(s1, s2) {
    let m = s1.length, n = s2.length;
    let dp = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));

    for (let i = 0; i <= m; i++) {
        for (let j = 0; j <= n; j++) {
            if (i === 0) {
                dp[i][j] = j;  // Insert all characters of s2
            } else if (j === 0) {
                dp[i][j] = i;  // Remove all characters of s1
            } else if (s1[i - 1] === s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1];
            } else {
                dp[i][j] = 1 + Math.min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]);  // Insert, Remove, Replace
            }
        }
    }
    return dp[m][n];
}

console.log(editDistance('kitten', 'sitting'));  // Output: 3
```

## **Practical Tips and Tricks**

- **Identify Overlapping Subproblems:**
  Look for problems that can be divided into smaller, similar subproblems.
  
- **Optimal Substructure Property:**
  Ensure the problem can be broken down such that the solution to the problem can be constructed from solutions to its subproblems.

- **Memoization vs. Tabulation:**
  - **Memoization:** Use when the problem is naturally recursive. Store the results of expensive function calls.
  - **Tabulation:** Use when you can iteratively build up the solution from the base cases.

- **Initialization:**
  Carefully initialize the DP table, especially the base cases.

## **Common Gotchas**

- **Incorrect Base Cases:**
  Make sure to correctly define and initialize base cases to avoid incorrect results.

- **Overlapping Subproblems:**
  Ensure you correctly identify and handle overlapping subproblems to avoid redundant calculations.

- **Table Size:**
  Be mindful of the memory usage when creating DP tables, especially for large inputs.

## **Advanced Topics**

### **Bitmask DP**

**Problem:**
Find the minimum cost to visit all cities given the costs of traveling between cities, where each city must be visited exactly once (Traveling Salesman Problem).

**Example:**
```javascript
function tsp(cost) {
    let n = cost.length;
    let dp = Array.from({ length: 1 << n }, () => Array(n).fill(Infinity));
    dp[1][0] = 0;

    for (let mask = 1; mask < (1 << n); mask += 2) {
        for (let u = 1; u < n; u++) {
            if (mask & (1 << u)) {
                for (let v = 0; v < n; v++) {
                    if ((mask & (1 << v)) && cost[v][u] !== Infinity) {
                        dp[mask][u] = Math.min(dp[mask][u], dp[mask ^ (1 << u)][v] + cost[v][u]);
                    }
                }
            }
        }
    }

    let answer = Infinity;
    for (let u = 1; u < n; u++) {
        answer = Math.min(answer, dp[(1 << n) - 1][u] + cost[u][0]);
    }
    return answer;
}

let cost = [
    [0, 10, 15, 20],
    [10, 0, 35, 25],
    [15, 35, 0, 30],
    [20, 25, 30, 0]
];

console.log(tsp(cost));  // Output: 80
```

### **DP on Trees**

**Problem:**
Find the maximum sum of values in a binary tree such that no two adjacent nodes are selected.

**Example:**
```javascript
class TreeNode {
    constructor(value = 0, left = null, right = null) {
        this.value = value;
        this.left = left;
        this.right = right;
    }
}

function maxSum(root) {
    function dfs(node) {
        if (!node) return [0, 0];

        let left = dfs(node.left);
        let right = dfs(node.right);

        let includeNode = node.value + left[1] + right[1];
        let excludeNode = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);

        return [includeNode, excludeNode];
    }

    let result = dfs(root);
    return Math.max(result[0], result[1]);
}

let root = new TreeNode(3);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.right = new TreeNode(3);
root.right.right = new TreeNode(1);

console.log(maxSum(root));  // Output: 7
```

## **Interview Tips and Tricks**

- **Understand the Problem:**
  Break down the problem to understand its subproblems and the relationships between them.
  
- **Identify Base Cases:**
  Clearly identify and initialize base cases for your DP table.

- **Think Recursively:**
  Even when using tabulation, think in terms of smaller subproblems and how they build up to the solution.

- **Optimize Space:**
  If possible, optimize space by using rolling arrays or in-place updates.

## **Common Mistakes**

- **Misidentifying Subproblems:**
  Ensure you correctly identify overlapping subproblems to leverage the power of DP.

- **Incorrect Initialization:**
  Incorrect base case initialization can lead to wrong results or infinite loops.

- **Subproblem Dependencies:**
  Ensure subproblems are computed before they are needed by other subproblems.

By mastering dynamic programming and understanding its intricacies, you will be well-equipped to handle a variety of optimization and combinatorial problems. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.