export const metadata = {
  title: 'Comprehensive Guide to Bit Manipulation in JavaScript',
  description: 'Perform operations directly on binary representations of numbers. Understand bit manipulation techniques, performance considerations, and practical examples.',
}

# **Bit Manipulation**

Bit manipulation involves directly working with the binary representations of numbers. This technique is crucial for optimizing performance, solving certain types of problems efficiently, and understanding how data is processed at the lowest level.

## **Concept and Use Cases**

### **Definition:**
Bit manipulation refers to the act of algorithmically manipulating bits or binary digits, which are the most basic form of data in computing and digital communications.

### **Common Use Cases:**
- Efficiently performing arithmetic operations
- Optimizing space and time complexity
- Cryptography and encoding
- Network programming
- Competitive programming

## **Key Bitwise Operators**

JavaScript provides several bitwise operators that allow direct manipulation of bits:

1. **AND (`&`)**: Sets each bit to 1 if both bits are 1.
   ```javascript
   console.log(5 & 3); // Output: 1 (0101 & 0011 = 0001)
   ```

2. **OR (`|`)**: Sets each bit to 1 if one of two bits is 1.
   ```javascript
   console.log(5 | 3); // Output: 7 (0101 | 0011 = 0111)
   ```

3. **XOR (`^`)**: Sets each bit to 1 if only one of two bits is 1.
   ```javascript
   console.log(5 ^ 3); // Output: 6 (0101 ^ 0011 = 0110)
   ```

4. **NOT (`~`)**: Inverts all the bits.
   ```javascript
   console.log(~5); // Output: -6 (~0101 = 1010 in 2's complement form)
   ```

5. **Left Shift (`<<`)**: Shifts bits to the left, filling with zeros.
   ```javascript
   console.log(5 << 1); // Output: 10 (0101 << 1 = 1010)
   ```

6. **Right Shift (`>>`)**: Shifts bits to the right, filling with the sign bit.
   ```javascript
   console.log(5 >> 1); // Output: 2 (0101 >> 1 = 0010)
   ```

7. **Unsigned Right Shift (`>>>`)**: Shifts bits to the right, filling with zeros.
   ```javascript
   console.log(5 >>> 1); // Output: 2 (0101 >>> 1 = 0010)
   ```

## **Practical Examples**

### **Checking if a Number is Even or Odd**
Using the AND operator, you can quickly check if a number is even or odd.
```javascript
function isEven(num) {
  return (num & 1) === 0;
}

console.log(isEven(4)); // Output: true
console.log(isEven(7)); // Output: false
```

### **Swapping Two Numbers Without a Temporary Variable**
Using XOR, you can swap two numbers in place.
```javascript
function swap(a, b) {
  a = a ^ b;
  b = a ^ b;
  a = a ^ b;
  return [a, b];
}

let [a, b] = swap(5, 7);
console.log(a, b); // Output: 7, 5
```

### **Counting the Number of 1s in a Binary Representation (Hamming Weight)**
Using bitwise AND and right shift.
```javascript
function hammingWeight(num) {
  let count = 0;
  while (num !== 0) {
    count += num & 1;
    num >>= 1;
  }
  return count;
}

console.log(hammingWeight(5)); // Output: 2 (0101 has two 1s)
```

### **Finding the Only Non-Repeating Element**
In an array where every element repeats twice except for one, XOR can find the unique element.
```javascript
function findUnique(arr) {
  return arr.reduce((acc, num) => acc ^ num, 0);
}

console.log(findUnique([2, 3, 5, 4, 5, 3, 4])); // Output: 2
```

### **Detecting Power of Two**
To check if a number is a power of two, you can use the following bit manipulation trick.
```javascript
function isPowerOfTwo(num) {
  return num > 0 && (num & (num - 1)) === 0;
}

console.log(isPowerOfTwo(4)); // Output: true
console.log(isPowerOfTwo(7)); // Output: false
```

### **Counting Bits to Convert One Number to Another**
Calculate the number of bits needed to convert integer `a` to integer `b`.
```javascript
function bitSwapRequired(a, b) {
  let count = 0;
  for (let c = a ^ b; c !== 0; c = c >> 1) {
    count += c & 1;
  }
  return count;
}

console.log(bitSwapRequired(29, 15)); // Output: 2
```

### **Reverse Bits of a Number**
Reverse the bits of an integer.
```javascript
function reverseBits(num) {
  let result = 0;
  for (let i = 0; i < 32; i++) {
    result = (result << 1) | (num & 1);
    num >>= 1;
  }
  return result >>> 0; // Ensure unsigned result
}

console.log(reverseBits(43261596)); // Output: 964176192
```

### **Extracting the Lowest Set Bit**
To isolate the lowest set bit of a number.
```javascript
function lowestSetBit(num) {
  return num & -num;
}

console.log(lowestSetBit(18)); // Output: 2 (0010)
```

### **Clearing the Lowest Set Bit**
To clear the lowest set bit.
```javascript
function clearLowestSetBit(num) {
  return num & (num - 1);
}

console.log(clearLowestSetBit(18)); // Output: 16 (10010 -> 10000)
```

### **Toggle All Bits After the Rightmost 1-bit**
To toggle all bits after the rightmost 1-bit (inclusive).
```javascript
function toggleBitsAfterRightmostOne(num) {
  return num ^ (num & -num);
}

console.log(toggleBitsAfterRightmostOne(18)); // Output: 16 (10010 -> 10000)
```

## **Tips and Tricks**

1. **Use Masks for Specific Bits**: Masks can isolate or modify specific bits in a number.
   ```javascript
   let mask = 1 << 3; // Mask to check the 4th bit (counting from 0)
   console.log((5 & mask) !== 0); // Check if the 4th bit is set
   ```

2. **Toggle Bits**: XOR with a mask to toggle specific bits.
   ```javascript
   let num = 5; // 0101
   let mask = 1 << 1; // Toggle the 2nd bit
   num ^= mask;
   console.log(num); // Output: 7 (0111)
   ```

3. **Clearing Bits**: Use AND with the complement of a mask to clear specific bits.
   ```javascript
   let num = 7; // 0111
   let mask = ~(1 << 1); // Clear the 2nd bit
   num &= mask;
   console.log(num); // Output: 5 (0101)
   ```

4. **Setting Bits**: Use OR with a mask to set specific bits.
   ```javascript
   let num = 5; // 0101
   let mask = 1 << 2; // Set the 3rd bit
   num |= mask;
   console.log(num); // Output: 13 (1101)
   ```

5. **Conditional Bit Manipulation**: Combine shifts and masks for conditional manipulations.
   ```javascript
   function conditionalSetBit(num, bitIndex, condition) {
     let mask = 1 << bitIndex;
     return condition ? (num | mask) : (num & ~mask);
   }

   console.log(conditionalSetBit(5, 1, true)); // Output: 7 (0101 -> 0111)
   console.log(conditionalSetBit(5, 1, false)); // Output: 5 (0101 -> 0101)
   ```

6. **Counting Set Bits Efficiently**: Brian Kernighanâ€™s Algorithm.
   ```javascript
   function countSetBits(num) {
     let count = 0;
     while (num) {
       num &= (num - 1);
       count++;
     }
     return count;
   }

   console.log(countSetBits(7)); // Output: 3 (0111 has three 1s)
   ```

7. **Circular Shifts**: Implement circular left and right shifts.
   ```javascript
   function circularLeftShift(num, shift) {
     return (num << shift) | (num >>> (32 - shift));
   }

   function circularRightShift(num, shift) {
     return (num >>> shift) | (num << (32 - shift));
   }

   console.log(circularLeftShift(5, 2)); // Output: 20 (0101 -> 10100)
   console.log(circularRightShift(5, 2)); // Output: 1073741821 (0101 -> 1100...01)
   ```

## **Common Gotchas**

1. **Sign Bit**: Be aware of the sign bit when performing right shifts on negative numbers. Right shifts (`>>`) on negative numbers preserve the sign bit, while unsigned right shifts (`>>>`) do not.
   ```javascript
   console.log(-5 >> 1); // Output: -3 (Preserves the sign bit)
   console.log(-5 >>> 1); // Output: 2147483645 (Does not preserve the sign bit)
   ```

2. **Overflow**: JavaScript numbers are 64-bit floating-point but bitwise operations work on 32-bit signed integers, which can cause unexpected results due to overflow. Always ensure that your operations do not inadvertently overflow.
   ```javascript
   console.log(Math.pow(2, 31) | 0); // Output: -2147483648 (Overflow)
   ```

3. **Operator Precedence**: Use parentheses to ensure the correct order of operations, especially in complex expressions involving multiple bitwise operations.
   ```javascript
   console.log((5 & 1) === 0); // Output: false (Correct precedence)
   console.log(5 & 1 === 0); // Output: false (Incorrect precedence)
   ```

4. **Performance Considerations**: While bitwise operations are generally fast, excessive use can make code less readable and maintainable. Ensure that the use of bitwise operations is justified by a significant performance gain.

## **Time and Space Complexity**

- **Bitwise Operations**: O(1) time complexity. Bitwise operations are generally very fast and execute in constant time.
- **Space Complexity**: O(1). Bitwise operations do not require additional space.

## **Advanced Bit Manipulation Techniques**

### **Population Count (Hamming Weight) Using Lookup Table**
For a more efficient population count, you can use a precomputed lookup table for nibbles (4 bits).
```javascript
const lookupTable = new Uint8Array(256);
for (let i = 0; i < 256; i++) {
  lookupTable[i] = (i & 1) + lookupTable[i >> 1];
}

function popCount(num) {
  return lookupTable[num & 0xff] +
         lookupTable[(num >> 8) & 0xff] +
         lookupTable[(num >> 16) & 0xff] +
         lookupTable[(num >> 24) & 0xff];
}

console.log(popCount(5)); // Output: 2 (0101 has two 1s)
```

### **Finding the Most Significant Bit (MSB)**
To find the position of the most significant bit set to 1.
```javascript
function msb(num) {
  let msbPos = -1;
  while (num > 0) {
    num >>= 1;
    msbPos++;
  }
  return msbPos;
}

console.log(msb(18)); // Output: 4 (10010, MSB is at position 4)
```

### **Extracting Bits**
Extract specific bits from a number using masks and shifts.
```javascript
function extractBits(num, start, end) {
  let mask = ((1 << (end - start + 1)) - 1) << start;
  return (num & mask) >> start;
}

console.log(extractBits(29, 1, 3)); // Output: 5 (11101 -> bits 1 to 3 are 101)
```

## **Real-World Applications**

### **Network Address Translation (NAT)**
Bit manipulation is extensively used in network programming, especially for tasks like Network Address Translation (NAT). For instance, calculating network addresses from IP addresses and subnets involves bitwise AND operations.

### **Graphics Programming**
In graphics programming, bitwise operations are used for tasks such as color blending, where individual color channels (red, green, blue, alpha) need to be manipulated.

### **Cryptography**
Many cryptographic algorithms, such as those used in hashing functions (e.g., SHA-256), heavily rely on bitwise operations to shuffle and mix bits to achieve diffusion.

## **Conclusion**

Mastering bit manipulation can significantly improve your problem-solving skills, especially in areas requiring optimization and low-level data processing. Understanding and utilizing these techniques effectively can set you apart in technical interviews and real-world programming challenges. By practicing these operations and incorporating them into your daily coding routines, you can gain a deeper understanding of how computers process data at the most fundamental level.