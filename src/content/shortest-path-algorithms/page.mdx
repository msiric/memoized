export const metadata = {
  title: 'Comprehensive Guide to Shortest Path Algorithms in JavaScript',
  description: 'Determine the shortest paths between nodes in a graph. Understand shortest path algorithms, performance considerations, and practical examples.',
}

# **Shortest Path Algorithms**

Shortest path algorithms are used to find the shortest paths between nodes in a graph. They are widely used in network routing, urban planning, and many other fields. Two primary algorithms for finding the shortest path are Dijkstra's algorithm and the Bellman-Ford algorithm.

## **Concept and Use Cases**

**Definition:**
Shortest path algorithms find the shortest path from a source vertex to one or more destination vertices in a graph.

**Common Use Cases:**
- GPS navigation
- Network routing
- Urban planning
- Transportation and logistics

### **Visual Representation:**

Consider a graph with vertices `{A, B, C, D}` and edges with weights:
```
A -- 1 -- B
A -- 4 -- C
B -- 2 -- C
B -- 5 -- D
C -- 1 -- D
```
The shortest path from `A` to `D` would include edges: `A-B`, `B-C`, `C-D`, with a total weight of 4.

## **Key Concepts**

1. **Graph Representation:**
   - Graphs can be represented using adjacency lists or adjacency matrices.
   
2. **Dijkstra's Algorithm:**
   - An algorithm for finding the shortest paths from a source vertex to all other vertices in a graph with non-negative edge weights.

3. **Bellman-Ford Algorithm:**
   - An algorithm for finding the shortest paths from a source vertex to all other vertices in a graph that may have negative edge weights.

## **Time and Space Complexity**

**Time Complexity:**
- Dijkstra's Algorithm: O(V^2) for adjacency matrix, O(E log V) using a priority queue.
- Bellman-Ford Algorithm: O(VE).

**Space Complexity:**
- Both algorithms: O(V) for storing distances and predecessors.

## **Shortest Path Algorithms and Methods**

### **Dijkstra's Algorithm**

**Steps:**
1. Initialize the distance to the source vertex as 0 and all other distances as infinity.
2. Use a priority queue to extract the vertex with the minimum distance.
3. Update the distances of the neighboring vertices.
4. Repeat until all vertices are processed.

**Example:**

<CodeGroup>

```javascript
class MinHeap {
    constructor() {
        this.heap = [];
    }

    insert(key, value) {
        this.heap.push({ key, value });
        this.bubbleUp();
    }

    extractMin() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop();

        const min = this.heap[0];
        this.heap[0] = this.heap.pop();
        this.bubbleDown();
        return min;
    }

    bubbleUp() {
        let index = this.heap.length - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].key >= this.heap[parentIndex].key) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    bubbleDown() {
        let index = 0;
        const length = this.heap.length;
        const element = this.heap[0];

        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swapIndex = null;

            if (leftChildIndex < length) {
                leftChild = this.heap[leftChildIndex];
                if (leftChild.key < element.key) {
                    swapIndex = leftChildIndex;
                }
            }

            if (rightChildIndex < length) {
                rightChild = this.heap[rightChildIndex];
                if (
                    (swapIndex === null && rightChild.key < element.key) ||
                    (swapIndex !== null && rightChild.key < leftChild.key)
                ) {
                    swapIndex = rightChildIndex;
                }
            }

            if (swapIndex === null) break;
            [this.heap[index], this.heap[swapIndex]] = [this.heap[swapIndex], this.heap[index]];
            index = swapIndex;
        }
    }

    isEmpty() {
        return this.heap.length === 0;
    }
}

class Graph {
    constructor(vertices) {
        this.V = vertices;
        this.adj = new Map();
    }

    addEdge(u, v, w) {
        if (!this.adj.has(u)) this.adj.set(u, []);
        this.adj.get(u).push([v, w]);
    }

    dijkstra(src) {
        const dist = Array(this.V).fill(Infinity);
        dist[src] = 0;
        const minHeap = new MinHeap();
        minHeap.insert(0, src);

        while (!minHeap.isEmpty()) {
            const { key: uDist, value: u } = minHeap.extractMin();

            if (uDist > dist[u]) continue;

            if (this.adj.has(u)) {
                for (const [v, weight] of this.adj.get(u)) {
                    if (dist[u] + weight < dist[v]) {
                        dist[v] = dist[u] + weight;
                        minHeap.insert(dist[v], v);
                    }
                }
            }
        }

        return dist;
    }
}

// Example usage:
const graph = new Graph(5);
graph.addEdge(0, 1, 9);
graph.addEdge(0, 2, 6);
graph.addEdge(0, 3, 5);
graph.addEdge(0, 4, 3);
graph.addEdge(2, 1, 2);
graph.addEdge(2, 3, 4);

console.log(graph.dijkstra(0));
// Output: [ 0, 8, 6, 5, 3 ]
```

```typescript
class MinHeap {
    heap: { key: number, value: number }[];

    constructor() {
        this.heap = [];
    }

    insert(key: number, value: number) {
        this.heap.push({ key, value });
        this.bubbleUp();
    }

    extractMin() {
        if (this.heap.length === 0) return null;
        if (this.heap.length === 1) return this.heap.pop()!;

        const min = this.heap[0];
        this.heap[0] = this.heap.pop()!;
        this.bubbleDown();
        return min;
    }

    bubbleUp() {
        let index = this.heap.length - 1;
        while (index > 0) {
            const parentIndex = Math.floor((index - 1) / 2);
            if (this.heap[index].key >= this.heap[parentIndex].key) break;
            [this.heap[index], this.heap[parentIndex]] = [this.heap[parentIndex], this.heap[index]];
            index = parentIndex;
        }
    }

    bubbleDown() {
        let index = 0;
        const length = this.heap.length;
        const element = this.heap[0];

        while (true) {
            const leftChildIndex = 2 * index + 1;
            const rightChildIndex = 2 * index + 2;
            let leftChild, rightChild;
            let swapIndex = null;

            if (leftChildIndex < length) {
                leftChild = this.heap[leftChildIndex];
                if (leftChild.key < element.key) {
                    swapIndex = leftChildIndex;
                }
            }

            if (rightChildIndex < length) {
                rightChild = this.heap[rightChildIndex];
                if (
                    (swapIndex === null && rightChild.key < element.key) ||
                    (swapIndex !== null && rightChild.key < leftChild.key)
                ) {
                    swapIndex = rightChildIndex;
                }
            }

            if (swapIndex === null) break;
            [this.heap[index], this.heap[swapIndex]] = [this.heap[swapIndex], this.heap[index]];
            index = swapIndex;
        }
    }

    isEmpty() {
        return this.heap.length === 0;
    }
}

class Graph {
    V: number;
    adj: Map<number, [number, number][]>;

    constructor(vertices: number) {
        this.V = vertices;
        this.adj = new Map();
    }

    addEdge(u: number, v: number, w: number) {
        if (!this.adj.has(u)) this.adj.set(u, []);
        this.adj.get(u)!.push([v, w]);
    }

    dijkstra(src: number) {
        const dist = Array(this.V).fill(Infinity);
        dist[src] = 0;
        const minHeap = new MinHeap();
        minHeap.insert(0, src);

        while (!minHeap.isEmpty()) {
            const { key: uDist, value: u } = minHeap.extractMin()!;

            if (uDist > dist[u]) continue;

            if (this.adj.has(u)) {
                for (const [v, weight] of this.adj.get(u)!) {
                    if (dist[u] + weight < dist[v]) {
                        dist[v] = dist[u] + weight;
                        minHeap.insert(dist[v], v);
                    }
                }
            }
        }

        return dist;
    }
}

// Example usage:
const graph = new Graph(5);
graph.addEdge(0, 1, 9);
graph.addEdge(0, 2, 6);
graph.addEdge(0, 3, 5);
graph.addEdge(0, 4, 3);
graph.addEdge(2, 1, 2);
graph.addEdge(2, 3, 4);

console.log(graph.dijkstra(0));
// Output: [ 0, 8, 6, 5, 3 ]
```

</CodeGroup>

### **Bellman-Ford Algorithm**

**Steps:**
1. Initialize the distance to the source vertex as 0 and all other distances as infinity.
2. Relax all edges V-1 times.
3. Check for negative weight cycles by checking if the distances can be further minimized.

**Example:**

<CodeGroup>

```javascript
class Graph {
    constructor(vertices) {
        this.V = vertices;
        this.edges = [];
    }

    addEdge(u, v, w) {
        this.edges.push([u, v, w]);
    }

    bellmanFord(src) {
        const dist = Array(this.V).fill(Infinity);
        dist[src] = 0;

        for (let i = 1; i < this.V; i++) {
            for (const [u, v, w] of this.edges) {
                if (dist[u] !== Infinity && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }

        for (const [u, v, w] of this.edges) {
            if (dist[u] !== Infinity && dist[u] + w < dist[v]) {
                console.log('Graph contains a negative weight cycle');
                return null;
            }
        }

        return dist;
    }
}

// Example usage:
const graph = new Graph(5);
graph.addEdge(0, 1, -1);
graph.addEdge(0, 2, 4);
graph.addEdge(1, 2, 3);
graph.addEdge(1, 3, 2);
graph.addEdge(1, 4, 2);
graph.addEdge(3, 2, 5);
graph.addEdge(3, 1, 1);
graph.addEdge(4, 3, -3);

console.log(graph.bellmanFord(0));
// Output: [ 0, -1, 2, -2, 1 ]
```

```typescript
class Graph {
    V: number;
    edges: [number, number, number][];

    constructor(vertices: number) {
        this.V = vertices;
        this.edges = [];
    }

    addEdge(u: number, v: number, w: number) {
        this.edges.push([u, v, w]);
    }

    bellmanFord(src: number) {
        const dist = Array(this.V).fill(Infinity);
        dist[src] = 0;

        for (let i = 1; i < this.V; i++) {
            for (const [u, v, w] of this.edges) {
                if (dist[u] !== Infinity && dist[u] + w < dist[v]) {
                    dist[v] = dist[u] + w;
                }
            }
        }

        for (const [u, v, w] of this.edges) {
            if (dist[u] !== Infinity && dist[u] + w < dist[v]) {
                console.log('Graph contains a negative weight cycle');
                return null;
            }
        }

        return dist;
    }
}

// Example usage:
const graph = new Graph(5);
graph.addEdge(0, 1, -1);
graph.addEdge(0, 2, 4);
graph.addEdge(1, 2, 3);
graph.addEdge(1, 3, 2);
graph.addEdge(1, 4, 2);
graph.addEdge(3, 2, 5);
graph.addEdge(3, 1, 1);
graph.addEdge(4, 3, -3);

console.log(graph.bellmanFord(0));
// Output: [ 0, -1, 2, -2, 1 ]
```

</CodeGroup>

## **Practical Tips and Tricks**

- **Choosing the Algorithm:**
  Use Dijkstra's algorithm for graphs with non-negative weights. Use Bellman-Ford when the graph contains negative weights.
  
- **Edge Cases:**
  Handle edge cases such as disconnected graphs and graphs with negative weight cycles appropriately.

- **Graph Representation:**
  Choose the appropriate graph representation (adjacency list vs. matrix) based on the graph's density.

## **Common Gotchas**

- **Negative Weight Cycles:**
  Ensure Bellman-Ford correctly detects negative weight cycles and handles them appropriately.

- **Priority Queue in Dijkstra's:**
  Implement the priority queue (min-heap) efficiently to optimize Dijkstra's algorithm.

- **Initialization:**
  Ensure all distances are initialized correctly to infinity, except for the source vertex.

## **Advanced Topics**

### **Floyd-Warshall Algorithm**

**Description:**
The Floyd-Warshall algorithm is an all-pairs shortest path algorithm that works on both positive and negative edge weights (but no negative weight cycles).

**Example:**

<CodeGroup>

```javascript
class Graph {
    constructor(vertices) {
        this.V = vertices;
        this.dist = Array.from({ length: vertices }, () => Array(vertices).fill(Infinity));

        for (let i = 0; i < vertices; i++) {
            this.dist[i][i] = 0;
        }
    }

    addEdge(u, v, w) {
        this.dist[u][v] = w;
    }

    floydWarshall() {
        for (let k = 0; k < this.V; k++) {
            for (let i = 0; i < this.V; i++) {
                for (let j = 0; j < this.V; j++) {
                    if (this.dist[i][j] > this.dist[i][k] + this.dist[k][j]) {
                        this.dist[i][j] = this.dist[i][k] + this.dist[k][j];
                    }
                }
            }
        }
        return this.dist;
    }
}

// Example usage:
const graph = new Graph(4);
graph.addEdge(0, 1, 5);
graph.addEdge(0, 3, 10);
graph.addEdge(1, 2, 3);
graph.addEdge(2, 3, 1);

console.log(graph.floydWarshall());
// Output: 
// [
//   [ 0, 5, 8, 9 ],
//   [ Infinity, 0, 3, 4 ],
//   [ Infinity, Infinity, 0, 1 ],
//   [ Infinity, Infinity, Infinity, 0 ]
// ]
```

```typescript
class Graph {
    V: number;
    dist: number[][];

    constructor(vertices: number) {
        this.V = vertices;
        this.dist = Array.from({ length: vertices }, () => Array(vertices).fill(Infinity));

        for (let i = 0; i < vertices; i++) {
            this.dist[i][i] = 0;
        }
    }

    addEdge(u: number, v: number, w: number) {
        this.dist[u][v] = w;
    }

    floydWarshall() {
        for (let k = 0; k < this.V; k++) {
            for (let i = 0; i < this.V; i++) {
                for (let j = 0; j < this.V; j++) {
                    if (this.dist[i][j] > this.dist[i][k] + this.dist[k][j]) {
                        this.dist[i][j] = this.dist[i][k] + this.dist[k][j];
                    }
                }
            }
        }
        return this.dist;
    }
}

// Example usage:
const graph = new Graph(4);
graph.addEdge(0, 1, 5);
graph.addEdge(0, 3, 10);
graph.addEdge(1, 2, 3);
graph.addEdge(2, 3, 1);

console.log(graph.floydWarshall());
// Output: 
// [
//   [ 0, 5, 8, 9 ],
//   [ Infinity, 0, 3, 4 ],
//   [ Infinity, Infinity, 0, 1 ],
//   [ Infinity, Infinity, Infinity, 0 ]
// ]
```

</CodeGroup>

### **A* Search Algorithm**

**Description:**
The A* search algorithm is an extension of Dijkstra's algorithm that uses heuristics to improve performance in finding the shortest path in a weighted graph.

**Example:**

<CodeGroup>

```javascript
class AStar {
    constructor(vertices) {
        this.V = vertices;
        this.adj = new Map();
    }

    addEdge(u, v, w) {
        if (!this.adj.has(u)) this.adj.set(u, []);
        this.adj.get(u).push([v, w]);
    }

    heuristic(node, goal) {
        // Example heuristic (Manhattan distance)
        return Math.abs(node - goal);
    }

    aStarSearch(start, goal) {
        const openSet = new MinHeap();
        openSet.insert(0, start);
        const cameFrom = new Map();
        const gScore = Array(this.V).fill(Infinity);
        gScore[start] = 0;
        const fScore = Array(this.V).fill(Infinity);
        fScore[start] = this.heuristic(start, goal);

        while (!openSet.isEmpty()) {
            const { key: currentScore, value: current } = openSet.extractMin();

            if (current === goal) {
                return this.reconstructPath(cameFrom, current);
            }

            if (this.adj.has(current)) {
                for (const [neighbor, weight] of this.adj.get(current)) {
                    const tentativeGScore = gScore[current] + weight;

                    if (tentativeGScore < gScore[neighbor]) {
                        cameFrom.set(neighbor, current);
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = gScore[neighbor] + this.heuristic(neighbor, goal);
                        openSet.insert(fScore[neighbor], neighbor);
                    }
                }
            }
        }

        return [];
    }

    reconstructPath(cameFrom, current) {
        const path = [current];
        while (cameFrom.has(current)) {
            current = cameFrom.get(current);
            path.unshift(current);
        }
        return path;
    }
}

// Example usage:
const graph = new AStar(5);
graph.addEdge(0, 1, 1);
graph.addEdge(0, 2, 4);
graph.addEdge(1, 2, 2);
graph.addEdge(1, 3, 5);
graph.addEdge(2, 3, 1);
graph.addEdge(3, 4, 3);

console.log(graph.aStarSearch(0, 4));
// Output: [ 0, 1, 2, 3, 4 ]
```

```typescript
class AStar {
    V: number;
    adj: Map<number, [number, number][]>;

    constructor(vertices: number) {
        this.V = vertices;
        this.adj = new Map();
    }

    addEdge(u: number, v: number, w: number) {
        if (!this.adj.has(u)) this.adj.set(u, []);
        this.adj.get(u)!.push([v, w]);
    }

    heuristic(node: number, goal: number) {
        // Example heuristic (Manhattan distance)
        return Math.abs(node - goal);
    }

    aStarSearch(start: number, goal: number) {
        const openSet = new MinHeap();
        openSet.insert(0, start);
        const cameFrom = new Map();
        const gScore = Array(this.V).fill(Infinity);
        gScore[start] = 0;
        const fScore = Array(this.V).fill(Infinity);
        fScore[start] = this.heuristic(start, goal);

        while (!openSet.isEmpty()) {
            const { key: currentScore, value: current } = openSet.extractMin()!;

            if (current === goal) {
                return this.reconstructPath(cameFrom, current);
            }

            if (this.adj.has(current)) {
                for (const [neighbor, weight] of this.adj.get(current)!) {
                    const tentativeGScore = gScore[current] + weight;

                    if (tentativeGScore < gScore[neighbor]) {
                        cameFrom.set(neighbor, current);
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = gScore[neighbor] + this.heuristic(neighbor, goal);
                        openSet.insert(fScore[neighbor], neighbor);
                    }
                }
            }
        }

        return [];
    }

    reconstructPath(cameFrom: Map<number, number>, current: number) {
        const path = [current];
        while (cameFrom.has(current)) {
            current = cameFrom.get(current);
            path.unshift(current);
        }
        return path;
    }
}

// Example usage:
const graph = new AStar(5);
graph.addEdge(0, 1, 1);
graph.addEdge(0, 2, 4);
graph.addEdge(1, 2, 2);
graph.addEdge(1, 3, 5);
graph.addEdge(2, 3, 1);
graph.addEdge(3, 4, 3);

console.log(graph.aStarSearch(0, 4));
// Output: [ 0, 1, 2, 3, 4 ]
```

</CodeGroup>

## **Interview Tips and Tricks**

- **Explain the Algorithms:**
  Clearly explain the steps of Dijkstra's and Bellman-Ford algorithms, and their differences.

- **Negative Weight Cycles in Bellman-Ford:**
  Demonstrate how Bellman-Ford detects negative weight cycles and handles them.

- **Priority Queue in Dijkstra's:**
  Discuss the importance of a priority queue (min-heap) in optimizing Dijkstra's algorithm.

- **Edge Cases:**
  Handle edge cases, such as disconnected graphs and graphs with negative weight cycles, appropriately.

## **Common Mistakes**

- **Incorrect Relaxation in Bellman-Ford:**
  Ensure all edges are relaxed V-1 times correctly.

- **Priority Queue Implementation in Dijkstra's:**
  Implement the priority queue efficiently to avoid performance issues.

- **Initialization:**
  Ensure all distances are initialized correctly to infinity, except for the source vertex.

By mastering Shortest Path algorithms and understanding their intricacies, you will be well-equipped to handle a variety of graph-related problems. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.