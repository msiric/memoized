export const metadata = {
  title: 'Comprehensive Guide to Topological Sort in JavaScript',
  description: 'Order tasks based on dependencies using topological sort. Understand topological sort, performance considerations, and practical examples.',
}

# **Topological Sort**

Topological Sort is an algorithm used to order the vertices of a directed acyclic graph (DAG) in a linear sequence such that for every directed edge \(UV\) from vertex \(U\) to vertex \(V\), \(U\) comes before \(V\) in the ordering. This technique is crucial in scenarios where dependencies need to be resolved, such as task scheduling, course prerequisite completion, and more.

## **Concept and Use Cases**

**Definition:**
Topological Sort is the process of arranging the vertices of a directed acyclic graph (DAG) in a linear order such that for every directed edge \(UV\), vertex \(U\) appears before vertex \(V\).

### **Visual Representation:**
Consider the following DAG:

```
   5 --> 0 <--- 4
   |     ^      |
   v     |      v
   2 --> 3 <--- 1
```

Topological Sort of the above graph could be: `5, 4, 2, 1, 3, 0`.

### **Common Use Cases:**
- Task scheduling based on dependencies.
- Course prerequisite ordering.
- Resolving symbol dependencies in linkers.
- Pipeline of data processing tasks.

## **When to Use**
- When you need to schedule tasks that have dependencies.
- When solving problems that involve prerequisite constraints.
- When dealing with graphs where the vertices must be processed in a certain order based on dependencies.

## **Time and Space Complexity**

**Time Complexity:** 
- O(V + E), where \(V\) is the number of vertices and \(E\) is the number of edges in the graph.

**Space Complexity:**
- O(V + E) for storing the graph and the result.

## **Approaches to Topological Sort**

1. **Kahn’s Algorithm (BFS)**
2. **Depth-First Search (DFS)**

## **Topological Sort using Kahn’s Algorithm (BFS)**

### **Step-by-Step Solution:**
1. Calculate the in-degree (number of incoming edges) for each vertex.
2. Initialize a queue and enqueue all vertices with in-degree 0 (sources).
3. While the queue is not empty:
   - Dequeue a vertex \(U\) and add it to the topological order.
   - Decrease the in-degree of all its neighbors.
   - If a neighbor’s in-degree becomes 0, enqueue it.
4. If the topological order includes all vertices, return the order. Otherwise, there is a cycle in the graph.

### **Code Example:**
```javascript
function topologicalSort(vertices, edges) {
    const inDegree = Array(vertices).fill(0);
    const graph = Array.from({ length: vertices }, () => []);

    // Build the graph and calculate in-degrees
    for (const [u, v] of edges) {
        graph[u].push(v);
        inDegree[v]++;
    }

    const queue = [];
    for (let i = 0; i < vertices; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }

    const topologicalOrder = [];
    while (queue.length > 0) {
        const u = queue.shift();
        topologicalOrder.push(u);

        for (const v of graph[u]) {
            inDegree[v]--;
            if (inDegree[v] === 0) {
                queue.push(v);
            }
        }
    }

    if (topologicalOrder.length === vertices) {
        return topologicalOrder;
    } else {
        // There is a cycle in the graph
        return [];
    }
}

// Example usage:
const vertices = 6;
const edges = [
    [5, 2],
    [5, 0],
    [4, 0],
    [4, 1],
    [2, 3],
    [3, 1]
];

console.log(topologicalSort(vertices, edges));  // Output: [5, 4, 2, 3, 1, 0]
```

### **Tips and Tricks:**
- Start by identifying vertices with in-degree 0 to initialize the queue.
- Use a queue to process vertices in a level-order manner.
- Ensure to check for cycles by comparing the length of the topological order with the number of vertices.

### **Frequent Gotchas:**
- Forgetting to decrease the in-degree of neighbors correctly.
- Not checking for cycles, which can lead to incorrect results.
- Handling graphs with no valid topological order due to cycles.

## **Topological Sort using Depth-First Search (DFS)**

### **Step-by-Step Solution:**
1. Mark all vertices as unvisited.
2. For each unvisited vertex, perform a DFS, marking vertices as visited and pushing them onto a stack upon completing the visit.
3. The topological order is obtained by popping vertices from the stack.

### **Code Example:**
```javascript
function topologicalSortDFS(vertices, edges) {
    const graph = Array.from({ length: vertices }, () => []);
    const visited = Array(vertices).fill(false);
    const stack = [];

    // Build the graph
    for (const [u, v] of edges) {
        graph[u].push(v);
    }

    function dfs(v) {
        visited[v] = true;
        for (const neighbor of graph[v]) {
            if (!visited[neighbor]) {
                dfs(neighbor);
            }
        }
        stack.push(v);
    }

    // Perform DFS for each unvisited vertex
    for (let i = 0; i < vertices; i++) {
        if (!visited[i]) {
            dfs(i);
        }
    }

    // The topological order is the reverse of the stack
    return stack.reverse();
}

// Example usage:
const vertices = 6;
const edges = [
    [5, 2],
    [5, 0],
    [4, 0],
    [4, 1],
    [2, 3],
    [3, 1]
];

console.log(topologicalSortDFS(vertices, edges));  // Output: [5, 4, 2, 3, 1, 0]
```

### **Tips and Tricks:**
- Use a stack to keep track of the topological order during DFS.
- Mark vertices as visited to avoid reprocessing them.
- Reverse the stack at the end to obtain the correct topological order.

### **Frequent Gotchas:**
- Forgetting to mark vertices as visited, leading to infinite loops.
- Not correctly reversing the stack to get the topological order.
- Handling graphs with no valid topological order due to cycles.

## **Task Scheduling with Dependencies**

**Problem:** Given a list of tasks and their dependencies, determine if it is possible to complete all tasks. If possible, return an order in which the tasks can be completed.

### **Step-by-Step Solution:**
1. Build the graph and calculate in-degrees.
2. Use Kahn’s Algorithm (BFS) to perform topological sort.
3. If the topological order includes all tasks, return the order. Otherwise, return an empty array.

### **Code Example:**
```javascript
function canFinishTasks(numTasks, prerequisites) {
    const inDegree = Array(numTasks).fill(0);
    const graph = Array.from({ length: numTasks }, () => []);

    // Build the graph and calculate in-degrees
    for (const [u, v] of prerequisites) {
        graph[u].push(v);
        inDegree[v]++;
    }

    const queue = [];
    for (let i = 0; i < numTasks; i++) {
        if (inDegree[i] === 0) {
            queue.push(i);
        }
    }

    const taskOrder = [];
    while (queue.length > 0) {
        const u = queue.shift();
        taskOrder.push(u);

        for (const v of graph[u]) {
            inDegree[v]--;
            if (inDegree[v] === 0) {
                queue.push(v);
            }
        }
    }

    if (taskOrder.length === numTasks) {
        return taskOrder;
    } else {
        // There is a cycle in the graph
        return [];
    }
}

// Example usage:
const numTasks = 4;
const prerequisites = [
    [1, 0],
    [2, 1],
    [3, 2]
];

console.log(canFinishTasks(numTasks, prerequisites));  // Output: [0, 1, 2, 3]
```

### **Tips and Tricks:**
- Use in-degree counting to identify sources (tasks with no prerequisites).
- Use a queue to process tasks in a level-order manner.
- Check for cycles by comparing the length of the task order with the number of tasks.

### **Frequent Gotchas:**
- Forgetting to decrease the in-degree of dependent tasks.
- Not handling tasks with no dependencies correctly.
- Not checking for cycles, leading to incorrect task orders.

By mastering the Topological Sort technique, you can efficiently solve a variety of problems involving task scheduling, prerequisite ordering, and resolving dependencies in graphs. This technique is essential for optimizing time complexity and handling graph-related problems effectively in both technical interviews and real-world applications.