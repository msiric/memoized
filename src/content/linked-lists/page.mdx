export const metadata = {
  title: 'Comprehensive Guide to Linked Lists in JavaScript',
  description: 'Learn about the various types of linked lists and their operations. Understand their implementation, performance considerations, and practical examples.',
}

# **Linked Lists in JavaScript**

Linked Lists are a fundamental data structure used to store collections of elements, where each element points to the next element in the sequence. Unlike arrays, linked lists do not store elements in contiguous memory locations.

## **Concept and Use Cases**

**Definition:**
A linked list is a linear data structure where each element, known as a node, contains a value and a reference (or link) to the next node in the sequence. The first node is called the head and the last node is called the tail.

**Common Use Cases:**
- Implementing dynamic data structures like stacks and queues.
- Managing ordered collections that frequently change size.
- Efficient insertion and deletion of elements, especially in the middle of the list.
- Use in applications like graph adjacency lists and memory management.

## **Types of Linked Lists**
- **Singly Linked List:** Each node points to the next node.
- **Doubly Linked List:** Each node points to both the next and the previous node.
- **Circular Linked List:** The last node points back to the head, forming a circle.

## **When to Use**
- When you need a dynamic data structure with efficient insertions and deletions.
- When the order of elements matters but you don't need random access.
- When implementing other data structures like stacks and queues.

## **Time and Space Complexity**

**Time Complexity:**
- Access by index: O(n)
- Insertion/Deletion at the beginning: O(1)
- Insertion/Deletion at the end (singly linked): O(n)
- Insertion/Deletion at the end (doubly linked): O(1)
- Searching: O(n)

**Space Complexity:**
- O(n), where n is the number of elements in the list.

## **Linked List Operations and Methods**

### **Creating a Linked List**

**Example:**

<CodeGroup>

```javascript
class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }

    // Methods to be defined...
}
```

```typescript
class Node {
    value: number;
    next: Node | null;

    constructor(value: number) {
        this.value = value;
        this.next = null;
    }
}

class LinkedList {
    head: Node | null;
    size: number;

    constructor() {
        this.head = null;
        this.size = 0;
    }

    // Methods to be defined...
}
```

</CodeGroup>

### **Inserting Elements**

**At the Beginning:**

<CodeGroup>

```javascript
class LinkedList {
    // ... other methods ...

    insertAtBeginning(value) {
        const newNode = new Node(value);
        if (!this.head) {
            this.head = newNode;
        } else {
            newNode.next = this.head;
            this.head = newNode;
        }
        this.size++;
    }
}
```

```typescript
class LinkedList {
    // ... other methods ...

    insertAtBeginning(value: number) {
        const newNode = new Node(value);
        if (!this.head) {
            this.head = newNode;
        } else {
            newNode.next = this.head;
            this.head = newNode;
        }
        this.size++;
    }
}
```

</CodeGroup>

**At the End:**

<CodeGroup>

```javascript
class LinkedList {
    // ... other methods ...

    insertAtEnd(value) {
        const newNode = new Node(value);
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }
}
```

```typescript
class LinkedList {
    // ... other methods ...

    insertAtEnd(value: number) {
        const newNode = new Node(value);
        if (!this.head) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next) {
                current = current.next;
            }
            current.next = newNode;
        }
        this.size++;
    }
}
```

</CodeGroup>

### **Deleting Elements**

**From the Beginning:**

<CodeGroup>

```javascript
class LinkedList {
    // ... other methods ...

    deleteFromBeginning() {
        if (!this.head) return null;
        const value = this.head.value;
        this.head = this.head.next;
        this.size--;
        return value;
    }
}
```

```typescript
class LinkedList {
    // ... other methods ...

    deleteFromBeginning() {
        if (!this.head) return null;
        const value = this.head.value;
        this.head = this.head.next;
        this.size--;
        return value;
    }
}
```

</CodeGroup>

**From the End:**

<CodeGroup>

```javascript
class LinkedList {
    // ... other methods ...

    deleteFromEnd() {
        if (!this.head) return null;
        if (!this.head.next) {
            const value = this.head.value;
            this.head = null;
            this.size--;
            return value;
        }
        let current = this.head;
        while (current.next.next) {
            current = current.next;
        }
        const value = current.next.value;
        current.next = null;
        this.size--;
        return value;
    }
}
```

```typescript
class LinkedList {
    // ... other methods ...

    deleteFromEnd() {
        if (!this.head) return null;
        if (!this.head.next) {
            const value = this.head.value;
            this.head = null;
            this.size--;
            return value;
        }
        let current = this.head;
        while (current.next!.next) {
            current = current.next;
        }
        const value = current.next!.value;
        current.next = null;
        this.size--;
        return value;
    }
}
```

</CodeGroup>

### **Searching for Elements**

**By Value:**

<CodeGroup>

```javascript
class LinkedList {
    // ... other methods ...

    search(value) {
        let current = this.head;
        while (current) {
            if (current.value === value) return true;
            current = current.next;
        }
        return false;
    }
}
```

```typescript
class LinkedList {
    // ... other methods ...

    search(value: number): boolean {
        let current = this.head;
        while (current) {
            if (current.value === value) return true;
            current = current.next;
        }
        return false;
    }
}
```

</CodeGroup>

### **Traversing the List**

**Example:**

<CodeGroup>

```javascript
class LinkedList {
    // ... other methods ...

    traverse() {
        let current = this.head;
        while (current) {
            console.log(current.value);
            current = current.next;
        }
    }
}
```

```typescript
class LinkedList {
    // ... other methods ...

    traverse() {
        let current = this.head;
        while (current) {
            console.log(current.value);
            current = current.next;
        }
    }
}
```

</CodeGroup>

## **Practical Tips and Tricks**

- **Use Sentinel Nodes:**
  Using a dummy head node can simplify insertions and deletions by avoiding special cases for an empty list or single element list.
  **Example:**

  <CodeGroup>

  ```javascript
  class LinkedList {
      constructor() {
          this.head = new Node(null);  // Dummy node
          this.size = 0;
      }

      insertAtEnd(value) {
          const newNode = new Node(value);
          let current = this.head;
          while (current.next) {
              current = current.next;
          }
          current.next = newNode;
          this.size++;
      }

      // Other methods...
  }
  ```

  ```typescript
  class LinkedList {
      head: Node;
      size: number;

      constructor() {
          this.head = new Node(null);  // Dummy node
          this.size = 0;
      }

      insertAtEnd(value: number) {
          const newNode = new Node(value);
          let current = this.head;
          while (current.next) {
              current = current.next;
          }
          current.next = newNode;
          this.size++;
      }

      // Other methods...
  }
  ```
  </CodeGroup>

- **Reverse a Linked List:**
  Reversing a linked list is a common interview question.
  **Example:**

  <CodeGroup>

  ```javascript
  class LinkedList {
      // ... other methods ...

      reverse() {
          let prev = null;
          let current = this.head;
          while (current) {
              let next = current.next;
              current.next = prev;
              prev = current;
              current = next;
          }
          this.head = prev;
      }
  }
  ```

  ```typescript
  class LinkedList {
      // ... other methods ...

      reverse() {
          let prev: Node | null = null;
          let current: Node | null = this.head;
          while (current) {
              let next: Node | null = current.next;
              current.next = prev;
              prev = current;
              current = next;
          }
          this.head = prev;
      }
  }
  ```
  </CodeGroup>

## **Common Gotchas**

- **Null Checks:**
  Always check for null when traversing or manipulating nodes to avoid runtime errors.
  **Example:**
  ```javascript
  let current = this.head;
  while (current && current.next) {
      // Perform operations
      current = current.next;
  }
  ```

  ```typescript
  let current: Node | null = this.head;
  while (current && current.next) {
      // Perform operations
      current = current.next;
  }
  ```

- **Edge Cases:**
  Consider edge cases like empty lists, single element lists, and operations at the boundaries (beginning or end of the list).

- **Memory Leaks:**
  In languages with manual memory management, ensure that removed nodes are properly deallocated to avoid memory leaks. JavaScript manages memory automatically, but be cautious of references that might prevent garbage collection.

## **Advanced Topics**

### **Doubly Linked Lists**

Doubly linked lists have nodes that point to both the next and previous nodes, allowing for more efficient insertions and deletions from both ends.

**Example:**

<CodeGroup>

```javascript
class DoublyNode {
    constructor(value) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }
}

class DoublyLinkedList {
    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    insertAtEnd(value) {
        const newNode = new DoublyNode(value);
        if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
        } else {
            this.tail.next = newNode;
            newNode.prev = this.tail;
            this.tail = newNode;
        }
        this.size++;
    }

    // Other methods...
}
```

```typescript
class DoublyNode {
    value: number;
    next: DoublyNode | null;
    prev: DoublyNode | null;

    constructor(value: number) {
        this.value = value;
        this.next = null;
        this.prev = null;
    }
}

class DoublyLinkedList {
    head: DoublyNode | null;
    tail: DoublyNode | null;
    size: number;

    constructor() {
        this.head = null;
        this.tail = null;
        this.size = 0;
    }

    insertAtEnd(value: number) {
        const newNode = new DoublyNode(value);
        if (!this.head) {
            this.head = newNode;
            this.tail = newNode;
        } else {
            this.tail.next = newNode;
            newNode.prev = this.tail;
            this.tail = newNode;
        }
        this.size++;
    }

    // Other methods...
}
```

</CodeGroup>

### **Circular Linked Lists**

Circular linked lists have the last node pointing back to the head, forming a circle. They are useful in scenarios where the list needs to be traversed repeatedly.

**Example:**

<CodeGroup>

```javascript
class CircularLinkedList {
    constructor() {
        this.head = null;
        this.size = 0;
    }

    insertAtEnd(value) {
        const newNode = new Node(value);
        if (!this.head) {
            this.head = newNode;
            newNode.next = this.head;
        } else {
            let current = this.head;
            while (current.next !== this.head) {
                current = current.next;
            }
            current.next = newNode;
            newNode.next = this.head;
        }
        this.size++;
    }

    // Other methods...
}
```

```typescript
class CircularLinkedList {
    head: Node | null;
    size: number;

    constructor() {
        this.head = null;
        this.size = 0;
    }

    insertAtEnd(value: number) {
        const newNode = new Node(value);
        if (!this.head) {
            this.head = newNode;
            newNode.next = this.head;
        } else {
            let current = this.head;
            while (current.next !== this.head) {
                current = current.next;
            }
            current.next = newNode;
            newNode.next = this.head;
        }
        this.size++;
    }

    // Other methods...
}
```

</CodeGroup>

## **Linked List Algorithms**
Below are some common linked list algorithms you should be familiar with:

### **Detecting a Cycle**
Detecting a cycle in a linked list checks if there is a loop where a node's next pointer points back to a previous node.

**Example:**

<CodeGroup>

```javascript
class LinkedList {
    constructor() {
        this.head = null;
    }

    // ... other methods ...

    hasCycle() {
        let slow = this.head;
        let fast = this.head;
        while (fast && fast.next) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow === fast) return true;
        }
        return false;
    }
}
```

```typescript
class LinkedList {
    head: Node | null;

    constructor() {
        this.head = null;
    }

    // ... other methods ...

    hasCycle(): boolean {
        let slow: Node | null = this.head;
        let fast: Node | null = this.head;
        while (fast && fast.next) {
            slow = slow.next;
            fast = fast.next.next;
            if (slow === fast) return true;
        }
        return false;
    }
}
```

</CodeGroup>

### **Merging Two Sorted Lists**
Merging two sorted lists combines them into a single sorted linked list.

**Example:**

<CodeGroup>

```javascript
class Node {
    constructor(value = 0, next = null) {
        this.value = value;
        this.next = next;
    }
}

function mergeTwoSortedLists(l1, l2) {
    let dummy = new Node(0);
    let current = dummy;

    while (l1 && l2) {
        if (l1.value < l2.value) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }

    current.next = l1 || l2;
    return dummy.next;
}

// Example usage:
let l1 = new Node(1, new Node(3, new Node(5)));
let l2 = new Node(2, new Node(4, new Node(6)));
let mergedList = mergeTwoSortedLists(l1, l2);

// Printing the merged list
let current = mergedList;
while (current) {
    console.log(current.value);
    current = current.next;
}
// Output: 1, 2, 3, 4, 5, 6
```

```typescript
class Node {
    value: number;
    next: Node | null;

    constructor(value: number, next: Node | null = null) {
        this.value = value;
        this.next = next;
    }
}

function mergeTwoSortedLists(l1: Node | null, l2: Node | null): Node | null {
    let dummy = new Node(0);
    let current = dummy;

    while (l1 && l2) {
        if (l1.value < l2.value) {
            current.next = l1;
            l1 = l1.next;
        } else {
            current.next = l2;
            l2 = l2.next;
        }
        current = current.next;
    }

    current.next = l1 || l2;
    return dummy.next;
}

// Example usage:
let l1 = new Node(1, new Node(3, new Node(5)));
let l2 = new Node(2, new Node(4, new Node(6)));
let mergedList = mergeTwoSortedLists(l1, l2);

// Printing the merged list
let current: Node | null = mergedList;
while (current) {
    console.log(current.value);
    current = current.next;
}
// Output: 1, 2, 3, 4, 5, 6
```

</CodeGroup>

## **Interview Tips and Tricks**

- **Master Basic Operations:**
  Be comfortable with implementing and using basic operations like insertion, deletion, and traversal.
- **Practice Common Algorithms:**
  Familiarize yourself with algorithms like reversing a list, detecting cycles, and merging sorted lists.
- **Consider Edge Cases:**
  Always consider edge cases like empty lists, single element lists, and operations at the boundaries.
- **Understand Memory Management:**
  Understand how linked lists are managed in memory and the implications of pointers/references.

## **Common Mistakes**

- **Incorrect Pointer Updates:**
  Ensure that pointers are correctly updated during insertions and deletions to avoid losing nodes.
- **Ignoring Edge Cases:**
  Consider all edge cases, such as operations on an empty list or a list with a single element.
- **Forgetting Size Updates:**
  Remember to update the size of the list during insertions and deletions.

By mastering linked lists and understanding their intricacies, you will be well-equipped to handle a variety of interview questions and real-world problems involving dynamic collections of data. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.