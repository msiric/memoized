export const metadata = {
  title: 'Comprehensive Guide to Randomized Algorithms in JavaScript',
  description: 'Utilize randomness to solve problems efficiently. Understand randomized algorithms, performance considerations, and practical examples.',
}

# **Randomized Algorithms**

Randomized algorithms use random numbers at some point during their logic to make decisions. These algorithms often provide simpler, faster, or more robust solutions to problems compared to their deterministic counterparts.

## **Concept and Use Cases**

**Definition:**
Randomized algorithms are algorithms that make random choices during their execution to achieve good performance on average. They can be classified into two categories:
- **Las Vegas Algorithms:** Always produce the correct result, but their runtime may vary.
- **Monte Carlo Algorithms:** Have a probability of producing the correct result within a given runtime.

**Common Use Cases:**
- Quick sort
- Hashing
- Probabilistic data structures (e.g., Bloom Filters)
- Graph algorithms (e.g., random walks)

## **Key Concepts**

1. **Random Choices:**
   - Randomized algorithms make random choices during execution, which can lead to different outcomes even for the same input.

2. **Expected Runtime:**
   - The performance of randomized algorithms is often analyzed in terms of expected runtime, which is the average runtime over all possible random choices.

3. **Probability of Correctness:**
   - For Monte Carlo algorithms, the probability of correctness is an important measure, while for Las Vegas algorithms, the runtime is a key measure.

## **Time and Space Complexity**

**Time Complexity:**
- Varies based on the algorithm and the specific problem being solved.

**Space Complexity:**
- Typically similar to their deterministic counterparts, but may include additional space for random number generation.

## **Randomized Algorithms and Methods**

### **Randomized Quick Sort**

**Steps:**
1. Choose a random pivot element.
2. Partition the array around the pivot.
3. Recursively sort the subarrays.

**Example:**
```javascript
function randomizedQuickSort(arr, low = 0, high = arr.length - 1) {
    if (low < high) {
        const pi = randomizedPartition(arr, low, high);
        randomizedQuickSort(arr, low, pi - 1);
        randomizedQuickSort(arr, pi + 1, high);
    }
}

function randomizedPartition(arr, low, high) {
    const randomIndex = Math.floor(Math.random() * (high - low + 1)) + low;
    [arr[randomIndex], arr[high]] = [arr[high], arr[randomIndex]];
    return partition(arr, low, high);
}

function partition(arr, low, high) {
    const pivot = arr[high];
    let i = low - 1;
    for (let j = low; j < high; j++) {
        if (arr[j] < pivot) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return i + 1;
}

// Example usage:
const arr = [10, 7, 8, 9, 1, 5];
randomizedQuickSort(arr);
console.log(arr);  // Output: [ 1, 5, 7, 8, 9, 10 ]
```

### **Reservoir Sampling**

**Problem:**
Select k random elements from a list of n elements, where n is large or unknown.

**Example:**
```javascript
function reservoirSampling(stream, k) {
    const reservoir = stream.slice(0, k);
    for (let i = k; i < stream.length; i++) {
        const j = Math.floor(Math.random() * (i + 1));
        if (j < k) {
            reservoir[j] = stream[i];
        }
    }
    return reservoir;
}

// Example usage:
const stream = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const k = 4;
console.log(reservoirSampling(stream, k));  // Output: 4 random elements from the stream
```

### **Randomized Selection (Quickselect)**

**Problem:**
Find the k-th smallest element in an unordered list.

**Steps:**
1. Choose a random pivot element.
2. Partition the array around the pivot.
3. Recur on the appropriate subarray.

**Example:**
```javascript
function randomizedSelect(arr, k, low = 0, high = arr.length - 1) {
    if (low === high) return arr[low];

    const pi = randomizedPartition(arr, low, high);

    const length = pi - low + 1;
    if (length === k) return arr[pi];
    if (k < length) return randomizedSelect(arr, k, low, pi - 1);
    return randomizedSelect(arr, k - length, pi + 1, high);
}

// Example usage:
const arr = [12, 3, 5, 7, 4, 19, 26];
const k = 3;
console.log(randomizedSelect(arr, k));  // Output: 5
```

### **Monte Carlo Algorithm: Primality Test**

**Problem:**
Check if a number is prime using a probabilistic method.

**Example:**
```javascript
function isPrime(n, k = 5) {
    if (n <= 1 || n === 4) return false;
    if (n <= 3) return true;

    while (k > 0) {
        const a = 2 + Math.floor(Math.random() * (n - 4));
        if (gcd(n, a) !== 1) return false;
        if (modExp(a, n - 1, n) !== 1) return false;
        k--;
    }

    return true;
}

function gcd(a, b) {
    if (b === 0) return a;
    return gcd(b, a % b);
}

function modExp(base, exp, mod) {
    let result = 1;
    base = base % mod;
    while (exp > 0) {
        if (exp % 2 === 1) result = (result * base) % mod;
        exp = Math.floor(exp / 2);
        base = (base * base) % mod;
    }
    return result;
}

// Example usage:
const num = 17;
console.log(isPrime(num));  // Output: true
```

## **Practical Tips and Tricks**

- **Random Seed:**
  For reproducibility, consider using a fixed seed for the random number generator during testing.

- **Balance Randomness:**
  Ensure that the randomness is balanced to avoid biased outcomes, especially in selection and partitioning algorithms.

- **Combine with Deterministic Methods:**
  Use randomized algorithms in combination with deterministic methods to handle worst-case scenarios.

## **Common Gotchas**

- **Bias in Randomness:**
  Ensure that the random choices are uniformly distributed to avoid biased results.

- **Infinite Loops:**
  Be cautious of potential infinite loops in randomized algorithms, especially in Monte Carlo methods.

- **Resource Consumption:**
  Randomized algorithms can sometimes consume more resources (time/memory) due to their probabilistic nature.

## **Advanced Topics**

### **Randomized Graph Algorithms**

**Randomized Minimum Cut**

**Problem:**
Find a minimum cut in an undirected graph using a randomized approach.

**Example:**
```javascript
class Graph {
    constructor(vertices) {
        this.V = vertices;
        this.edges = [];
    }

    addEdge(u, v) {
        this.edges.push([u, v]);
    }

    findMinCut() {
        let minCut = Infinity;

        for (let i = 0; i < this.V * this.V; i++) {
            const result = this.kargerMinCut();
            minCut = Math.min(minCut, result);
        }

        return minCut;
    }

    kargerMinCut() {
        const vertices = [...Array(this.V).keys()];
        const edges = [...this.edges];

        while (vertices.length > 2) {
            const randomIndex = Math.floor(Math.random() * edges.length);
            const [u, v] = edges[randomIndex];

            const mergedVertex = vertices.indexOf(v);
            vertices.splice(mergedVertex, 1);

            edges.forEach((edge, index) => {
                if (edge[0] === v) edge[0] = u;
                if (edge[1] === v) edge[1] = u;
                if (edge[0] === edge[1]) edges.splice(index, 1);
            });
        }

        return edges.length;
    }
}

// Example usage:
const graph = new Graph(4);
graph.addEdge(0, 1);
graph.addEdge(0, 2);
graph.addEdge(1, 2);
graph.addEdge(1, 3);
graph.addEdge(2, 3);

console.log(graph.findMinCut());  // Output: 2
```

### **Random Walks**

**Problem:**
Simulate a random walk on a graph to estimate properties such as node centrality or the probability of reaching a certain state.

**Example:**
```javascript
class RandomWalk {
    constructor(graph) {
        this.graph = graph;
    }

    walk(start, steps) {
        let current = start;
        for (let i = 0; i < steps; i++) {
            const neighbors = this.graph.getNeighbors(current);
            if (neighbors.length === 0) break;
            current = neighbors[Math.floor(Math.random() * neighbors.length)];
        }
        return current;
    }
}

// Example usage:
class Graph {
    constructor() {
        this.adjList = new Map();
    }

    addEdge(u, v) {
        if (!this.adjList.has(u)) this.adjList.set(u, []);
        if (!this.adjList.has(v)) this.adjList.set(v, []);
        this.adjList.get(u).push(v);
        this.adjList.get(v).push(u);
    }

    getNeighbors(v) {
        return this.adjList.get(v) || [];
    }
}

const graph = new Graph();
graph.addEdge(0, 1);
graph.addEdge(0, 2);
graph.addEdge(1, 2);
graph.addEdge(1, 3);
graph.addEdge(2, 3);

const randomWalk = new RandomWalk(graph);
console.log(randomWalk.walk(0, 10));  // Output: Random vertex reached after 10 steps
```

## **Interview Tips and Tricks**

- **Explain the Random Choices:**
  Clearly explain how random choices are made and their impact on the algorithm's performance.

- **Expected Runtime:**
  Discuss the expected runtime and average-case complexity of randomized algorithms.

- **Compare with Deterministic Algorithms:**
  Highlight the advantages and disadvantages of randomized algorithms compared to deterministic algorithms.

- **Use Cases:**
  Provide examples of practical use cases where randomized algorithms are beneficial.

## **Common Mistakes**

- **Incorrect Random Choices:**
  Ensure that random choices are made uniformly to avoid biased results.

- **Infinite Loops:**
  Be cautious of potential infinite loops in algorithms like random walks and Monte Carlo methods.

- **Resource Consumption:**
  Manage resource consumption carefully, especially in algorithms that rely heavily on random number generation.

By mastering Randomized Algorithms and understanding their intricacies, you will be well-equipped to handle a variety of problems with innovative and efficient solutions. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.