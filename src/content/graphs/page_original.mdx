export const metadata = {
  title: 'Quickstart',
  description:
    'This guide will get you all set up and ready to use the Protocol API. We’ll cover how to get started an API client and how to make your first API request.',
}

# Comprehensive Guide to Graphs in JavaScript

Graphs are abstract data structures that consist of a set of nodes (also called vertices) and edges that connect pairs of nodes. Graphs are incredibly powerful for modeling complex relationships and structures in various domains.

**Definition:**
A graph G is defined as a pair (V,E), where V is a set of vertices and E is a set of edges connecting the vertices.

**Use Cases:**

Social Networks: Graphs model networks of users, where vertices represent users and edges represent connections or interactions between users.
Geographic Information Systems: Used to represent maps, locations, and routes where intersections and roads are vertices and edges, respectively.
Network Traffic Routing: Routers and switches form vertices, and the cables or paths between them are edges, optimizing the flow of data across the network.

## Basic Concepts and Terminology

Understanding the fundamental components and types of graphs is crucial for their implementation and application.

**Vertices and Edges:**

Vertices are the fundamental units of graphs and can represent entities such as people, cities, or nodes in a network.
Edges connect the vertices and can represent relationships or pathways between the entities.

**Directed vs. Undirected Graphs:**

Directed Graphs (Digraphs): Edges have a direction, indicating a one-way relationship. For example, in a Twitter follower graph, an edge from vertex A to vertex B might indicate that A follows B.
Undirected Graphs: Edges have no direction, representing a bidirectional relationship. For example, in a Facebook friends graph, an edge between vertices A and B indicates that A and B are friends.

**Weighted vs. Unweighted:**

Weighted Graphs: Edges have weights or costs associated with them, which can represent distances, costs, or any metric that quantifies the connection.
Unweighted Graphs: Edges do not have any weights associated with them.

**Adjacency Matrix and Adjacency List:**

Adjacency Matrix: A 2D array where the entry at row i and column j indicates whether there is an edge from vertex i to vertex j, and possibly the weight of the edge.
Adjacency List: Each vertex stores a list of adjacent vertices. This is more space-efficient in sparse graphs compared to an adjacency matrix.

**Cycles and Acyclic Graphs:**

Cycles: A cycle in a graph is a path of edges and vertices wherein a vertex is reachable from itself.
Acyclic Graphs: Graphs that do not contain any cycles. A directed acyclic graph (DAG) is often used in scenarios like task scheduling where cycles could represent contradictions or deadlock conditions.

## Implementing Graphs in JavaScript

Let’s start with implementing a basic graph using an adjacency list, which is efficient for sparse graphs and typical in real-world applications.

**Adjacency List Representation:**

Here's how you might implement a simple undirected graph using JavaScript:

```js
class Graph {
  constructor() {
    this.adjacencyList = {};
  }

  addVertex(vertex) {
    if (!this.adjacencyList[vertex]) {
      this.adjacencyList[vertex] = [];
    }
  }

  addEdge(vertex1, vertex2) {
    this.adjacencyList[vertex1].push(vertex2);
    this.adjacencyList[vertex2].push(vertex1);
  }

  removeEdge(vertex1, vertex2) {
    this.adjacencyList[vertex1] = this.adjacencyList[vertex1].filter(v => v !== vertex2);
    this.adjacencyList[vertex2] = this.adjacencyList[vertex2].filter(v => v !== vertex1);
  }

  removeVertex(vertex) {
    while (this.adjacencyList[vertex].length) {
      const adjacentVertex = this.adjacencyList[vertex].pop();
      this.removeEdge(vertex, adjacentVertex);
    }
    delete this.adjacencyList[vertex];
  }
}
```

## Graph Traversal Algorithms

Graph traversal is crucial for exploring a graph and can be performed in various ways, each suitable for different kinds of problems:

**Depth-First Search (DFS):**

DFS explores as far as possible along each branch before backtracking, making it useful for scenarios that need to explore all possibilities before making a decision.

**Recursive Implementation:**

```js
function dfsRecursive(vertex, visited = new Set(), results = []) {
  if (!vertex || visited.has(vertex)) return;
  visited.add(vertex);
  results.push(vertex);
  const neighbors = this.adjacencyList[vertex];
  neighbors.forEach(neighbor => dfsRecursive.call(this, neighbor, visited, results));
  return results;
}
```

**Iterative Implementation:**

Using a stack can simulate the recursive stack call:

```js
function dfsIterative(start) {
  const stack = [start];
  const results = [];
  const visited = new Set();
  visited.add(start);

  while (stack.length) {
    const vertex = stack.pop();
    results.push(vertex);

    this.adjacencyList[vertex].forEach(neighbor => {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        stack.push(neighbor);
      }
    });
  }
  return results;
}
```

**Breadth-First Search (BFS):**

BFS explores the neighbor vertices at the present depth prior to moving on to nodes at the next depth level. It’s excellent for finding the shortest path on unweighted graphs.

**Implementation using a Queue:**

```js
function bfs(start) {
  const queue = [start];
  const results = [];
  const visited = new Set();
  visited.add(start);

  while (queue.length) {
    const vertex = queue.shift();
    results.push(vertex);

    this.adjacencyList[vertex].forEach(neighbor => {
      if (!visited.has(neighbor)) {
        visited.add(neighbor);
        queue.push(neighbor);
      }
    });
  }
  return results;
}
```

**Applications:**

DFS is particularly useful in scenarios such as puzzle solving (e.g., mazes), where it's crucial to explore a complete path before backtracking.
BFS is used for finding the shortest path in routing and networking, or in algorithms like Dijkstra’s and the Bellman-Ford for weighted graphs.

## Common Graph Algorithms

Some of the most impactful graph algorithms are those that solve classical problems such as shortest paths and network flows:

**Dijkstra’s Algorithm:**

Finds the shortest paths from a single source vertex to all other vertices in a graph with non-negative edge weights.

```js
function dijkstra(start) {
  const distances = {};
  const priorityQueue = new PriorityQueue();
  const previous = {};
  let path = []; // to return at end
  let smallest;

  // initial state
  for (let vertex in this.adjacencyList) {
    if (vertex === start) {
      distances[vertex] = 0;
      priorityQueue.enqueue(vertex, 0);
    } else {
      distances[vertex] = Infinity;
      priorityQueue.enqueue(vertex, Infinity);
    }
    previous[vertex] = null;
  }

  // as long as there is something to visit
  while (priorityQueue.values.length) {
    smallest = priorityQueue.dequeue().val;
    if (smallest === end) {
      // build up path to return at end
      while (previous[smallest]) {
        path.push(smallest);
        smallest = previous[smallest];
      }
      break;
    }

    if (smallest || distances[smallest] !== Infinity) {
      for (let neighbor in this.adjacencyList[smallest]) {
        // find neighboring node
        let nextNode = this.adjacencyList[smallest][neighbor];
        // calculate new distance to neighboring node
        let candidate = distances[smallest] + nextNode.weight;
        let nextNeighbor = nextNode.node;
        if (candidate < distances[nextNeighbor]) {
          // updating new smallest distance to neighbor
          distances[nextNeighbor] = candidate;
          // updating previous - How we got to neighbor
          previous[nextNeighbor] = smallest;
          // enqueue in priority queue with new priority
          priorityQueue.enqueue(nextNeighbor, candidate);
        }
      }
    }
  }
  return path.concat(smallest).reverse();
}
```

**Bellman-Ford Algorithm:**

Similar to Dijkstra’s but can handle graphs with negative weight edges. It improves distances gradually by iterating through the edges and adjusting distances until no further improvements can be made or until it has iterated V−1 times (where V is the number of vertices).

**Floyd-Warshall Algorithm:**

A dynamic programming algorithm that finds shortest paths between all pairs of vertices. It can process negative weights and detect negative cycles in the graph.

**Topological Sorting:**

Useful for scheduling tasks, topological sorting of a DAG provides an ordering of the vertices such that for every directed edge UV, vertex U comes before V in the ordering.

## Common Interview Problems

Interview problems involving graphs are designed to test your understanding of graph operations and your ability to apply algorithms to solve complex problems efficiently:

**Detecting Cycles:**

Detecting cycles in a graph is crucial for understanding whether the graph has any circular dependencies. For directed graphs, DFS can be adapted to detect cycles, while for undirected graphs, you can use either DFS or Union-Find.

```js
function detectCycle(graph) {
  const visited = new Set();
  const recStack = new Set();

  const dfs = vertex => {
    if (!visited.has(vertex)) {
      visited.add(vertex);
      recStack.add(vertex);

      for (const neighbor of graph.adjacencyList[vertex]) {
        if (!visited.has(neighbor) && dfs(neighbor)) {
          return true;
        } else if (recStack.has(neighbor)) {
          return true;
        }
      }
    }
    recStack.delete(vertex);
    return false;
  };

  for (const vertex in graph.adjacencyList) {
    if (dfs(vertex)) {
      return true;
    }
  }
  return false;
}
```

**Finding Connected Components:**

This problem involves finding all distinct connected components in an undirected graph. It can be solved using either DFS or BFS to explore the graph.

```js
function findConnectedComponents(graph) {
  const visited = new Set();
  let count = 0;

  for (const vertex in graph.adjacencyList) {
    if (!visited.has(vertex)) {
      dfs(graph, vertex, visited);
      count++; // Each DFS call completes a connected component
    }
  }

  function dfs(graph, vertex, visited) {
    visited.add(vertex);
    for (const neighbor of graph.adjacencyList[vertex]) {
      if (!visited.has(neighbor)) {
        dfs(graph, neighbor, visited);
      }
    }
  }

  return count;
}
```

**Minimum Spanning Tree (MST):**

Kruskal’s and Prim’s algorithms are popular methods for finding the MST of a graph, which is a subset of the edges that connects all vertices without any cycles and with the minimum possible total edge weight.

```js
// Pseudo-code or discussion for Kruskal's and Prim's algorithms
```
## Advanced Topics

Graphs have a variety of more complex applications and structures that can provide sophisticated solutions to advanced problems:

**Graph Coloring:**

Graph coloring problems are fundamental in scenarios like register allocation in compilers or scheduling problems, where each color represents a register or a time slot.

```js
// Discussion or pseudo-code for a graph coloring algorithm
```

**Network Flow:**

The maximum flow problems can be solved using algorithms like Ford-Fulkerson method, which finds the greatest possible flow in a network.

```js
// Brief introduction to concepts like flow network, residual graphs, and augmenting paths
```
## Exercises and Challenges

To master graph algorithms, it’s crucial to practice implementing and solving problems:

**Hands-On Coding:**

Implement graph representations, traversal algorithms, and solve classic problems like shortest path, cycle detection, and MST using a variety of graph types.

**Mock Interviews and Problem-Solving Sessions:**

Regular practice sessions focusing on graph problems can help you prepare for technical interviews and develop problem-solving strategies.

Review and Resources

Consistent review and accessing quality resources are key to deepening your understanding of graphs:

**Summary Sessions:**

Regularly revisit key concepts and algorithms to reinforce learning and address any areas of confusion.

**Further Reading and Practice Platforms:**

Platforms like LeetCode, HackerRank, and CodeSignal are recommended for practice. Books and online tutorials can also provide in-depth insights into graph theory and applications.

**Visual Aids and Teaching Tools:**

Utilize diagrams to illustrate concepts, and platforms like JSFiddle or CodePen for live coding demonstrations and interactive learning.

## Understanding Graphs

Basic Concepts

Vertices and Edges: A graph G is defined as a set of vertices V and a set of edges E connecting these vertices. Vertices represent entities, and edges represent the relationships or interactions between these entities.

**Directed vs. Undirected Graphs:**

Directed Graph (Digraph): Edges have a direction, indicating a one-way relationship.
Undirected Graph: Edges do not have a direction, indicating a two-way or mutual relationship.

Weighted vs. Unweighted Graphs

Weighted Graphs: Edges have weights or costs associated with them, often representing distance, time, or other metrics.
Unweighted Graphs: Edges do not have weights; they simply represent a connection.

Cyclic vs. Acyclic Graphs

Cyclic Graphs: Contain cycles, which are paths from a vertex back to itself.
Acyclic Graphs: Do not contain cycles. A special kind of acyclic graph is a tree.

Connectivity

Graphs can be connected or disconnected. A connected graph means there is a path between any two vertices, which is an important property for many algorithms.

## Common Graph Representations

Adjacency Matrix: A 2D array where the element at row i and column j is non-zero if there is an edge from vertex i to vertex j.
Adjacency List: An array of lists. The index represents a vertex and each element in its list represents the other vertices that form an edge with the vertex.

## Graph Traversal Algorithms

These are fundamental for exploring a graph and are typically used as subroutines in other complex graph algorithms.

Depth-First Search (DFS): Explores as far as possible along each branch before backtracking.
Breadth-First Search (BFS): Explores all the neighbors at the present depth prior to moving on to nodes at the next depth level.

Implementation Example in JavaScript

Here's how you might implement a simple graph with an adjacency list and perform BFS:

```js
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) this.adjacencyList[vertex] = [];
    }

    addEdge(v1, v2) {
        this.adjacencyList[v1].push(v2);
        this.adjacencyList[v2].push(v1);
    }

    bfs(start) {
        const queue = [start];
        const result = [];
        const visited = {};
        visited[start] = true;

        while (queue.length) {
            let currentVertex = queue.shift();
            result.push(currentVertex);

            this.adjacencyList[currentVertex].forEach(neighbor => {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            });
        }

        return result;
    }
}
```

## Advanced Graph Algorithms

Dijkstra’s Algorithm: Finds the shortest path from a source vertex to all other vertices in a weighted graph.
Bellman-Ford Algorithm: Also calculates shortest paths and can handle graphs with negative weight edges.
Floyd-Warshall Algorithm: A dynamic programming algorithm that finds shortest paths between all pairs of vertices.
Topological Sorting: Used in directed acyclic graphs (DAG) to linearly order the vertices such that for every directed edge u→v, vertex u comes before v in the ordering.

## Practical Interview Tips

Understand Problem Context: Clarify whether the graph in question is directed, undirected, weighted, or unweighted, as this can significantly affect which algorithms are appropriate.
Discuss Applications: Be prepared to discuss real-world applications of graph theories, such as social network analysis, route planning in logistics, or web crawlers in search engines.
Optimization and Edge Cases: Discuss potential optimizations and consider edge cases in graph algorithms, such as disconnected graphs, graphs with loops, or graphs with a single node.

## Additional Graph Concepts and Techniques

Graph Coloring

Used in scheduling problems, map coloring, and assigning frequencies for cellular towers, graph coloring involves assigning colors to vertices so that no two adjacent vertices share the same color. This is often used to demonstrate the concept of NP-completeness.

Network Flow

Problems like the maximum flow, which calculates the greatest possible flow in a network, use algorithms like Ford-Fulkerson or Edmonds-Karp. These are crucial for understanding resource distribution networks, traffic flow, or data streaming capacities.

Centrality Measures

In social network analysis or web link analysis, determining the importance of a vertex within a graph is crucial. Algorithms to determine centrality measures like Degree, Closeness, and Betweenness Centrality are essential.

## Handling Special Types of Graphs

Sparse vs. Dense Graphs

Sparse graphs have relatively few edges. Adjacency lists are more space-efficient for these graphs.
Dense graphs have many edges, approaching a complete graph, where an adjacency matrix might be more time-efficient despite higher space costs.

Planar Graphs

Graphs that can be drawn on a plane without any edges crossing. Algorithms for planar graphs are useful in computer graphics, circuit design, and geography.

## Practical Implementations and Optimization

Graph Databases

Graph databases like Neo4j are designed to handle very large graphs with billions of vertices and edges, offering optimized indexing schemes and query languages (e.g., Cypher).

Distributed Graph Processing

Techniques like those employed by Apache Giraph or Google's Pregel are designed to handle massive graphs by distributing processing across multiple machines.

## Common Mistakes and Pitfalls

Neglecting Graph Properties

Ignoring properties like connectivity, acyclicity, or planarity can lead to incorrect choices of algorithms or data structures, resulting in inefficient or incorrect implementations.

Complexity Misestimation

Misestimating time or space complexity in graph algorithms can lead to performance bottlenecks, especially with large-scale data.

## Advanced Problem Solving with Graphs

Dynamic Graph Algorithms

Algorithms that maintain certain properties or answers (like shortest paths, connected components) as the graph is modified by additions or deletions of edges or vertices.

Randomized and Approximation Algorithms

For problems that are NP-hard, like most graph coloring or certain types of network design problems, using algorithms that yield good enough solutions quickly or with certain probabilistic guarantees can be practical.

## Interview Strategy and Discussion Points

Algorithm Adaptation: Be prepared to adapt basic graph algorithms to handle specific constraints or optimizations posed during interviews.
Problem Decomposition: Often, complex problems can be decomposed into smaller subproblems using graph-based approaches. Demonstrating this ability can significantly impress interviewers.
Real-World Applications: Discuss how theoretical graph problems map to real-world systems, such as traffic navigation, recommendation systems, or even power grid management.