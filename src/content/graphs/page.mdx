export const metadata = {
  title: 'Comprehensive Guide to Graphs in JavaScript',
  description: 'Learn about graph representations and graph traversal methods. Understand graph algorithms, performance considerations, and practical examples.',
}

# **Graphs in JavaScript**

Graphs are a fundamental data structure used to model relationships between objects. They consist of nodes (vertices) connected by edges. Graphs are widely used in various applications, including social networks, transportation systems, and web page linking.

## **Concept and Use Cases**

**Definition:**
A graph is a collection of nodes (vertices) connected by edges. Graphs can be directed or undirected and can have weighted or unweighted edges.

**Common Use Cases:**
- Representing networks (e.g., social networks, computer networks).
- Modeling relationships (e.g., family trees, organizational structures).
- Solving routing problems (e.g., GPS navigation, airline routing).
- Analyzing web page links (e.g., PageRank algorithm).

## **Types of Graphs**
- **Undirected Graph:** Edges have no direction.
- **Directed Graph (Digraph):** Edges have a direction.
- **Weighted Graph:** Edges have weights (costs).
- **Unweighted Graph:** Edges have no weights.
- **Cyclic Graph:** Contains cycles.
- **Acyclic Graph:** Contains no cycles.

## **When to Use**
- When modeling pairwise relationships between entities.
- When performing traversal or pathfinding algorithms.
- When analyzing network structures and connectivity.

## **Time and Space Complexity**

**Time Complexity:**
- Adding a vertex: O(1)
- Adding an edge: O(1) for adjacency list, O(V) for adjacency matrix
- Removing a vertex: O(V + E) for adjacency list, O(V^2) for adjacency matrix
- Removing an edge: O(E) for adjacency list, O(1) for adjacency matrix
- Searching/traversing: O(V + E)

**Space Complexity:**
- Adjacency List: O(V + E)
- Adjacency Matrix: O(V^2)

## **Graph Representation**

### **Adjacency List**

**Example:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(vertex1, vertex2) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1].push(vertex2);
            this.adjacencyList[vertex2].push(vertex1);  // Remove this line for directed graphs
        }
    }

    // Other methods...
}
```

### **Adjacency Matrix**

**Example:**
```javascript
class Graph {
    constructor(size) {
        this.size = size;
        this.adjacencyMatrix = Array.from({ length: size }, () => Array(size).fill(0));
    }

    addVertex(vertex) {
        // Optional: Ensure vertex is within bounds
    }

    addEdge(vertex1, vertex2) {
        this.adjacencyMatrix[vertex1][vertex2] = 1;
        this.adjacencyMatrix[vertex2][vertex1] = 1;  // Remove this line for directed graphs
    }

    // Other methods...
}
```

## **Graph Operations and Methods**

### **Adding and Removing Vertices and Edges**

**Example:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(vertex1, vertex2) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1].push(vertex2);
            this.adjacencyList[vertex2].push(vertex1);  // Remove this line for directed graphs
        }
    }

    removeEdge(vertex1, vertex2) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1] = this.adjacencyList[vertex1].filter(v => v !== vertex2);
            this.adjacencyList[vertex2] = this.adjacencyList[vertex2].filter(v => v !== vertex1);
        }
    }

    removeVertex(vertex) {
        if (this.adjacencyList[vertex]) {
            while (this.adjacencyList[vertex].length) {
                const adjacentVertex = this.adjacencyList[vertex].pop();
                this.removeEdge(vertex, adjacentVertex);
            }
            delete this.adjacencyList[vertex];
        }
    }

    // Other methods...
}
```

### **Graph Traversal**

**Depth-First Search (DFS):**

**Example:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(vertex1, vertex2) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1].push(vertex2);
            this.adjacencyList[vertex2].push(vertex1);  // Remove this line for directed graphs
        }
    }

    dfs(start) {
        const result = [];
        const visited = {};
        const adjacencyList = this.adjacencyList;

        (function dfsRecursive(vertex) {
            if (!vertex) return null;
            visited[vertex] = true;
            result.push(vertex);

            adjacencyList[vertex].forEach(neighbor => {
                if (!visited[neighbor]) {
                    return dfsRecursive(neighbor);
                }
            });
        })(start);

        return result;
    }

    // Other methods...
}
```

**Breadth-First Search (BFS):**

**Example:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(vertex1, vertex2) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1].push(vertex2);
            this.adjacencyList[vertex2].push(vertex1);  // Remove this line for directed graphs
        }
    }

    bfs(start) {
        const queue = [start];
        const result = [];
        const visited = {};
        visited[start] = true;

        while (queue.length) {
            const vertex = queue.shift();
            result.push(vertex);

            this.adjacencyList[vertex].forEach(neighbor => {
                if (!visited[neighbor]) {
                    visited[neighbor] = true;
                    queue.push(neighbor);
                }
            });
        }

        return result;
    }

    // Other methods...
}
```

## **Practical Tips and Tricks**

- **Use Adjacency List for Sparse Graphs:**
  Adjacency lists are more space-efficient for sparse graphs.
  **Example:**
  ```javascript
  let graph = new Graph();
  graph.addVertex('A');
  graph.addVertex('B');
  graph.addEdge('A', 'B');
  console.log(graph.adjacencyList);  // Output: { A: ['B'], B: ['A'] }
  ```

- **Use Adjacency Matrix for Dense Graphs:**
  Adjacency matrices are more efficient for dense graphs and can quickly check if an edge exists.
  **Example:**
  ```javascript
  let graph = new Graph(3);
  graph.addEdge(0, 1);
  graph.addEdge(0, 2);
  console.log(graph.adjacencyMatrix);  // Output: [ [ 0, 1, 1 ], [ 1, 0, 0 ], [ 1, 0, 0 ] ]
  ```

- **Detect Cycles in Graphs:**
  Use DFS with recursion stack or union-find data structure to detect cycles.
  **Example:**
  ```javascript
  function hasCycle(graph) {
      const visited = new Set();
      const recStack = new Set();

      function dfs(vertex) {
          if (!visited.has(vertex)) {
              visited.add(vertex);
              recStack.add(vertex);

              for (let neighbor of graph[vertex]) {
                  if (!visited.has(neighbor) && dfs(neighbor)) {
                      return true;
                  } else if (recStack.has(neighbor)) {
                      return true;
                  }
              }
          }
          recStack.delete(vertex);
          return false;
      }

      for (let vertex in graph) {
          if (dfs(vertex)) {
              return true;
          }
      }
      return false;
  }

  let graph = {
      A: ['B'],
      B: ['C'],
      C: ['A']
  };

  console.log(hasCycle(graph));  // Output: true
  ```

## **Common Gotchas**

- **Disconnected Graphs:**
  Ensure traversal algorithms handle disconnected graphs by iterating through all vertices.
  **Example:**
  ```javascript
  function dfsAll(graph) {
      const visited = {};
      const result = [];

      for (let vertex in graph) {
          if (!visited[vertex]) {
              (function dfs(vertex) {
                  if (!vertex) return null;
                  visited[vertex] = true;
                  result.push(vertex);

                  graph[vertex].forEach(neighbor => {
                      if (!visited[neighbor]) {
                          return dfs(neighbor);
                      }
                  });
              })(vertex);
          }
      }

      return result;
  }
  ```

- **Bidirectional Edges in Directed Graphs:**
  Be cautious when adding edges to directed graphs to ensure the correct direction.
  **Example:**
  ```javascript
  function addDirectedEdge(graph, vertex1, vertex2) {
      if (!graph[vertex1]) graph[vertex1] = [];
      graph[vertex1].push(vertex2);
  }
  ```

- **Cycle Detection:**
  Ensure cycle detection algorithms properly handle directed vs. undirected graphs.
  **Example:**
  ```javascript
  function detectCycleDirected(graph) {
      const visited = new Set();
      const recStack = new Set();

      function dfs(vertex) {
          if (!visited.has(vertex)) {
              visited.add(vertex);
              recStack.add(vertex);

              for (let neighbor of graph[vertex]) {
                  if (!visited.has(neighbor) && dfs(neighbor)) {
                      return true;
                  } else if (recStack.has(neighbor)) {
                      return true;
                  }
              }
          }
          recStack.delete(vertex);
          return false;
      }

      for (let vertex in graph) {
          if (dfs(vertex)) {
              return true;
          }
      }
      return false;
  }
  ```

## **Advanced Topics**

### **Topological Sorting**

Topological sorting is used to order vertices in a Directed Acyclic Graph (DAG).

**Example:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(vertex1, vertex2) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1].push(vertex2);
        }
    }

    topologicalSort() {
        const stack = [];
        const visited = {};

        const dfs = (vertex) => {
            visited[vertex] = true;
            this.adjacencyList[vertex].forEach(neighbor => {
                if (!visited[neighbor]) {
                    dfs(neighbor);
                }
            });
            stack.push(vertex);
        };

        for (let vertex in this.adjacencyList) {
            if (!visited[vertex]) {
                dfs(vertex);
            }
        }

        return stack.reverse();
    }
}

let graph = new Graph();
graph.addVertex('A');
graph.addVertex('B');
graph.addVertex('C');
graph.addVertex('D');
graph.addVertex('E');
graph.addVertex('F');
graph.addEdge('A', 'D');
graph.addEdge('F', 'B');
graph.addEdge('B', 'D');
graph.addEdge('F', 'A');
graph.addEdge('D', 'C');

console.log(graph.topologicalSort());  // Output: [ 'F', 'E', 'A', 'B', 'D', 'C' ]
```

### **Shortest Path Algorithms**

**Dijkstra's Algorithm:**

**Example:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(vertex1, vertex2, weight) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1].push({ node: vertex2, weight });
            this.adjacencyList[vertex2].push({ node: vertex1, weight });  // Remove this line for directed graphs
        }
    }

    dijkstra(start) {
        const distances = {};
        const priorityQueue = new PriorityQueue();
        const previous = {};
        const path = []; // to return at end
        let smallest;

        // build up initial state
        for (let vertex in this.adjacencyList) {
            if (vertex === start) {
                distances[vertex] = 0;
                priorityQueue.enqueue(vertex, 0);
            } else {
                distances[vertex] = Infinity;
                priorityQueue.enqueue(vertex, Infinity);
            }
            previous[vertex] = null;
        }

        // as long as there is something to visit
        while (priorityQueue.values.length) {
            smallest = priorityQueue.dequeue().val;
            if (smallest === end) {
                // WE ARE DONE
                // BUILD UP PATH TO RETURN AT END
                while (previous[smallest]) {
                    path.push(smallest);
                    smallest = previous[smallest];
                }
                break;
            }
            if (smallest || distances[smallest] !== Infinity) {
                for (let neighbor in this.adjacencyList[smallest]) {
                    // find neighboring node
                    let nextNode = this.adjacencyList[smallest][neighbor];
                    // calculate new distance to neighboring node
                    let candidate = distances[smallest] + nextNode.weight;
                    let nextNeighbor = nextNode.node;
                    if (candidate < distances[nextNeighbor]) {
                        // updating new smallest distance to neighbor
                        distances[nextNeighbor] = candidate;
                        // updating previous - How we got to neighbor
                        previous[nextNeighbor] = smallest;
                        // enqueue in priority queue with new priority
                        priorityQueue.enqueue(nextNeighbor, candidate);
                    }
                }
            }
        }
        return path.concat(smallest).reverse();
    }
}

class PriorityQueue {
    constructor() {
        this.values = [];
    }

    enqueue(val, priority) {
        this.values.push({ val, priority });
        this.sort();
    }

    dequeue() {
        return this.values.shift();
    }

    sort() {
        this.values.sort((a, b) => a.priority - b.priority);
    }
}

let graph = new Graph();
graph.addVertex('A');
graph.addVertex('B');
graph.addVertex('C');
graph.addVertex('D');
graph.addVertex('E');
graph.addVertex('F');

graph.addEdge('A', 'B', 4);
graph.addEdge('A', 'C', 2);
graph.addEdge('B', 'E', 3);
graph.addEdge('C', 'D', 2);
graph.addEdge('C', 'F', 4);
graph.addEdge('D', 'E', 3);
graph.addEdge('D', 'F', 1);
graph.addEdge('E', 'F', 1);

console.log(graph.dijkstra('A', 'E'));  // Output: ['A', 'C', 'D', 'F', 'E']
```

## **Graph Algorithms**

### **Cycle Detection in Directed Graphs**

**Example:**
```javascript
function hasCycle(graph) {
    const visited = new Set();
    const recStack = new Set();

    function dfs(vertex) {
        if (!visited.has(vertex)) {
            visited.add(vertex);
            recStack.add(vertex);

            for (let neighbor of graph[vertex]) {
                if (!visited.has(neighbor) && dfs(neighbor)) {
                    return true;
                } else if (recStack.has(neighbor)) {
                    return true;
                }
            }
        }
        recStack.delete(vertex);
        return false;
    }

    for (let vertex in graph) {
        if (dfs(vertex)) {
            return true;
        }
    }
    return false;
}

let graph = {
    A: ['B'],
    B: ['C'],
    C: ['A']
};

console.log(hasCycle(graph));  // Output: true
```

### **Finding Connected Components**

**Example:**
```javascript
class Graph {
    constructor() {
        this.adjacencyList = {};
    }

    addVertex(vertex) {
        if (!this.adjacencyList[vertex]) {
            this.adjacencyList[vertex] = [];
        }
    }

    addEdge(vertex1, vertex2) {
        if (this.adjacencyList[vertex1] && this.adjacencyList[vertex2]) {
            this.adjacencyList[vertex1].push(vertex2);
            this.adjacencyList[vertex2].push(vertex1);  // Remove this line for directed graphs
        }
    }

    findConnectedComponents() {
        const visited = new Set();
        const components = [];

        const dfs = (vertex, component) => {
            visited.add(vertex);
            component.push(vertex);

            this.adjacencyList[vertex].forEach(neighbor => {
                if (!visited.has(neighbor)) {
                    dfs(neighbor, component);
                }
            });
        };

        for (let vertex in this.adjacencyList) {
            if (!visited.has(vertex)) {
                const component = [];
                dfs(vertex, component);
                components.push(component);
            }
        }

        return components;
    }
}

let graph = new Graph();
graph.addVertex('A');
graph.addVertex('B');
graph.addVertex('C');
graph.addVertex('D');
graph.addVertex('E');

graph.addEdge('A', 'B');
graph.addEdge('A', 'C');
graph.addEdge('D', 'E');

console.log(graph.findConnectedComponents());  // Output: [['A', 'B', 'C'], ['D', 'E']]
```

## **Interview Tips and Tricks**

- **Understand Basic Operations:**
  Be comfortable with implementing addVertex, addEdge, removeVertex, removeEdge, and traversal operations.
- **Practice Common Algorithms:**
  Familiarize yourself with algorithms like cycle detection, topological sorting, shortest path algorithms, and finding connected components.
- **Consider Edge Cases:**
  Always consider edge cases like disconnected graphs, cyclic vs. acyclic graphs, and directed vs. undirected graphs.
- **Optimize Space and Time:**
  Understand how to implement graphs efficiently using adjacency lists and matrices, and the trade-offs involved.

## **Common Mistakes**

- **Incorrect Index Calculations:**
  Be careful with index calculations, especially when working with adjacency matrices.
- **Ignoring Edge Cases:**
  Consider all edge cases, such as operations on empty graphs or graphs with a single node.
- **Cycle Detection:**
  Ensure cycle detection algorithms properly handle directed vs. undirected graphs.

By mastering graphs and understanding their intricacies, you will be well-equipped to handle a variety of interview questions and real-world problems involving networked data structures. Regular practice and a solid grasp of advanced topics will deepen your understanding and improve your problem-solving skills.

## **Practice Problems**

1. [Clone Graph](https://leetcode.com/problems/clone-graph/)
2. [Course Schedule](https://leetcode.com/problems/course-schedule/)
3. [Number of Islands](https://leetcode.com/problems/number-of-islands/)
4. [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)
5. [Word Ladder](https://leetcode.com/problems/word-ladder/)