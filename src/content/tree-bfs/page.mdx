export const metadata = {
  title: 'Comprehensive Guide to Tree BFS in JavaScript',
  description: 'Traverse trees level by level using Breadth-First Search. Understand tree BFS, performance considerations, and practical examples.',
}

# **Tree BFS (Breadth-First Search)**

The Breadth-First Search (BFS) technique is a fundamental algorithm for traversing or searching tree and graph data structures. BFS operates by exploring nodes level by level, starting from the root node and moving to the next level nodes.

## **Concept and Use Cases**

**Definition:** 
BFS is an algorithm for traversing or searching tree or graph data structures. It starts at the root node and explores all the neighbor nodes at the present depth prior to moving on to nodes at the next depth level.

**Common Use Cases:**
- Level-order traversal of a tree.
- Finding the shortest path in an unweighted graph.
- Solving puzzles and games (e.g., finding the shortest path in a maze).

### **Visual Representation:**
Consider a binary tree:
```
    1
   / \
  2   3
 / \
4   5
```
For level-order traversal, the output is `[[1], [2, 3], [4, 5]]`.

## **When to Use**
- When you need to traverse or explore nodes level by level.
- When solving problems that involve searching for the shortest path in an unweighted graph.
- When implementing level-order traversal of a binary tree.

## **Time and Space Complexity**

**Time Complexity:** 
- O(n), where n is the number of nodes in the tree. Each node is visited once.

**Space Complexity:**
- O(n) in the worst case, where n is the number of nodes. This is due to the space required to store the queue.

## **Level-Order Traversal of a Binary Tree**

**Problem:** Given the root of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

### **Step-by-Step Solution:**
1. Use a queue to keep track of nodes at each level.
2. Initialize the queue with the root node.
3. While the queue is not empty, process each node and add its children to the queue.
4. Collect the values of nodes at each level.

### **Code Example:**
```javascript
class TreeNode {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

function levelOrderTraversal(root) {
    if (root === null) return [];

    const result = [];
    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        const currentLevel = [];

        for (let i = 0; i < levelSize; i++) {
            const currentNode = queue.shift();
            currentLevel.push(currentNode.value);

            if (currentNode.left !== null) {
                queue.push(currentNode.left);
            }
            if (currentNode.right !== null) {
                queue.push(currentNode.right);
            }
        }

        result.push(currentLevel);
    }

    return result;
}

// Example usage:
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);
root.right.left = new TreeNode(6);
root.right.right = new TreeNode(7);

console.log(levelOrderTraversal(root));  // Output: [[1], [2, 3], [4, 5, 6, 7]]
```

### **Tips and Tricks:**
- Use a queue to keep track of nodes at each level.
- Collect the values of nodes at each level and add them to the result.
- Ensure to process all nodes at the current level before moving to the next level.

### **Frequent Gotchas:**
- Forgetting to check for an empty tree before starting the traversal.
- Not handling nodes without children correctly, leading to errors.
- Mixing up the order of processing nodes, resulting in incorrect traversal.

## **Finding the Minimum Depth of a Binary Tree**

**Problem:** Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

### **Step-by-Step Solution:**
1. Use a queue to keep track of nodes at each level and their corresponding depths.
2. Initialize the queue with the root node and depth 1.
3. While the queue is not empty, process each node and check if it is a leaf node.
4. If a leaf node is found, return its depth as the minimum depth.

### **Code Example:**
```javascript
function minDepth(root) {
    if (root === null) return 0;

    const queue = [{ node: root, depth: 1 }];

    while (queue.length > 0) {
        const { node, depth } = queue.shift();

        if (node.left === null && node.right === null) {
            return depth;
        }

        if (node.left !== null) {
            queue.push({ node: node.left, depth: depth + 1 });
        }
        if (node.right !== null) {
            queue.push({ node: node.right, depth: depth + 1 });
        }
    }
}

// Example usage:
const root = new TreeNode(1);
root.left = new TreeNode(2);
root.right = new TreeNode(3);
root.left.left = new TreeNode(4);
root.left.right = new TreeNode(5);

console.log(minDepth(root));  // Output: 2
```

### **Tips and Tricks:**
- Use a queue to keep track of nodes and their corresponding depths.
- Return the depth as soon as a leaf node is found to ensure the minimum depth.
- Handle nodes without children correctly to avoid errors.

### **Frequent Gotchas:**
- Forgetting to check for an empty tree before starting the traversal.
- Not updating the depth correctly, leading to incorrect results.
- Handling edge cases, such as trees with only one node.

## **Finding the Largest Value in Each Tree Row**

**Problem:** Given the root of a binary tree, find the largest value in each row of the tree and return them as an array.

### **Step-by-Step Solution:**
1. Use a queue to keep track of nodes at each level.
2. Initialize the queue with the root node.
3. While the queue is not empty, process each node and find the maximum value at each level.
4. Collect the maximum values and return them as the result.

### **Code Example:**
```javascript
function largestValues(root) {
    if (root === null) return [];

    const result = [];
    const queue = [root];

    while (queue.length > 0) {
        const levelSize = queue.length;
        let maxValue = -Infinity;

        for (let i = 0; i < levelSize; i++) {
            const currentNode = queue.shift();
            maxValue = Math.max(maxValue, currentNode.value);

            if (currentNode.left !== null) {
                queue.push(currentNode.left);
            }
            if (currentNode.right !== null) {
                queue.push(currentNode.right);
            }
        }

        result.push(maxValue);
    }

    return result;
}

// Example usage:
const root = new TreeNode(1);
root.left = new TreeNode(3);
root.right = new TreeNode(2);
root.left.left = new TreeNode(5);
root.left.right = new TreeNode(3);
root.right.right = new TreeNode(9);

console.log(largestValues(root));  // Output: [1, 3, 9]
```

### **Tips and Tricks:**
- Use a queue to keep track of nodes at each level.
- Keep track of the maximum value at each level and add it to the result.
- Ensure to process all nodes at the current level before moving to the next level.

### **Frequent Gotchas:**
- Forgetting to check for an empty tree before starting the traversal.
- Not handling nodes without children correctly, leading to errors.
- Mixing up the order of processing nodes, resulting in incorrect traversal.

By mastering the Tree BFS (Breadth-First Search) technique, you can efficiently solve a variety of problems involving level-order traversal, finding minimum depths, and identifying values at each level in trees. This technique is essential for optimizing time complexity and handling tree-related data structures effectively in both technical interviews and real-world applications.