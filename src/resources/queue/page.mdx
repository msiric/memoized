export const metadata = {
  title: 'Comprehensive Guide to JavaScript and TypeScript Queue Implementation',
  description: 'Learn about Queues, a fundamental data structure, and understand their implementation in JavaScript and TypeScript.',
}

# **Queue in JavaScript and TypeScript**

A Queue is a linear data structure that follows the First In First Out (FIFO) principle, where elements are added at the end and removed from the front. This makes it useful for scenarios like task scheduling, breadth-first search algorithms, and buffering.

## **Concept and Use Cases**

**Definition:**
A Queue is a collection of elements that supports two main operations: enqueue (adding an element to the rear) and dequeue (removing an element from the front).

**Common Use Cases:**
- Task scheduling.
- Managing requests in web servers.
- Implementing breadth-first search algorithms.

## **When to Use**
- When you need to manage a collection of items in a FIFO order.
- For applications that require task scheduling.
- When implementing algorithms that need to explore nodes level by level.

## **Time and Space Complexity**

**Time Complexity:**
- Enqueue: O(1)
- Dequeue: O(1)
- Peek: O(1)

**Space Complexity:**
- O(n) for storing n elements.

## **Queue Implementation in JavaScript and TypeScript**

<CodeGroup>

```js
class ListNode {
  constructor(data) {
    this.data = data
    this.next = null
  }
}

class Queue {
  constructor() {
    this.head = null
    this.tail = null
    this.length = 0
  }

  enqueue(element) {
    const newNode = new ListNode(element)
    if (this.tail) {
      this.tail.next = newNode
    } else {
      this.head = newNode
    }
    this.tail = newNode
    this.length++
  }

  dequeue() {
    if (this.head === null) return null
    const dequeuedNode = this.head
    this.head = this.head.next
    if (this.head === null) {
      this.tail = null
    }
    this.length--
    return dequeuedNode.data
  }

  peek() {
    if (this.head === null) return null
    return this.head.data
  }

  isEmpty() {
    return this.length === 0
  }

  size() {
    return this.length
  }

  clear() {
    this.head = null
    this.tail = null
    this.length = 0
  }

  log() {
    const elements = []
    let currentNode = this.head
    while (currentNode) {
      elements.push(currentNode.data)
      currentNode = currentNode.next
    }
    console.log(elements)
  }
}

export { Queue }
```

```ts
class ListNode<T> {
  data: T
  next: ListNode<T> | null

  constructor(data: T) {
    this.data = data
    this.next = null
  }
}

class Queue<T> {
  private head: ListNode<T> | null
  private tail: ListNode<T> | null
  private length: number

  constructor() {
    this.head = null
    this.tail = null
    this.length = 0
  }

  enqueue(element: T): void {
    const newNode = new ListNode(element)
    if (this.tail) {
      this.tail.next = newNode
    } else {
      this.head = newNode
    }
    this.tail = newNode
    this.length++
  }

  dequeue(): T | null {
    if (this.head === null) return null
    const dequeuedNode = this.head
    this.head = this.head.next
    if (this.head === null) {
      this.tail = null
    }
    this.length--
    return dequeuedNode.data
  }

  peek(): T | null {
    if (this.head === null) return null
    return this.head.data
  }

  isEmpty(): boolean {
    return this.length === 0
  }

  size(): number {
    return this.length
  }

  clear(): void {
    this.head = null
    this.tail = null
    this.length = 0
  }

  log(): void {
    const elements: T[] = []
    let currentNode = this.head
    while (currentNode) {
      elements.push(currentNode.data)
      currentNode = currentNode.next
    }
    console.log(elements)
  }
}

export { Queue }
```

</CodeGroup>