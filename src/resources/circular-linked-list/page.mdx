export const metadata = {
  title: 'Comprehensive Guide to JavaScript and TypeScript Circular Linked List Implementation',
  description: 'Learn about Circular Linked Lists, a variation of linked lists, and understand their implementation in JavaScript and TypeScript.',
}

# **Circular Linked List in JavaScript and TypeScript**

A Circular Linked List is a variation of a linked list where the last node points back to the first node, creating a circular structure. This unique structure allows for continuous traversal of the list and has applications in certain types of algorithms and data storage techniques.

## **Concept and Use Cases**

**Definition:**
A Circular Linked List is a linked list where the last node points back to the first node, forming a circle of nodes.

**Common Use Cases:**
- Implementing circular buffers.
- Managing a pool of resources.
- Round-robin scheduling algorithms.

## **When to Use**
- When you need a data structure that allows continuous traversal.
- When implementing algorithms that require a circular structure.
- For applications requiring efficient management of circular data.

## **Time and Space Complexity**

**Time Complexity:**
- Insertion: O(n) for finding the last node, O(1) if the last node is known.
- Deletion: O(n) for finding the node to delete.
- Search: O(n)

**Space Complexity:**
- O(n) for storing n nodes.

## **Circular Linked List Implementation in JavaScript and TypeScript**

<CodeGroup>

```js
class CircularLinkedListNode {
  constructor(data) {
    this.data = data
    this.next = null
  }
}

class CircularLinkedList {
  constructor() {
    this.headNode = null
    this.tailNode = null
    this.length = 0
  }

  size = () => this.length

  head = () => (this.headNode ? this.headNode.data : null)

  isEmpty = () => this.length === 0

  initiateNodeAndIndex() {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

  getElementAt(index) {
    if (index >= 0 && index < this.length) {
      let { currentNode } = this.initiateNodeAndIndex()
      for (let i = 0; i < index && currentNode !== null; i++) {
        currentNode = currentNode.next
      }
      return currentNode
    }
    return null
  }

  addAtFirst(data) {
    const node = new CircularLinkedListNode(data)
    if (!this.headNode) {
      this.headNode = node
      this.tailNode = node
      node.next = this.headNode
    } else {
      node.next = this.headNode
      this.tailNode.next = node
      this.headNode = node
    }
    this.length++
    return this.length
  }

  add(data) {
    if (!this.headNode) {
      return this.addAtFirst(data)
    }
    const node = new CircularLinkedListNode(data)
    this.tailNode.next = node
    node.next = this.headNode
    this.tailNode = node
    this.length++
    return this.length
  }

  insertAt(index, data) {
    if (index === 0) return this.addAtFirst(data)
    if (index === this.length) return this.add(data)
    if (index < 0 || index > this.length) {
      throw new RangeError(`Index is out of range. Max index is ${this.length}`)
    }
    const node = new CircularLinkedListNode(data)
    const previousNode = this.getElementAt(index - 1)
    node.next = previousNode.next
    previousNode.next = node
    this.length++
    return this.length
  }

  indexOf(data) {
    let { currentNode } = this.initiateNodeAndIndex()
    let currentIndex = 0
    while (currentNode) {
      if (currentNode.data === data) {
        return currentIndex
      }
      currentNode = currentNode.next
      currentIndex++
      if (currentNode === this.headNode) break
    }
    return -1
  }

  remove() {
    if (this.isEmpty()) return null
    const lastNode = this.getElementAt(this.length - 2)
    const removedNode = lastNode.next
    lastNode.next = this.headNode
    this.tailNode = lastNode
    this.length--
    if (this.isEmpty()) {
      this.headNode = null
      this.tailNode = null
    }
    return removedNode.data
  }

  removeFirst() {
    if (this.isEmpty()) return null
    const removedNode = this.headNode
    if (this.length === 1) {
      this.clear()
      return removedNode.data
    }
    const lastNode = this.tailNode
    this.headNode = this.headNode.next
    lastNode.next = this.headNode
    this.length--
    return removedNode.data
  }

  removeAt(index) {
    if (index < 0 || index >= this.length) {
      throw new RangeError("Out of Range index")
    }
    if (index === 0) return this.removeFirst()
    if (index === this.length - 1) return this.remove()
    const previousNode = this.getElementAt(index - 1)
    const currentNode = previousNode.next
    previousNode.next = currentNode.next
    this.length--
    return currentNode.data
  }

  removeData(data) {
    const index = this.indexOf(data)
    if (index === -1) {
      return null
    }
    return this.removeAt(index)
  }

  printData(output = value => console.log(value)) {
    let { currentNode, currentIndex } = this.initiateNodeAndIndex()
    while (currentNode !== null && currentIndex < this.length) {
      output(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
  }

  get() {
    const list = []
    let { currentNode, currentIndex } = this.initiateNodeAndIndex()
    while (currentNode !== null && currentIndex < this.length) {
      list.push(currentNode.data)
      currentNode = currentNode.next
      currentIndex++
    }
    return list
  }

  clear() {
    this.headNode = null
    this.tailNode = null
    this.length = 0
  }

  *iterator() {
    let { currentNode, currentIndex } = this.initiateNodeAndIndex()
    while (currentNode !== null && currentIndex < this.length) {
      yield currentNode.data
      currentNode = currentNode.next
      currentIndex++
    }
  }

  [Symbol.iterator]() {
    return this.iterator()
  }
}

export { CircularLinkedListNode, CircularLinkedList }
```

```ts
class CircularLinkedListNode<T> {
  data: T
  next: CircularLinkedListNode<T> | null

  constructor(data: T) {
    this.data = data
    this.next = null
  }
}

class CircularLinkedList<T> {
  headNode: CircularLinkedListNode<T> | null
  tailNode: CircularLinkedListNode<T> | null
  length: number

  constructor() {
    this.headNode = null
    this.tailNode = null
    this.length = 0
  }

  size = (): number => this.length

  head = (): T | null => (this.headNode ? this.headNode.data : null)

  isEmpty = (): boolean => this.length === 0

  private initiateNodeAndIndex() {
    return { currentNode: this.headNode, currentIndex: 0 }
  }

  getElementAt(index: number): CircularLinkedListNode<T> | null {
    if (index >= 0 && index < this.length) {
      let { currentNode } = this.initiateNodeAndIndex()
      for (let i = 0; i < index && currentNode !== null; i++) {
        currentNode = currentNode.next!
      }
      return currentNode
    }
    return null
  }

  addAtFirst(data: T): number {
    const node = new CircularLinkedListNode(data)
    if (!this.headNode) {
      this.headNode = node
      this.tailNode = node
      node.next = this.headNode
    } else {
      node.next = this.headNode
      this.tailNode!.next = node
      this.headNode = node
    }
    this.length++
    return this.length
  }

  add(data: T): number {
    if (!this.headNode) {
      return this.addAtFirst(data)
    }
    const node = new CircularLinkedListNode(data)
    this.tailNode!.next = node
    node.next = this.headNode
    this.tailNode = node
    this.length++
    return this.length
  }

  insertAt(index: number, data: T): number {
    if (index === 0) return this.addAtFirst(data)
    if (index === this.length) return this.add(data)
    if (index < 0 || index > this.length) {
      throw new RangeError(`Index is out of range. Max index is ${this.length}`)
    }
    const node = new CircularLinkedListNode(data)
    const previousNode = this.getElementAt(index - 1)!
    node.next = previousNode.next
    previousNode.next = node
    this.length++
    return this.length
  }

  indexOf(data: T): number {
    let { currentNode } = this.initiateNodeAndIndex()
    let currentIndex = 0
    while (currentNode) {
      if (currentNode.data === data) {
        return currentIndex
      }
      currentNode = currentNode.next!
      currentIndex++
      if (currentNode === this.headNode) break
    }
    return -1
  }

  remove(): T | null {
    if (this.isEmpty()) return null
    const lastNode = this.getElementAt(this.length - 2)!
    const removedNode = lastNode.next!
    lastNode.next = this.headNode
    this.tailNode = lastNode
    this.length--
    if (this.isEmpty()) {
      this.headNode = null
      this.tailNode = null
    }
    return removedNode.data
  }

  removeFirst(): T | null {
    if (this.isEmpty()) return null
    const removedNode = this.headNode!
    if (this.length === 1) {
      this.clear()
      return removedNode.data
    }
    const lastNode = this.tailNode!
    this.headNode = this.headNode!.next!
    lastNode.next = this.headNode
    this.length--
    return removedNode.data
  }

  removeAt(index: number): T | null {
    if (index < 0 || index >= this.length) {
      throw new RangeError('Out of Range index')
    }
    if (index === 0) return this.removeFirst()
    if (index === this.length - 1) return this.remove()
    const previousNode = this.getElementAt(index - 1)!
    const currentNode = previousNode.next!
    previousNode.next = currentNode.next
    this.length--
    return currentNode.data
  }

  removeData(data: T): T | null {
    const index = this.indexOf(data)
    if (index === -1) {
      return null
    }
    return this.removeAt(index)
  }

  printData(output = (value: T) => console.log(value)) {
    let { currentNode, currentIndex } = this.initiateNodeAndIndex()
    while (currentNode !== null && currentIndex < this.length) {
      output(currentNode.data)
      currentNode = currentNode.next!
      currentIndex++
    }
  }

  get(): T[] {
    const list: T[] = []
    let { currentNode, currentIndex } = this.initiateNodeAndIndex()
    while (currentNode !== null && currentIndex < this.length) {
      list.push(currentNode.data)
      currentNode = currentNode.next!
      currentIndex++
    }
    return list
  }

  clear() {
    this.headNode = null
    this.tailNode = null
    this.length = 0
  }

  *iterator() {
    let { currentNode, currentIndex } = this.initiateNodeAndIndex()
    while (currentNode !== null && currentIndex < this.length) {
      yield currentNode.data
      currentNode = currentNode.next!
      currentIndex++
    }
  }

  [Symbol.iterator]() {
    return this.iterator()
  }
}

export { CircularLinkedListNode, CircularLinkedList }
```

</CodeGroup>