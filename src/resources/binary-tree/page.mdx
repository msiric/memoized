export const metadata = {
  title:
    'Comprehensive Guide to JavaScript and TypeScript Binary Tree Implementation',
  description:
    'Learn about Binary Trees, a fundamental data structure, and understand their implementation in JavaScript and TypeScript.',
}

# **Binary Tree in JavaScript and TypeScript**

A Binary Tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. Binary trees are the foundation for various data structures and algorithms in computer science, such as binary search trees and heaps.

## **Concept and Use Cases**

**Definition:**
A Binary Tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.

**Common Use Cases:**
- Representing hierarchical data.
- Implementing binary search trees.
- Implementing heaps for priority queues.

## **When to Use**
- When you need a simple hierarchical data structure.
- When implementing other data structures like binary search trees or heaps.
- For applications requiring tree traversals, such as expression trees.

## **Time and Space Complexity**

**Time Complexity:**
- Insertion: O(n) in the worst case.
- Deletion: O(n) in the worst case.
- Search: O(n) in the worst case.

**Space Complexity:**
- O(n) for storing n nodes.

## **Binary Tree Implementation in JavaScript and TypeScript**

<CodeGroup>

```js
class TreeNode {
  constructor(data) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree {
  constructor() {
    this.root = null
  }

  insert(data) {
    const newNode = new TreeNode(data)
    if (this.root === null) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }
  }

  insertNode(node, newNode) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode
      } else {
        this.insertNode(node.left, newNode)
      }
    } else {
      if (node.right === null) {
        node.right = newNode
      } else {
        this.insertNode(node.right, newNode)
      }
    }
  }

  inorderTraversal(node, result = []) {
    if (node !== null) {
      this.inorderTraversal(node.left, result)
      result.push(node.data)
      this.inorderTraversal(node.right, result)
    }
    return result
  }

  preorderTraversal(node, result = []) {
    if (node !== null) {
      result.push(node.data)
      this.preorderTraversal(node.left, result)
      this.preorderTraversal(node.right, result)
    }
    return result
  }

  postorderTraversal(node, result = []) {
    if (node !== null) {
      this.postorderTraversal(node.left, result)
      this.postorderTraversal(node.right, result)
      result.push(node.data)
    }
    return result
  }

  breadthFirstTraversal() {
    const result = []
    const queue = []
    if (this.root) {
      queue.push(this.root)
    }

    while (queue.length > 0) {
      const node = queue.shift()
      if (node) {
        result.push(node.data)
        if (node.left) queue.push(node.left)
        if (node.right) queue.push(node.right)
      }
    }
    return result
  }

  search(node, data) {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      return this.search(node.left, data)
    } else if (data > node.data) {
      return this.search(node.right, data)
    } else {
      return node
    }
  }

  remove(data) {
    this.root = this.removeNode(this.root, data)
  }

  removeNode(node, key) {
    if (node === null) {
      return null
    }
    if (key < node.data) {
      node.left = this.removeNode(node.left, key)
      return node
    } else if (key > node.data) {
      node.right = this.removeNode(node.right, key)
      return node
    } else {
      if (node.left === null && node.right === null) {
        node = null
        return node
      }
      if (node.left === null) {
        node = node.right
        return node
      } else if (node.right === null) {
        node = node.left
        return node
      }

      const aux = this.findMinNode(node.right)
      node.data = aux.data
      node.right = this.removeNode(node.right, aux.data)
      return node
    }
  }

  findMinNode(node) {
    if (node.left === null) {
      return node
    } else {
      return this.findMinNode(node.left)
    }
  }

  findMax() {
    if (this.root === null) {
      return null
    }
    let node = this.root
    while (node.right !== null) {
      node = node.right
    }
    return node.data
  }

  findMin() {
    if (this.root === null) {
      return null
    }
    let node = this.root
    while (node.left !== null) {
      node = node.left
    }
    return node.data
  }

  height(node = this.root) {
    if (node === null) {
      return -1
    }
    const leftHeight = this.height(node.left)
    const rightHeight = this.height(node.right)
    return Math.max(leftHeight, rightHeight) + 1
  }

  clear() {
    this.root = null
  }
}

export { BinaryTree, TreeNode }
```

```ts
class TreeNode<T> {
  data: T
  left: TreeNode<T> | null
  right: TreeNode<T> | null

  constructor(data: T) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree<T> {
  root: TreeNode<T> | null

  constructor() {
    this.root = null
  }

  insert(data: T) {
    const newNode = new TreeNode(data)
    if (this.root === null) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }
  }

  private insertNode(node: TreeNode<T>, newNode: TreeNode<T>) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode
      } else {
        this.insertNode(node.left, newNode)
      }
    } else {
      if (node.right === null) {
        node.right = newNode
      } else {
        this.insertNode(node.right, newNode)
      }
    }
  }

  inorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      this.inorderTraversal(node.left, result)
      result.push(node.data)
      this.inorderTraversal(node.right, result)
    }
    return result
  }

  preorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      result.push(node.data)
      this.preorderTraversal(node.left, result)
      this.preorderTraversal(node.right, result)
    }
    return result
  }

  postorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      this.postorderTraversal(node.left, result)
      this.postorderTraversal(node.right, result)
      result.push(node.data)
    }
    return result
  }

  breadthFirstTraversal(): T[] {
    const result: T[] = []
    const queue: Array<TreeNode<T> | null> = []
    if (this.root) {
      queue.push(this.root)
    }

    while (queue.length > 0) {
      const node = queue.shift()
      if (node) {
        result.push(node.data)
        if (node.left) queue.push(node.left)
        if (node.right) queue.push(node.right)
      }
    }
    return result
  }

  search(node: TreeNode<T> | null, data: T): TreeNode<T> | null {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      return this.search(node.left, data)
    } else if (data > node.data) {
      return this.search(node.right, data)
    } else {
      return node
    }
  }

  remove(data: T) {
    this.root = this.removeNode(this.root, data)
  }

  private removeNode(node: TreeNode<T> | null, key: T): TreeNode<T> | null {
    if (node === null) {
      return null
    }
    if (key < node.data) {
      node.left = this.removeNode(node.left, key)
      return node
    } else if (key > node.data) {
      node.right = this.removeNode(node.right, key)
      return node
    } else {
      if (node.left === null && node.right === null) {
        node = null
        return node
      }
      if (node.left === null) {
        node = node.right
        return node
      } else if (node.right === null) {
        node = node.left
        return node
      }

      const aux = this.findMinNode(node.right)
      node.data = aux!.data
      node.right = this.removeNode(node.right, aux!.data)
      return node
    }
  }

  private findMinNode(node: TreeNode<T>): TreeNode<T> | null {
    if (node.left === null) {
      return node
    } else {
      return this.findMinNode(node.left)
    }
  }

  findMax(): T | null {
    if (this.root === null) {
      return null
    }
    let node = this.root
    while (node.right !== null) {
      node = node.right
    }
    return node.data
  }

  findMin(): T | null {
    if (this.root === null) {
      return null
    }
    let node = this.root
    while (node.left !== null) {
      node = node.left
    }
    return node.data
  }

  height(node: TreeNode<T> | null = this.root): number {
    if (node === null) {
      return -1
    }
    const leftHeight = this.height(node.left)
    const rightHeight = this.height(node.right)
    return Math.max(leftHeight, rightHeight) + 1
  }

  clear() {
    this.root = null
  }
}

export { BinaryTree, TreeNode }
```

</CodeGroup>