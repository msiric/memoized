export const metadata = {
  title: 'Comprehensive Guide to JavaScript and TypeScript Binary Tree Implementation',
  description: 'Learn about Binary Trees, a fundamental data structure, and understand their implementation in JavaScript and TypeScript.',
}

# **Binary Tree in JavaScript and TypeScript**

A Binary Tree is a hierarchical data structure in which each node has at most two children, referred to as the left child and the right child. Binary trees are the foundation for various data structures and algorithms in computer science, such as binary search trees and heaps.

## **Concept and Use Cases**

**Definition:**
A Binary Tree is a tree data structure in which each node has at most two children, referred to as the left child and the right child.

**Common Use Cases:**
- Representing hierarchical data.
- Implementing binary search trees.
- Implementing heaps for priority queues.

## **When to Use**
- When you need a simple hierarchical data structure.
- When implementing other data structures like binary search trees or heaps.
- For applications requiring tree traversals, such as expression trees.

## **Time and Space Complexity**

**Time Complexity:**
- Insertion: O(n) in the worst case.
- Deletion: O(n) in the worst case.
- Search: O(n) in the worst case.

**Space Complexity:**
- O(n) for storing n nodes.

## **Binary Tree Implementation in JavaScript and TypeScript**

<CodeGroup>

```js
class TreeNode {
  constructor(data) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree {
  constructor() {
    this.root = null
  }

  // Insert a node in the binary tree
  insert(data) {
    const newNode = new TreeNode(data)
    if (this.root === null) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }
  }

  insertNode(node, newNode) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode
      } else {
        this.insertNode(node.left, newNode)
      }
    } else {
      if (node.right === null) {
        node.right = newNode
      } else {
        this.insertNode(node.right, newNode)
      }
    }
  }

  // In-order traversal
  inorderTraversal(node, result = []) {
    if (node !== null) {
      this.inorderTraversal(node.left, result)
      result.push(node.data)
      this.inorderTraversal(node.right, result)
    }
    return result
  }

  // Pre-order traversal
  preorderTraversal(node, result = []) {
    if (node !== null) {
      result.push(node.data)
      this.preorderTraversal(node.left, result)
      this.preorderTraversal(node.right, result)
    }
    return result
  }

  // Post-order traversal
  postorderTraversal(node, result = []) {
    if (node !== null) {
      this.postorderTraversal(node.left, result)
      this.postorderTraversal(node.right, result)
      result.push(node.data)
    }
    return result
  }

  // Search for a node in the binary tree
  search(node, data) {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      return this.search(node.left, data)
    } else if (data > node.data) {
      return this.search(node.right, data)
    } else {
      return node
    }
  }
}

export { BinaryTree, TreeNode }
```

```ts
class TreeNode<T> {
  data: T
  left: TreeNode<T> | null
  right: TreeNode<T> | null

  constructor(data: T) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinaryTree<T> {
  root: TreeNode<T> | null

  constructor() {
    this.root = null
  }

  // Insert a node in the binary tree
  insert(data: T) {
    const newNode = new TreeNode(data)
    if (this.root === null) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }
  }

  private insertNode(node: TreeNode<T>, newNode: TreeNode<T>) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode
      } else {
        this.insertNode(node.left, newNode)
      }
    } else {
      if (node.right === null) {
        node.right = newNode
      } else {
        this.insertNode(node.right, newNode)
      }
    }
  }

  // In-order traversal
  inorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      this.inorderTraversal(node.left, result)
      result.push(node.data)
      this.inorderTraversal(node.right, result)
    }
    return result
  }

  // Pre-order traversal
  preorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      result.push(node.data)
      this.preorderTraversal(node.left, result)
      this.preorderTraversal(node.right, result)
    }
    return result
  }

  // Post-order traversal
  postorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      this.postorderTraversal(node.left, result)
      this.postorderTraversal(node.right, result)
      result.push(node.data)
    }
    return result
  }

  // Search for a node in the binary tree
  search(node: TreeNode<T> | null, data: T): TreeNode<T> | null {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      return this.search(node.left, data)
    } else if (data > node.data) {
      return this.search(node.right, data)
    } else {
      return node
    }
  }
}

export { BinaryTree, TreeNode }
```

</CodeGroup>