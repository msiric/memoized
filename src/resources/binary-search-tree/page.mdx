export const metadata = {
  title: 'Comprehensive Guide to JavaScript and TypeScript Binary Search Tree Implementation',
  description: 'Learn about Binary Search Trees (BST), a fundamental data structure, and understand their implementation in JavaScript and TypeScript.',
}

# **Binary Search Tree in JavaScript and TypeScript**

A Binary Search Tree (BST) is a node-based binary tree data structure in which each node has at most two children, referred to as the left child and the right child. For each node, the left subtree contains only nodes with values less than the node’s value, and the right subtree contains only nodes with values greater than the node’s value.

## **Concept and Use Cases**

**Definition:**
A Binary Search Tree is a binary tree where each node has a maximum of two children. It maintains the property that the left child is less than the parent node, and the right child is greater than the parent node.

**Common Use Cases:**
- Implementing dynamic sets and lookup tables.
- Searching for elements in logarithmic time.
- Inorder traversal to get elements in sorted order.

## **When to Use**
- When you need to maintain a dynamic dataset that supports fast search, insertion, and deletion operations.
- When you need an ordered traversal of elements.
- For applications where balanced binary search trees are not necessary.

## **Time and Space Complexity**

**Time Complexity:**
- Insertion: O(h) where h is the height of the tree.
- Deletion: O(h)
- Search: O(h)

**Space Complexity:**
- O(n) for storing n nodes.

## **Binary Search Tree Implementation in JavaScript and TypeScript**

<CodeGroup>

```js
class TreeNode {
  constructor(data) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinarySearchTree {
  constructor() {
    this.root = null
  }

  // Insert a node in the BST
  insert(data) {
    const newNode = new TreeNode(data)
    if (this.root === null) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }
  }

  insertNode(node, newNode) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode
      } else {
        this.insertNode(node.left, newNode)
      }
    } else {
      if (node.right === null) {
        node.right = newNode
      } else {
        this.insertNode(node.right, newNode)
      }
    }
  }

  // In-order traversal
  inorderTraversal(node, result = []) {
    if (node !== null) {
      this.inorderTraversal(node.left, result)
      result.push(node.data)
      this.inorderTraversal(node.right, result)
    }
    return result
  }

  // Pre-order traversal
  preorderTraversal(node, result = []) {
    if (node !== null) {
      result.push(node.data)
      this.preorderTraversal(node.left, result)
      this.preorderTraversal(node.right, result)
    }
    return result
  }

  // Post-order traversal
  postorderTraversal(node, result = []) {
    if (node !== null) {
      this.postorderTraversal(node.left, result)
      this.postorderTraversal(node.right, result)
      result.push(node.data)
    }
    return result
  }

  // Search for a node in the BST
  search(node, data) {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      return this.search(node.left, data)
    } else if (data > node.data) {
      return this.search(node.right, data)
    } else {
      return node
    }
  }

  // Find the minimum node in the BST
  findMinNode(node) {
    if (node.left === null) {
      return node
    } else {
      return this.findMinNode(node.left)
    }
  }

  // Remove a node in the BST
  remove(data) {
    this.root = this.removeNode(this.root, data)
  }

  removeNode(node, data) {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      node.left = this.removeNode(node.left, data)
      return node
    } else if (data > node.data) {
      node.right = this.removeNode(node.right, data)
      return node
    } else {
      // Node with only one child or no child
      if (node.left === null && node.right === null) {
        node = null
        return node
      }
      if (node.left === null) {
        node = node.right
        return node
      } else if (node.right === null) {
        node = node.left
        return node
      }

      // Node with two children: Get the inorder successor (smallest in the right subtree)
      const tempNode = this.findMinNode(node.right)
      node.data = tempNode.data
      node.right = this.removeNode(node.right, tempNode.data)
      return node
    }
  }
}

export { BinarySearchTree, TreeNode }
```

```ts
class TreeNode<T> {
  data: T
  left: TreeNode<T> | null
  right: TreeNode<T> | null

  constructor(data: T) {
    this.data = data
    this.left = null
    this.right = null
  }
}

class BinarySearchTree<T> {
  root: TreeNode<T> | null

  constructor() {
    this.root = null
  }

  // Insert a node in the BST
  insert(data: T) {
    const newNode = new TreeNode(data)
    if (this.root === null) {
      this.root = newNode
    } else {
      this.insertNode(this.root, newNode)
    }
  }

  private insertNode(node: TreeNode<T>, newNode: TreeNode<T>) {
    if (newNode.data < node.data) {
      if (node.left === null) {
        node.left = newNode
      } else {
        this.insertNode(node.left, newNode)
      }
    } else {
      if (node.right === null) {
        node.right = newNode
      } else {
        this.insertNode(node.right, newNode)
      }
    }
  }

  // In-order traversal
  inorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      this.inorderTraversal(node.left, result)
      result.push(node.data)
      this.inorderTraversal(node.right, result)
    }
    return result
  }

  // Pre-order traversal
  preorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      result.push(node.data)
      this.preorderTraversal(node.left, result)
      this.preorderTraversal(node.right, result)
    }
    return result
  }

  // Post-order traversal
  postorderTraversal(node: TreeNode<T> | null, result: T[] = []): T[] {
    if (node !== null) {
      this.postorderTraversal(node.left, result)
      this.postorderTraversal(node.right, result)
      result.push(node.data)
    }
    return result
  }

  // Search for a node in the BST
  search(node: TreeNode<T> | null, data: T): TreeNode<T> | null {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      return this.search(node.left, data)
    } else if (data > node.data) {
      return this.search(node.right, data)
    } else {
      return node
    }
  }

  // Find the minimum node in the BST
  findMinNode(node: TreeNode<T>): TreeNode<T> | null {
    if (node.left === null) {
      return node
    } else {
      return this.findMinNode(node.left)
    }
  }

  // Remove a node in the BST
  remove(data: T) {
    this.root = this.removeNode(this.root, data)
  }

  private removeNode(node: TreeNode<T> | null, data: T): TreeNode<T> | null {
    if (node === null) {
      return null
    }
    if (data < node.data) {
      node.left = this.removeNode(node.left, data)
      return node
    } else if (data > node.data) {
      node.right = this.removeNode(node.right, data)
      return node
    } else {
      // Node with only one child or no child
      if (node.left === null && node.right === null) {
        node = null
        return node
      }
      if (node.left === null) {
        node = node.right
        return node
      } else if (node.right === null) {
        node = node.left
        return node
      }

      // Node with two children: Get the inorder successor (smallest in the right subtree)
      const tempNode = this.findMinNode(node.right)
      node.data = tempNode!.data
      node.right = this.removeNode(node.right, tempNode!.data)
      return node
    }
  }
}

export { BinarySearchTree, TreeNode }
```

</CodeGroup>