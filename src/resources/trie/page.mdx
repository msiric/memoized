export const metadata = {
  title: 'Comprehensive Guide to JavaScript and TypeScript Trie Implementation',
  description: 'Learn about Tries, a fundamental data structure, and understand their implementation in JavaScript and TypeScript.',
}

# **Trie in JavaScript and TypeScript**

A Trie is a tree-like data structure that stores a dynamic set of strings, where the keys are usually strings. Tries are commonly used for storing a predictive text or autocomplete dictionary.

## **Concept and Use Cases**

**Definition:**
A Trie, also known as a prefix tree, is a type of search tree used to store associative data structures. A Trie is used to store strings where each node represents a single character of a string.

**Common Use Cases:**
- Autocomplete systems.
- Spell checkers.
- IP routing (longest prefix matching).

## **When to Use**
- When you need to quickly search for a prefix or whole words.
- For implementing efficient autocomplete systems.
- When managing a large dataset of strings.

## **Time and Space Complexity**

**Time Complexity:**
- Insertion: O(m) where m is the length of the key.
- Deletion: O(m) where m is the length of the key.
- Search: O(m) where m is the length of the key.

**Space Complexity:**
- O(n * m) where n is the number of keys and m is the average key length.

## **Trie Implementation in JavaScript and TypeScript**

<CodeGroup>

```js
class TrieNode {
  constructor(key, parent) {
    this.key = key
    this.count = 0
    this.children = Object.create(null)
    this.parent = parent || null
  }
}

class Trie {
  constructor() {
    this.root = new TrieNode(null, null)
  }

  // Recursively finds the occurrence of all words in a given node
  static findAllWords(root, word, output) {
    if (root === null) return
    if (root.count > 0) {
      output.push({ word, count: root.count })
    }
    for (const key in root.children) {
      Trie.findAllWords(root.children[key], word + key, output)
    }
  }

  insert(word) {
    if (typeof word !== "string") return
    if (word === "") {
      this.root.count += 1
      return
    }
    let node = this.root
    for (const char of word.toLowerCase()) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode(char, node)
      }
      node = node.children[char]
    }
    node.count += 1
  }

  findPrefix(prefix) {
    if (typeof prefix !== "string") return null
    let node = this.root
    for (const char of prefix.toLowerCase()) {
      if (!node.children[char]) return null
      node = node.children[char]
    }
    return node
  }

  remove(word, count = 1) {
    if (typeof word !== "string" || count <= 0) return
    if (word === "") {
      this.root.count = Math.max(0, this.root.count - count)
      return
    }
    let node = this.root
    for (const char of word.toLowerCase()) {
      if (!node.children[char]) return
      node = node.children[char]
    }
    node.count = Math.max(0, node.count - count)
    if (node.count === 0 && Object.keys(node.children).length === 0) {
      let parent = node.parent
      while (parent) {
        delete parent.children[node.key]
        if (Object.keys(parent.children).length > 0 || parent.count > 0) break
        node = parent
        parent = parent.parent
      }
    }
  }

  findAllWords(prefix) {
    const output = []
    const node = this.findPrefix(prefix)
    if (node === null) return output
    Trie.findAllWords(node, prefix.toLowerCase(), output)
    return output
  }

  contains(word) {
    const node = this.findPrefix(word.toLowerCase())
    return node !== null && node.count > 0
  }

  findOccurrences(word) {
    const node = this.findPrefix(word.toLowerCase())
    return node ? node.count : 0
  }

  // Serialize the Trie to a JSON string
  serialize() {
    return JSON.stringify(this.root, (key, value) =>
      key === "parent" ? undefined : value
    )
  }

  // Deserialize a JSON string to a Trie
  static deserialize(data) {
    const trie = new Trie()
    trie.root = JSON.parse(data)
    trie.relinkParents(trie.root)
    return trie
  }

  // Helper method to relink parent nodes after deserialization
  relinkParents(node) {
    for (const childKey in node.children) {
      node.children[childKey].parent = node
      this.relinkParents(node.children[childKey])
    }
  }

  // Get all words stored in the Trie
  getAllWords() {
    const output = []
    Trie.findAllWords(this.root, "", output)
    return output.sort((a, b) => a.word.localeCompare(b.word))
  }
}

export { Trie }
```

```ts
class TrieNode {
  key: string | null
  count: number
  children: Record<string, TrieNode>
  parent: TrieNode | null

  constructor(key: string | null, parent: TrieNode | null) {
    this.key = key
    this.count = 0
    this.children = Object.create(null)
    this.parent = parent || null
  }
}

class Trie {
  root: TrieNode

  constructor() {
    this.root = new TrieNode(null, null)
  }

  // Recursively finds the occurrence of all words in a given node
  static findAllWords(
    root: TrieNode,
    word: string,
    output: Array<{ word: string; count: number }>,
  ) {
    if (root === null) return
    if (root.count > 0) {
      output.push({ word, count: root.count })
    }
    for (const key in root.children) {
      Trie.findAllWords(root.children[key], word + key, output)
    }
  }

  insert(word: string) {
    if (typeof word !== 'string') return
    if (word === '') {
      this.root.count += 1
      return
    }
    let node = this.root
    for (const char of word.toLowerCase()) {
      if (!node.children[char]) {
        node.children[char] = new TrieNode(char, node)
      }
      node = node.children[char]
    }
    node.count += 1
  }

  findPrefix(prefix: string): TrieNode | null {
    if (typeof prefix !== 'string') return null
    let node = this.root
    for (const char of prefix.toLowerCase()) {
      if (!node.children[char]) return null
      node = node.children[char]
    }
    return node
  }

  remove(word: string, count: number = 1) {
    if (typeof word !== 'string' || count <= 0) return
    if (word === '') {
      this.root.count = Math.max(0, this.root.count - count)
      return
    }
    let node = this.root
    for (const char of word.toLowerCase()) {
      if (!node.children[char]) return
      node = node.children[char]
    }
    node.count = Math.max(0, node.count - count)
    if (node.count === 0 && Object.keys(node.children).length === 0) {
      let parent = node.parent
      while (parent) {
        delete parent.children[node.key!]
        if (Object.keys(parent.children).length > 0 || parent.count > 0) break
        node = parent
        parent = parent.parent
      }
    }
  }

  findAllWords(prefix: string): Array<{ word: string; count: number }> {
    const output: Array<{ word: string; count: number }> = []
    const node = this.findPrefix(prefix)
    if (node === null) return output
    Trie.findAllWords(node, prefix.toLowerCase(), output)
    return output
  }

  contains(word: string): boolean {
    const node = this.findPrefix(word.toLowerCase())
    return node !== null && node.count > 0
  }

  findOccurrences(word: string): number {
    const node = this.findPrefix(word.toLowerCase())
    return node ? node.count : 0
  }

  // Serialize the Trie to a JSON string
  serialize(): string {
    return JSON.stringify(this.root, (key, value) =>
      key === 'parent' ? undefined : value,
    )
  }

  // Deserialize a JSON string to a Trie
  static deserialize(data: string): Trie {
    const trie = new Trie()
    trie.root = JSON.parse(data)
    trie.relinkParents(trie.root)
    return trie
  }

  // Helper method to relink parent nodes after deserialization
  private relinkParents(node: TrieNode) {
    for (const childKey in node.children) {
      node.children[childKey].parent = node
      this.relinkParents(node.children[childKey])
    }
  }

  // Get all words stored in the Trie
  getAllWords(): Array<{ word: string; count: number }> {
    const output: Array<{ word: string; count: number }> = []
    Trie.findAllWords(this.root, '', output)
    return output.sort((a, b) => a.word.localeCompare(b.word))
  }
}

export { Trie }
```

</CodeGroup>