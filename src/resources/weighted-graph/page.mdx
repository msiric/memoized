export const metadata = {
  title: 'Comprehensive Guide to JavaScript and TypeScript Weighted Graph Implementation',
  description: 'Learn about Weighted Graphs, a fundamental data structure, and understand their implementation in JavaScript and TypeScript.',
}

# **Weighted Graph in JavaScript and TypeScript**

A Weighted Graph is a type of graph in which each edge has an associated numerical value, called a weight. This data structure is essential for applications where different paths have different costs or lengths.

## **Concept and Use Cases**

**Definition:**
A Weighted Graph is a collection of vertices connected by edges, each of which has a numerical weight.

**Common Use Cases:**
- Finding the shortest path in navigation systems.
- Network routing algorithms.
- Optimizing resource allocation.

## **When to Use**
- When you need to model relationships with different weights or costs.
- For applications like navigation, network routing, and resource optimization.
- When implementing algorithms like Dijkstra's or Prim's for shortest paths or minimum spanning trees.

## **Time and Space Complexity**

**Time Complexity:**
- Add Vertex: O(1)
- Add Edge: O(1)
- Remove Vertex: O(V + E) where V is the number of vertices and E is the number of edges.
- Remove Edge: O(1)
- Search: O(V + E)

**Space Complexity:**
- O(V + E) for storing V vertices and E edges with weights.

## **Weighted Graph Implementation in JavaScript and TypeScript**

<CodeGroup>

```js
class WeightedGraph {
  constructor() {
    this.adjacencyList = new Map()
  }

  addVertex(vertex) {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, new Map())
    }
  }

  addEdge(vertex1, vertex2, weight) {
    if (!this.adjacencyList.has(vertex1)) {
      this.addVertex(vertex1)
    }
    if (!this.adjacencyList.has(vertex2)) {
      this.addVertex(vertex2)
    }
    this.adjacencyList.get(vertex1).set(vertex2, weight)
    this.adjacencyList.get(vertex2).set(vertex1, weight) // For undirected graph
  }

  removeEdge(vertex1, vertex2) {
    this.adjacencyList.get(vertex1)?.delete(vertex2)
    this.adjacencyList.get(vertex2)?.delete(vertex1)
  }

  removeVertex(vertex) {
    if (this.adjacencyList.has(vertex)) {
      this.adjacencyList.delete(vertex)
      for (const neighbors of this.adjacencyList.values()) {
        neighbors.delete(vertex)
      }
    }
  }

  getVertices() {
    return Array.from(this.adjacencyList.keys())
  }

  getNeighbors(vertex) {
    return Array.from(
      this.adjacencyList.get(vertex) ?? []
    ).map(([neighbor, weight]) => [neighbor, weight])
  }

  getEdgeWeight(vertex1, vertex2) {
    return this.adjacencyList.get(vertex1)?.get(vertex2)
  }

  bfs(startVertex) {
    const visited = new Set()
    const queue = [startVertex]
    const result = []

    while (queue.length > 0) {
      const vertex = queue.shift()
      if (!visited.has(vertex)) {
        visited.add(vertex)
        result.push(vertex)
        queue.push(
          ...this.getNeighbors(vertex)
            .map(([neighbor]) => neighbor)
            .filter(neighbor => !visited.has(neighbor))
        )
      }
    }

    return result
  }

  dfs(startVertex) {
    const visited = new Set()
    const stack = [startVertex]
    const result = []

    while (stack.length > 0) {
      const vertex = stack.pop()
      if (!visited.has(vertex)) {
        visited.add(vertex)
        result.push(vertex)
        stack.push(
          ...this.getNeighbors(vertex)
            .map(([neighbor]) => neighbor)
            .filter(neighbor => !visited.has(neighbor))
        )
      }
    }

    return result
  }

  dijkstra(startVertex, endVertex) {
    const distances = new Map()
    const previous = new Map()
    const pq = []

    distances.set(startVertex, 0)
    this.getVertices().forEach(vertex => {
      if (vertex !== startVertex) {
        distances.set(vertex, Infinity)
      }
      previous.set(vertex, null)
    })

    pq.push([0, startVertex])

    while (pq.length > 0) {
      pq.sort((a, b) => a[0] - b[0])
      const [currentDistance, currentVertex] = pq.shift()

      if (currentVertex === endVertex) {
        const path = []
        let vertex = endVertex
        while (vertex !== null) {
          path.push(vertex)
          vertex = previous.get(vertex) ?? null
        }
        return { distance: currentDistance, path: path.reverse() }
      }

      if (currentDistance > distances.get(currentVertex)) {
        continue
      }

      for (const [neighbor, weight] of this.getNeighbors(currentVertex)) {
        const distance = currentDistance + weight
        if (distance < distances.get(neighbor)) {
          distances.set(neighbor, distance)
          previous.set(neighbor, currentVertex)
          pq.push([distance, neighbor])
        }
      }
    }

    return null
  }

  clear() {
    this.adjacencyList.clear()
  }
}

export { WeightedGraph }
```

```ts
class WeightedGraph<T> {
  private adjacencyList: Map<T, Map<T, number>>

  constructor() {
    this.adjacencyList = new Map<T, Map<T, number>>()
  }

  addVertex(vertex: T): void {
    if (!this.adjacencyList.has(vertex)) {
      this.adjacencyList.set(vertex, new Map<T, number>())
    }
  }

  addEdge(vertex1: T, vertex2: T, weight: number): void {
    if (!this.adjacencyList.has(vertex1)) {
      this.addVertex(vertex1)
    }
    if (!this.adjacencyList.has(vertex2)) {
      this.addVertex(vertex2)
    }
    this.adjacencyList.get(vertex1)!.set(vertex2, weight)
    this.adjacencyList.get(vertex2)!.set(vertex1, weight) // For undirected graph
  }

  removeEdge(vertex1: T, vertex2: T): void {
    this.adjacencyList.get(vertex1)?.delete(vertex2)
    this.adjacencyList.get(vertex2)?.delete(vertex1)
  }

  removeVertex(vertex: T): void {
    if (this.adjacencyList.has(vertex)) {
      this.adjacencyList.delete(vertex)
      for (const neighbors of this.adjacencyList.values()) {
        neighbors.delete(vertex)
      }
    }
  }

  getVertices(): T[] {
    return Array.from(this.adjacencyList.keys())
  }

  getNeighbors(vertex: T): [T, number][] {
    return Array.from(this.adjacencyList.get(vertex) ?? []).map(
      ([neighbor, weight]) => [neighbor, weight],
    )
  }

  getEdgeWeight(vertex1: T, vertex2: T): number | undefined {
    return this.adjacencyList.get(vertex1)?.get(vertex2)
  }

  bfs(startVertex: T): T[] {
    const visited = new Set<T>()
    const queue: T[] = [startVertex]
    const result: T[] = []

    while (queue.length > 0) {
      const vertex = queue.shift()!
      if (!visited.has(vertex)) {
        visited.add(vertex)
        result.push(vertex)
        queue.push(
          ...this.getNeighbors(vertex)
            .map(([neighbor]) => neighbor)
            .filter((neighbor) => !visited.has(neighbor)),
        )
      }
    }

    return result
  }

  dfs(startVertex: T): T[] {
    const visited = new Set<T>()
    const stack: T[] = [startVertex]
    const result: T[] = []

    while (stack.length > 0) {
      const vertex = stack.pop()!
      if (!visited.has(vertex)) {
        visited.add(vertex)
        result.push(vertex)
        stack.push(
          ...this.getNeighbors(vertex)
            .map(([neighbor]) => neighbor)
            .filter((neighbor) => !visited.has(neighbor)),
        )
      }
    }

    return result
  }

  dijkstra(
    startVertex: T,
    endVertex: T,
  ): { distance: number; path: T[] } | null {
    const distances = new Map<T, number>()
    const previous = new Map<T, T | null>()
    const pq: [number, T][] = []

    distances.set(startVertex, 0)
    this.getVertices().forEach((vertex) => {
      if (vertex !== startVertex) {
        distances.set(vertex, Infinity)
      }
      previous.set(vertex, null)
    })

    pq.push([0, startVertex])

    while (pq.length > 0) {
      pq.sort((a, b) => a[0] - b[0])
      const [currentDistance, currentVertex] = pq.shift()!

      if (currentVertex === endVertex) {
        const path: T[] = []
        let vertex: T | null = endVertex
        while (vertex !== null) {
          path.push(vertex)
          vertex = previous.get(vertex) ?? null
        }
        return { distance: currentDistance, path: path.reverse() }
      }

      if (currentDistance > distances.get(currentVertex)!) {
        continue
      }

      for (const [neighbor, weight] of this.getNeighbors(currentVertex)) {
        const distance = currentDistance + weight
        if (distance < distances.get(neighbor)!) {
          distances.set(neighbor, distance)
          previous.set(neighbor, currentVertex)
          pq.push([distance, neighbor])
        }
      }
    }

    return null
  }

  clear(): void {
    this.adjacencyList.clear()
  }
}

export { WeightedGraph }
```

</CodeGroup>