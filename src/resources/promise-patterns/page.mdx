export const metadata = {
  title: 'Understanding Promise Patterns',
  description:
    'Master complex Promise patterns including parallel execution, sequencing, error handling strategies, and cancellation patterns.',
}

# **Promise Patterns**

Advanced Promise patterns enable sophisticated asynchronous operations in JavaScript. Understanding these patterns is crucial for handling complex async scenarios effectively.

## **Core Patterns**

**Key Categories:**

1. **Concurrency Control**: Parallel vs sequential
2. **Error Management**: Recovery and fallbacks
3. **Cancellation**: Abort patterns
4. **Rate Limiting**: Throttling promises
5. **Caching**: Promise memoization

## **Implementation Patterns and Best Practices**

<CodeGroup>

```ts
// Parallel Execution Patterns
class ParallelExecutor {
  // Limited concurrency
  static async withLimit<T>(
    tasks: Array<() => Promise<T>>,
    limit: number,
  ): Promise<T[]> {
    const results: T[] = []
    const executing = new Set<Promise<void>>()

    for (const [i, task] of tasks.entries()) {
      const promise = task().then((result) => {
        results[i] = result
        executing.delete(promise)
      })

      executing.add(promise)

      if (executing.size >= limit) {
        await Promise.race(executing)
      }
    }

    await Promise.all(executing)
    return results
  }

  // Batch processing
  static async inBatches<T>(
    items: T[],
    batchSize: number,
    processor: (item: T) => Promise<any>,
  ): Promise<any[]> {
    const results: any[] = []

    for (let i = 0; i < items.length; i += batchSize) {
      const batch = items.slice(i, i + batchSize)
      const batchResults = await Promise.all(batch.map(processor))
      results.push(...batchResults)
    }

    return results
  }
}

// Error Handling Patterns
class ErrorHandler {
  // Retry with exponential backoff
  static async withRetry<T>(
    operation: () => Promise<T>,
    retries: number = 3,
    baseDelay: number = 1000,
  ): Promise<T> {
    let lastError: Error

    for (let i = 0; i < retries; i++) {
      try {
        return await operation()
      } catch (error) {
        lastError = error as Error
        if (i < retries - 1) {
          const delay = baseDelay * Math.pow(2, i)
          await new Promise((resolve) => setTimeout(resolve, delay))
        }
      }
    }

    throw lastError!
  }

  // Fallback chain
  static async withFallback<T>(
    primary: () => Promise<T>,
    ...fallbacks: Array<() => Promise<T>>
  ): Promise<T> {
    try {
      return await primary()
    } catch (error) {
      if (fallbacks.length === 0) throw error
      return this.withFallback(fallbacks[0], ...fallbacks.slice(1))
    }
  }
}

// Cancellation Pattern
class CancellablePromise<T> {
  private controller: AbortController

  constructor(private executor: (signal: AbortSignal) => Promise<T>) {
    this.controller = new AbortController()
  }

  execute(): Promise<T> {
    return this.executor(this.controller.signal)
  }

  cancel(): void {
    this.controller.abort()
  }

  static timeout<T>(promise: Promise<T>, ms: number): CancellablePromise<T> {
    return new CancellablePromise(async (signal) => {
      const timeoutId = setTimeout(() => {
        if (!signal.aborted) {
          this.controller.abort()
        }
      }, ms)

      try {
        return await promise
      } finally {
        clearTimeout(timeoutId)
      }
    })
  }
}

// Rate Limiting Pattern
class RateLimiter {
  private queue: Array<() => Promise<any>> = []
  private processing = false
  private lastExecuted: number = 0

  constructor(
    private maxRequestsPerInterval: number,
    private interval: number,
  ) {}

  async add<T>(task: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      this.queue.push(async () => {
        try {
          resolve(await task())
        } catch (error) {
          reject(error)
        }
      })

      this.process()
    })
  }

  private async process(): Promise<void> {
    if (this.processing) return
    this.processing = true

    while (this.queue.length > 0) {
      const now = Date.now()
      const timeSinceLastExecution = now - this.lastExecuted

      if (timeSinceLastExecution < this.interval) {
        await new Promise((resolve) =>
          setTimeout(resolve, this.interval - timeSinceLastExecution),
        )
      }

      const batch = this.queue.splice(0, this.maxRequestsPerInterval)
      await Promise.all(batch.map((task) => task()))
      this.lastExecuted = Date.now()
    }

    this.processing = false
  }
}

// Promise Cache Pattern
class PromiseCache<T> {
  private cache = new Map<string, Promise<T>>()
  private timestamps = new Map<string, number>()

  constructor(private ttl: number = 5 * 60 * 1000) {}

  async get(key: string, factory: () => Promise<T>): Promise<T> {
    this.clearExpired()

    if (!this.cache.has(key)) {
      const promise = factory().catch((error) => {
        this.cache.delete(key)
        this.timestamps.delete(key)
        throw error
      })

      this.cache.set(key, promise)
      this.timestamps.set(key, Date.now())
    }

    return this.cache.get(key)!
  }

  private clearExpired(): void {
    const now = Date.now()
    for (const [key, timestamp] of this.timestamps.entries()) {
      if (now - timestamp > this.ttl) {
        this.cache.delete(key)
        this.timestamps.delete(key)
      }
    }
  }
}

// Progressive Loading Pattern
class ProgressiveLoader<T> {
  constructor(private loader: () => AsyncGenerator<T, void, unknown>) {}

  async *load(): AsyncGenerator<T, void, unknown> {
    const iterator = this.loader()

    try {
      while (true) {
        const { value, done } = await iterator.next()
        if (done) break
        yield value
      }
    } finally {
      await iterator.return?.()
    }
  }
}

// Example Usage
async function example() {
  // Parallel execution with limit
  const tasks = [
    () => Promise.resolve(1),
    () => Promise.resolve(2),
    () => Promise.resolve(3),
  ]
  const results = await ParallelExecutor.withLimit(tasks, 2)

  // Error handling with retry
  const result = await ErrorHandler.withRetry(async () => {
    const response = await fetch('https://api.example.com')
    if (!response.ok) throw new Error('API error')
    return response.json()
  })

  // Cancellable operation
  const cancellable = new CancellablePromise(async (signal) => {
    const response = await fetch('https://api.example.com', {
      signal,
    })
    return response.json()
  })

  const promise = cancellable.execute()
  // Later: cancellable.cancel()

  // Rate limiting
  const limiter = new RateLimiter(5, 1000) // 5 requests per second
  await limiter.add(() => fetch('https://api.example.com'))

  // Promise caching
  const cache = new PromiseCache()
  const data = await cache.get('key', () =>
    fetch('https://api.example.com').then((r) => r.json()),
  )

  // Progressive loading
  const loader = new ProgressiveLoader(async function* () {
    for (let i = 0; i < 100; i += 10) {
      yield await fetch(`https://api.example.com/data?offset=${i}`).then((r) =>
        r.json(),
      )
    }
  })

  for await (const chunk of loader.load()) {
    console.log('Loaded chunk:', chunk)
  }
}
```

</CodeGroup>

The implementations above demonstrate various Promise patterns:

1. **Parallel Execution**: Controlled concurrency
2. **Error Handling**: Retry and fallback strategies
3. **Cancellation**: Abort controller usage
4. **Rate Limiting**: Request throttling
5. **Caching**: Promise memoization
6. **Progressive Loading**: Chunked data loading
7. **Batch Processing**: Grouped operations
8. **Type Safety**: Full TypeScript support

Each implementation shows advanced Promise patterns while maintaining:

- Error handling
- Resource management
- Performance optimization
- Type safety
- Clean code practices

These patterns help create robust asynchronous operations in JavaScript applications.
